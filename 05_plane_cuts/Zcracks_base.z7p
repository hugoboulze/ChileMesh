void init_var()
{
  // Global variables
  global int built_advanced_plot_dialog;
  global int built_advance_propag_dialog;
  global int built_edit_propag_coeff_dialog;
  global int built_edit_propag_script_dialog;
  global int built_hexa_dialog, built_hexa_help_dialog;
  global int built_quad_dialog, built_quad_help_dialog;
  global STRING crack_name,   // Name of the crack surface mesh .geo
                sane_name,    // Name of the initial uncracked mesh .geo
                cracked_name, // Name of the final initial cracked mesh .geo
                surf_mesh;    // Name of crack surface mesh for crack conversion

  global int    branch_id,max_branch; // For multiple branch propagation
  global LIST<VECTOR> branches_DX,branches_DY;
  global LIST<int>    branches_base_front,branches_number;
  global ARRAY<VECTOR> base_fronts;
  global double Ncycles,DNcycles,Nexplicit;

  global LIST<STRING> zcpost_fields; // Fields read in the ZCPOST files
  global LIST<double> zcpost_times; // Time cards read in the ZCPOST files
  global LIST<int> zcpost_ids; // front ids read in the ZCPOST files
  global int  zcpost_nfronts;
  global ARRAY<int> select_fields,select_times,select_fronts; // Time cards read in the ZCPOST files
  global STRING zcpost_file;

  global STRING bc_conditions; // BC that must be set with write_SIF

  global STRING yams_prefix,MedVersion;

  global STRING elset_name,   // Name of the remeshed part usually set to AUTO (means it can be defined)
                faset_names, liset_names,nset_names,elset_names, // List of sets that must be kept
                ridge_names, topo_names,geom_names, // Geom info for remeshing
                sym_bset, // For symmetric plane insertion experimental
                bset_to_elset,extrude_top,extrude_bottom,bset_boundary,liset_slider_name, // For shell cases
                nset_not_to_cut,elset_to_cut,elset_inside,delamin_set,trace_elset, // For specific cutting
                mat_file,slice_name,intersection_mesh; // for transfer and woven composite

  // read in a templated external inp as stuff to be preserved
  global int needs_read_template, finite_strain, is_plastic;
  global ARRAY<STRING> faset_names_from_template, nset_names_from_template, geom_names_from_template;

  // read in dtpl in some cases (eg. samcef)
  global LIST<STRING> material_elsets, material_files;

  global STRING material_from_template;
  global int max_node_id, max_ele_id;
  global STRING thermal_field; // Zebulon results files name (without .ut) containg temperatures
  global int cur_cyc; // used to update the .remesh file during propag

  global int if_Dwpe, if_dislo, use_pp; // Integral for VM, and use post-processing

  global STRING distance_file,fiber_files; // To cut with explicit distance file
  global STRING refine_function,refine_origin;
  global STRING local_frame_fname_from_template;
  global STRING temperature_name;
  global double distance_grad,fuse_length;

  global int non_local;
  global int if_meshgems,nb_dd;

  global STRING editor, fe_command, qsub_file_name;
  global STRING os, cop_cmd, del_cmd;
  global int smp, front_view,nb_pt,o_nb_pt,front_plane;
  global int embedded;

  // New Zcracks version based on cut.sh
  global int new_version;
  global STRING refinement_datafile;
 
  // Runs only in templated mode (Abaqus, ansys users)
  // Also simplifies interface
  global int only_templated;
  
  // Z-cracks scripts without GUI 
  global int batch_mode;

  // Meshing parameters
  global STRING yams_options,optim_style,optim_1st;
  global double filter_tol,grid_max,lip_tol,refine_radius,tol_cut,gradation; 
  global double elset_radius,max_size,min_size,max_quality,quality_threshold;
  global double constant_density,smooth_elset_radius, max_kink_angle;
  global int nb_iter,nb_velem,if_remesh_surface;
  global int if_grid,if_barsoum,if_var_refine,if_quad,if_must_define_elset,if_remove,
    if_growing_elset,if_moving_elset, if_refine_only, if_must_refine, if_pyra,if_surface_refine, if_hexa;
  global int if_no_open,if_output_surface,if_esh,if_meshcleaner,if_front_check,if_contact_correction,if_add_mpc_for_contact;
  global int if_smooth_region,if_quadrangles;

  // Meshers applied before/after remeshing stage in drive_crack
  global STRING before_remeshing,after_remeshing;

  // Current ellipical crack definition
  // Postions and geometry dir= direction of the grand axis (ra)
  global int crack_id,if_ellipse;
  global VECTOR center,normal,dir;
  global double ra,rb,hmin,rmax,sigy,gth_radius;

  // New smoothing for propag parameters
  global int smooth_propag,if_remove_ext_propag,remove_ext_hexa,if_dGda; // Second term for better propag law integration
  global ARRAY< VECTOR > front_Mextra_info;

  // For 2D problem
  global VECTOR thickness;
  global double shell_offset;

  global int if_ebe,nb_ext,nb_fronts;
  // Options for CZM
  global int if_keep,if_czm,if_2D,if_ghs_only,if_fuse_import,if_2DE,if_shell;
  //NR
 global double cz_process_time, damage_min, damage_max,cz_gtheta_process_time; //NRNR cz_process_time is used in case the computation step breaks all the czm i.e the zcracks front will coincide with the process zone front
  global STRING czm_var_name, interface_elements_name; //ex : lambda_max
  global double adv_t, adv_f; // for write_czm_advance (t: transverse, f: front)

  global int arch;

  global double TIP_radius;
  global int nb_fnodes,hnumber;
  global double hradius,n_length;
  global int if_K,if_Ki,if_mpa_m,if_Gmax,if_exclude_BE,if_contact,nb_cycles;

  global LIST<STRING> propag_models, propag_filters;
  global POINTER propag_law, propag_filter;
  global LIST<COEFF> propag_coefficients;
  global ARRAY<STRING> propag_coef_names;
  global STRING propag_model, old_propag_model, propag_script, propag_mat_file, 
    filter_type, filter_inp;
  global POINTER paris_C, paris_m;
  global double tau;

  global STRING contact_cmds;

  global double paris_DN,max_h,ext_dist,lip_factor;
  global double fatigue_Ti,fatigue_DT,fact_nc;
  global double power_func_coef;
  global int if_ext,if_lip_factor,if_transfert,if_separate;
  global STRING debug;

  global STRING datafile;
  int ret;
  STRING version, search, str;
  global ARRAY<STRING> data_files;

  global STRING Zmaster;

  global int from_quad,import_remesh;
  global double scale,angle_criterion;
  global STRING format, distene_path, cut_exe;
  global LIST<STRING> import_formats;
  
  global int qsubserver;
  global STRING ZRUN_CMD,SQS_RUN_SERVER_NAME_QUEUE,SQS_RUN_SERVER_FILE_STATE;

  global ARRAY<VECTOR> ofronts,saved_fronts;
  global MATRIX oGvalues,extraGvalues,saved_Gvalues;
  global int extrafield,saved_extrafield;
  global double interp_coef;

  global int user_extention;
  global VECTOR load_factor;
 
  ARRAY<STRING> tmp_string;
  global int quad_opt;

  //hexa torus options
  global int nb_hexa, th_hexa, nc_hexa;
  global double dr_hexa, prog_hexa;

  user_extention=0;
  str = getenv("ZCRACKS_PROPRIETARY");
  if(!str) user_extention = 1;

  // Explicit DN propagation
  Nexplicit=0.;

  // New version
  new_version=1;
  only_templated=0;
  if_meshgems=1;

  batch_mode=0;

  // branch index and max number of created branches for branching propagations
  branch_id=0;
  max_branch=1;

  //CZM front traking options :
  damage_min = 0.01; //0.8 ;
  damage_max = 1.; //1.; //0.04;
  cz_process_time = 2.; //retour.. closed front
  czm_var_name = "lambda_max";
  interface_elements_name="INTERFACE";
  cz_gtheta_process_time = 1.; // Kmax
 
  // qsubserver for batch mode
  qsubserver=27401;
  ZRUN_CMD="Zrun ";
  
  // OS veriable only defined on windows
  // cop_cmd is used for ***shell commands in inp
  os = getenv("OS");
  if(os=="Windows_NT") {
     os = "win32";
     cop_cmd = "COPY ";
     del_cmd = "DEL ";
	 if(if_meshgems) distene_path = getenv("Z7PATH")+"/win64/Zmesh/bin/";
	 else            distene_path = getenv("Z7PATH")+"/win32/Zmesh/DISTENE/Tools/bin/";
     cut_exe = "cut.exe";
  }
  else {
     os = getenv("Z7MACHINE");
     cop_cmd = "cp -f ";
     del_cmd = "rm -f ";
     distene_path = getenv("Z7PATH")+"/PUBLIC/lib-"+getenv("Z7MACHINE")+"/Zmesh/bin/";
     cut_exe = "cut";
  }

  //yams_prefix="qsub"; 

  //Zmaster="Zmaster -gl ";
  Zmaster="Zmaster ";

  MedVersion="";
  zcpost_file="cracked_GPP_PROPAG[1:1:1].ZCPOST";
  fuse_length=-1.5;
  nb_dd=0;
  if_meshcleaner=0;
  if_front_check=0;
  if_contact_correction=1;
  if_add_mpc_for_contact=1;
  refine_origin="";
  extrafield=0;
  use_pp=0;
  nb_pt=16;
  o_nb_pt=-1;
  interp_coef=-1.;
  if_Dwpe=0;
  if_dislo=0;
  if_esh=0;
  refinement_datafile="";
  if_ebe=0;
  hmin=1.e50;
  gth_radius=0.;
  rmax=0.;
  sigy=0.;
  non_local=0;
  nb_ext=0;
  if_refine_only=0;
  if_remove=1;
  if_grid=1;
  debug="NO";
  format="abaqus_templated";
  scale=1.;
  angle_criterion=0.;
  from_quad=0;
  import_remesh=0;
  if_ghs_only=0;
  if_fuse_import=0;
  if_barsoum=0;
  if_must_refine=0;
  if_moving_elset=1;
  if_growing_elset=1;
  if_var_refine=0;
  gradation=1.3;
  nb_velem=3;
  constant_density=0.;
  max_kink_angle=90.;
  tol_cut=0.;
  if_no_open=0;
  if_remesh_surface=0;
  if_output_surface=0;
  needs_read_template=1;
  max_node_id=0;
  max_ele_id=0;
  cur_cyc=0;
  finite_strain = 0;
  is_plastic=0;
  if_pyra=1;
  if_surface_refine=0;

  smp=1;

  distance_grad=0.;
  TIP_radius=0.;
  if_separate=1;
  front_view=0;
  front_plane=0;
  if_czm=0;
  if_keep=0;
  ret=0;
  if_2D=0;
  if_shell=0;
  if_smooth_region=0;
  if_quadrangles=0;

  arch = 1;  //0 - 32 bits, 1 - 64 bits

  init_values(0);

  // Init vectors
  center.resize(3);
  normal.resize(3);
  dir.resize(3);
  center=0.;
  normal=0.;
  dir=0.;
  thickness.resize(0); 
  shell_offset=0.;

  import_formats.reset();
  if(!only_templated) {
     import_formats.add("med");
     import_formats.add("mesh");
     import_formats.add("abaqus");
  }
  import_formats.add("abaqus_templated");
  import_formats.add("ansys_templated");
  import_formats.add("aster_templated");
  import_formats.add("samcef_templated");
  import_formats.add("zebulon_templated");

  object_factory_keywords("ZCRACKS_PROPAG_LAW",tmp_string);
  propag_models.add("paris_std");
  for(i=0;i<!tmp_string;i++) propag_models.add(tmp_string[i]);

  object_factory_keywords("ZCRACKS_FILTER",tmp_string);
  propag_filters.add("no_filter");
  for(i=0;i<!tmp_string;i++) propag_filters.add(tmp_string[i]);

  init_var_ductile();
  if(user_extention) { init_var_extention(); }
  built_advanced_plot_dialog = 0;
  built_advance_propag_dialog = 0;
  built_edit_propag_coeff_dialog = 0;
  built_edit_propag_script_dialog = 0;
  built_hexa_dialog = 0;
  built_hexa_help_dialog = 0;
  built_quad_dialog = 0;
  built_quad_help_dialog = 0;
}

int get_cycles_info_from_zck(int cyc, double &N, double &DN)
{ 
  ASCII_FILE asc;
  STRING name,line;
  int i,icyc,iferr=0;
  
  name = cracked_name + "_PROPAG.zck";
  asc.open(name);

  N=0;
  DN=0;
  if(cyc<-1) return(0);

  if(asc.ok) {
     for(i=0;i>=0;i++) {
        line = asc.getline();
        if(!asc.ok) break;
        if(!line<2) continue;
        cur_line = line;
        cyc_str = line.getSTRING();
        N=line.getdouble();
        if(!asc.ok) { iferr=1; break; }
        DN=line.getdouble();
        if(!asc.ok) { iferr=1; break; }
        icyc=line.getint();
        if(!asc.ok) { iferr=1;true; break; }
        if(icyc==cyc) { break; }
     }
  } return(0); // First cycle or empty zck

  if(if_err) { ERROR("Error reading zck file: "+name); return(-1); }

  if(icyc==cyc) return(0);

  return(1);

}

void init_var_ductile(){
  // Global variables for ductile Z-cracks
  // These variables are defined here in order to be used in the functions used by both fatigue and ductile crack interfaces implemented in this file
  // initialise all of them to the 0 or 0. and reinitialise to their real value in the ductile interface

  //this function is called from principal init_var
  //we can move this function to Zcracks_base_ductile.z7p, but in this case it will be necessary to include the latter in the Zcracks.z7p

  global int is_ductile, if_CTOA, set_reduced, if_suppress_old_res;
  global double ductile_Tt,ductile_DT, CTOA_distance;

  is_ductile=0;
  set_reduced=0;
  if_CTOA=0;
  if_suppress_old_res=0;

  ductile_Tt=0.;
  ductile_DT=0.;
  CTOA_distance=1.;
}

// We use Catmull-Rom splines with specified tension
void cat_mat(MATRIX &CM,double loc_tau)
{
  CM.resize(4,4);
  CM(0,0) = 0.;      CM(0,1) = 1.;      CM(0,2) = 0.;         CM(0,3) = 0.;
  CM(1,0) = -loc_tau;    CM(1,1) = 0.;      CM(1,2) = loc_tau;        CM(1,3) = 0.;
  CM(2,0) = 2.*loc_tau;  CM(2,1) = loc_tau-3.;  CM(2,2) = 3.-2.*loc_tau;  CM(2,3) = -loc_tau;
  CM(3,0) = -loc_tau;    CM(3,1) = 2.-loc_tau;  CM(3,2) = loc_tau-2.;     CM(3,3) = loc_tau;
}

// For easy intersection between elsets
// Provide a simple function to perform mesh intersections
void intersect(STRING &mesh_name)
{
  STRING mesher;
  int ifnop=if_no_open;

  // Add the MICRO elset
  mesher="  **remove_set *elsets MICRO \n **elset MICRO *function 1.;\n";
  apply_mesher(mesh_name,mesh_name,mesher);
  mesher="  **elset todel *function 1.;\n";
  mesher=mesher+"  **remesh_elset_skin *elset "+elset_names+" ALL_ELEMENT\n";
  mesher=mesher+"  **delete_elset todel\n";
  mesher=mesher+"  **degenerated_elset **delete_elset DEGENERATED_ELEMENTS\n";

  apply_mesher(mesh_name,"INPUT_SURFACE.geo",mesher);
  convert_surface("INPUT_SURFACE.geo");

  if_no_open=1;
  mesher=elset_names;
  elset_names=elset_names+" MICRO";
  intersection_mesh=mesh_name;
  nice_cut(max_quality);
  intersection_mesh="";
  if_no_open=ifnop;
  elset_names=mesher;
  mesher="**remove_set *bsets INTERFACE_MICRO INTERFACE_MICRO0 SURFACE \n";
  mesher=mesher+"**unshared_faces SURFACE **unshared_faces INTERFACE_MICRO0 *elsets MICRO \n";
  mesher=mesher+"**join_bsets INTERFACE_MICRO *bsets INTERFACE_MICRO0 SURFACE *remove *remove_duplicates \n";
  mesher=mesher+"**elset_near_nset *nset INTERFACE_MICRO *radius "+dtoa(50.*min_size)+" *distance_file INTERFACE_DST \n";
  mesher=mesher+"**remove_set *bsets INTERFACE_MICRO0 *elsets MACRO\n";
  mesher=mesher+"**elset MACRO *use_elsets ALL_ELEMENT *not_in_elsets MICRO \n";

  apply_mesher(cracked_name+".geo",cracked_name+".geo",mesher);
}


// For MICHELIN
STRING remove_crack_from_sets() {
  STRING out_mesh,list,set,mesher1,mesher2s,mesher2f,mesher3;
  int i,max_front;

  max_front=32;

  mesher1="**remove_set *bsets WORK_BSET \n **join_bsets WORK_BSET *remove *remove_duplicates \n *bsets ";
  mesher2s=" SIDE0 SIDE1 \n **remove_set *bsets ";
  mesher2f=" FRONT_TR \n **remove_set *bsets ";
  mesher3=" \n **rename_set *bsets WORK_BSET ";

  out_mesh="**remove_set *bsets FRONT_TR \n **join_bsets FRONT_TR *remove_duplicates *bsets ";
  for(i=0;i<max_front;i++) out_mesh=out_mesh+"FRONT"+itoa(i)+" ";
  out_mesh=out_mesh+"\n";
  out_mesh=out_mesh+"**remove_set *bsets Nlip \n";

  // SIDES
  list=faset_names;
  for(i=0;i>=0;i++) {
    set=list.getSTRING();
    if(set=="") break;
    out_mesh=out_mesh+"\n "+mesher1+set+mesher2s+set+mesher3+set+"\n ";
  }

  // FRONT
  list=liset_names;
  for(i=0;i>=0;i++) {
    set=list.getSTRING();
    if(set=="") break;
    out_mesh=out_mesh+"\n "+mesher1+set+mesher2f+set+mesher3+set+"\n ";
  }

  out_mesh=out_mesh+"\n **remove_set *bsets FRONT_TR \n";
  return out_mesh;
}

// Extend vector to buid Catmull-Rom interpolation
void extend_vector(VECTOR &data0,VECTOR &data,int if_closed)
{
  int i,n;
  double x;

  n=data0.size();
  data.resize(n+2);
  for(i=0;i<n;i++) {
    data[i+1]=data0[i];
  }
 
  if(n==1) {
    data.resize(4);
    data=data0[0];
  } else if(if_closed) {
    // Closed VECTOR
    data[0]=data0[n-2];
    data[n+1]=data0[1];
  } else {
    data[0]=2.*data0[0]-data0[1];
    data[n+1]=2.*data0[n-1]-data0[n-2];
  }
}

void extend_matrix(MATRIX &data0,MATRIX &data,int if_closed)
{
  int i,j,n,m;
  double x;

  n=data0.n;
  m=data0.m;
  data.resize(n+2,m);
  if(n==1) data.resize(4,m);
  
  for(j=0;j<m;j++) {
    for(i=0;i<n;i++) {
      data(i+1,j)=data0(i,j);
    }
    if(n==1) {
      data(0,j)=data0(0,j);
      data(n+1,j)=data0(0,j);
    } else if(if_closed) {
      // Closed VECTOR
      data(0,j)=data0(n-2,j);
      data(n+1,j)=data0(1,j);
    } else {
      data(0,j)=2.*data0(0,j)-data0(1,j);
      data(n+1,j)=2.*data0(n-1,j)-data0(n-2,j);
    }
  }
}

double catmull(double &x,VECTOR &data,MATRIX &CM) 
{
  int iseg;
  double val,u;
  
  // Localize in segment
  iseg=x;
  if(iseg<0) iseg=0;
  if(iseg>data.size()-4) iseg=data.size()-4;
  u=iseg;
  u=x-u;

  // Compute 
  p=CM*p;
  val=data[iseg]+u*(data[iseg+1]+u*(data[iseg+2]+u*data[iseg+3]));

  return(val);
}

void catmullV(double &x,MATRIX &data,MATRIX &CM,MATRIX& val)
{
  int iseg,i,j,m,n;
  double u;
  MATRIX p,v;

  m=data.m;
  n=data.n;

  // Localize in segment
  iseg=x;
  if(iseg<0) iseg=0;
  if(iseg>n-4) iseg=n-4;
  u=iseg;
  u=x-u;

  // Set vector
  p.resize(4,m);
  for(j=0;j<m;j++) {
    for(i=0;i<4;i++) p(i,j)=data(iseg+i,j);
  }

  // Compute
  v.resize(1,4);
  val.resize(1,m);
  v(0,0)=1.;
  v(0,1)=u;
  v(0,2)=u*u;
  v(0,3)=u*v(0,2);

  val=v*CM*p;
}

// Read front file and apply Catmull-Rom interpolation for nb_point output
int reshape_front(STRING &front_in,STRING &front_out, int nbpt)
{
  ASCII_FILE fin;
  double s,x,xstep;
  int n0,i,j,stage,ntot,ifc;
  Zfstream f;
  MATRIX vals,nvals,CM,data,data0,interp;
  VECTOR P0,P1;

  P0.resize(3);
  P1.resize(3);
  ifc=0; // Not closed front by default

  // Compute interpol mat
  cat_mat(CM,tau);

  //  # s x y z G T angle KI KIii KIIii KIIIii Gii
  fin.open(front_in);
  if(!fin.ok) {
    ERROR("Unable to find "+front_in+" file");
    return(0);
  }
  for(n0=0;n0>=0;n0++) {
    s = fin.getdouble(); // N
    if(!fin.ok) break;
    for(j=1;j<12;j++) fin.getdouble();
  }
  fin.close();

  if(n0<nbpt) {
    // Not enough point
    stage=nbpt/n0;
    if(stage<=2) stage=2;
    xstep=stage;
    xstep=1./stage;
    ntot=(n0-1)*stage+1;
    vals.resize(n0,12);
    nvals.resize(ntot,12);
    // Now get data and build
    fin.open(front_in);
    for(i=0;i<n0;i++) {
      for(j=0;j<12;j++) vals(i,j)=fin.getdouble();
    }
    fin.close(front_out);
    for(i=0;i<3;i++) P0[i]=vals(0,i);
    for(i=0;i<3;i++) P1[i]=vals(n0-1,i);
    P0=P1-P0;
    if((P0|P0)<=1.e-14) ifc=1;
    else ifc=0;
    data0.resize(n0,12);
    data.resize(n0+2,12);
    // Fill data0
    for(j=0;j<12;j++) {
      for(i=0;i<n0;i++) {
        data0(i,j)=vals(i,j);
      }
    }
    // Extends
    extend_matrix(data0,data,ifc);
    // Set step
    x=0.;
    // Now build new values
    for(i=0;i<ntot;i++) { 
      catmullV(x,data,CM,interp); 
      for(j=0;j<12;j++) {
        nvals(i,j)=interp(0,j);
      }
      x=x+xstep;
    }
    f.open(front_out,ios::out);
    f.setf(ios::scientific);
    f.precision(64);
    f<<"# Reshaped file with CM interpolation with at least "<<nbpt<<" points"<<endl;
    f<<"# s x y z G T angle KI KIii KIIii KIIIii Gii"<<endl;
    for(i=0;i<ntot;i++) {
      for(j=0;j<12;j++) f<<nvals(i,j)<<" ";
      f<<endl;
    }
    f.close();
  } else STD_CP(front_in,front_out);


  return(1);
}

// Read zck file and apply Catmull-Rom interpolation for nb_point output
int reshape_zck(STRING &zck_in,STRING &zck_out, int nbpt,double N0,double Cf)
{
  ASCII_FILE zck;
  STRING zckni,timei,last_line;
  Zfstream f;
  double N, dN,x,xstep,tmp;
  int i, cyc, np, npi, nf, j, k, l,h,ifc,npp;
  MATRIX vals,nvals,CM,data0,data,interp;
  VECTOR P0,P1;
  LIST<int> true_point;

  P0.resize(3);
  P1.resize(3);
  ifc=0; // Not closed front by default

  // Compute interpol mat
  cat_mat(CM,tau);

  cout << "Catmull-Rom reshaping ZCK file"<<endl;

  zck.open(zck_in);
  f.open(zck_out,ios::out);
  f.setf(ios::scientific);
  f.precision(64);
  
  if(!zck.ok) {
     cout<<endl<<"Cannot open ZCK file: "<<zck_in<<endl<<endl;
     return(0);
  }
  f<<"# Reshaped file with CM interpolation and "<<nbpt<<" points for each front"<<endl;
  f << "# Zcracks propagation informations" << endl;
  f << "# 1:N 2:DeltaN 3:icycle 4:time 5:point_nb 6:front_nb (front_nb)x{ (point_nb)x{  7+(point_nb*12)*fid:3Dpos 7+(point_nb*12)*fid+3:clength 7+(point_nb*12)*fid+4:3Dincr 7+(point_nb*12)*fid+7:delta_length 7+(point_nb*12)*fid+8:Kmin 7+(point_nb*12)*fid+9:Kmax 7+(point_nb*12)*fid+10:Tmin 7+(point_nb*12)*fid+11:Tmax" << endl;
  for(i=0;i>=0;i++) {
     cout <<"."<<flush;
     N = zck.getdouble(); // N
     if(!zck.ok) break;
     N=N*Cf+N0;
     dN = zck.getdouble(); // dN
     dN=Cf*dN;
     cyc = zck.getint();
     time=zck.getSTRING(); // time
     np = zck.getint();
     nf = zck.getint();
     npi=nbpt;
     if(np<2) npi=np;  
     f << N << " " << dN << " " << cyc << " " << time << " " << npi << " " << nf << " ";
     N=N+dN;
     cyc=cyc+1;
     last_line = dtoa(N)+" "+dtoa(dN)+" "+itoa(cyc)+" "+time+" "+itoa(npi)+" "+itoa(nf)+" ";
     for(j=0;j<nf;j++) {
       vals.resize(np,12);
       nvals.resize(npi,12);
       for(k=0;k<np;k++) {
         for(l=0;l<12;l++) vals(k,l)=zck.getdouble(); 
       }
       if(npi==2) {
         // Nothing to do!
         for(k=0;k<np;k++) {
           for(l=0;l<12;l++) nvals(k,l)=vals(k,l);
         }
       } else {
         // Analyse provided data based on front
         true_point.reset();
         true_point.add(0);
         for(l=0;l<3;l++) P0[l]=vals(0,l);
         for(k=1;k<np;k++) {
           for(l=0;l<3;l++) P1[l]=vals(k,l);
           P0=P1-P0;
           if((P0|P0)>1.e-14) true_point.add(k);
           P0=P1;
         }
         // Set if_closed
         for(l=0;l<3;l++) P0[l]=vals(0,l);
         for(l=0;l<3;l++) P1[l]=vals(true_point[true_point.size()-1],l);
         P0=P1-P0;
         if((P0|P0)<=1.e-14) ifc=1;
         else ifc=0;
         // True number of points in input data
         npp=true_point.size();
         data0.resize(npp,12);
         data.resize(npp+2,12);
         // Loop on each field
         for(l=0;l<12;l++) {
           // Fill data0
           for(k=0;k<npp;k++) {
             data0(k,l)=vals(true_point[k],l);
           }         
         }        
         // Extends
         extend_matrix(data0,data,ifc);
         // Set step
         xstep=npp-1;
         x=npi-1;
         if(x<=0) xstep=0;
         else xstep=xstep/x;
         x=0.;
         // Now build new values
         for(k=0;k<npi;k++) {
           catmullV(x,data,CM,interp); 
           for(l=0;l<12;l++) {
             nvals(k,l)=interp(0,l);
           }
           x=x+xstep;
         }
       }
       // Write data
       for(k=0;k<npi;k++) {
         for(l=0;l<12;l++) {
           f << nvals(k,l) << " ";
           if(l<3) tmp=nvals(k,l)+nvals(k,l+4);
           else if(l==3) tmp=nvals(k,3)+nvals(k,7);
           else if((l>=4)&&(l<7)) tmp=0.;
           else tmp=nvals(k,l);
           last_line=last_line+dtoa(tmp)+" ";
         }
       }
     }
     f<<endl;
  }
  // Add last line to plot created new front
  f<<last_line<<endl;
  zck.close();
  f.close();
  cout <<" Done."<<endl;
  return(1);
}


// Post processing for CDM
int compute_Dwpe(STRING &integ_file)
{
  // Mesher + PP must have been written
  STRING cmd;

  cmd=ZRUN_CMD+" -m "+integ_file+"_PPD.inp";
  system(cmd);

  if(smp>1) cmd=ZRUN_CMD+" -pp -smp "+itoa(smp)+" "+integ_file+"_PPD.inp";
  else cmd=ZRUN_CMD+" -pp "+integ_file+"_PPD.inp";

  return(system(cmd));
}

int write_Dwpe(STRING &integ_file,STRING &in_mesh,double &ra,double &rb)
{
  STRING cmd;
  int ret;

  // Write mesher and 
  cmd=    "  **remove_set *bsets INTEG";
  cmd=cmd+"  **elset_near_nset\n";
  cmd=cmd+"   *elset INTEG\n";
  cmd=cmd+"   *nset FRONT\n";
  cmd=cmd+"   *radius "+dtoa(rb)+"\n";
  cmd=cmd+"   *connect\n";
  cmd=cmd+"****return\n";
  cmd=cmd+"****post_processing\n";
  cmd=cmd+" ***data_source Z7\n";
  cmd=cmd+"  **open "+integ_file+".ut\n";
  cmd=cmd+" ***local_post_processing\n";
  cmd=cmd+"   **file integ\n";
  cmd=cmd+"   **elset INTEG\n";
  cmd=cmd+"   **process welaswplas\n";
  cmd=cmd+"     *stress sig\n";
  cmd=cmd+"     *straine eel\n";
  cmd=cmd+"     *straini ein\n";
  cmd=cmd+"     *precision 1.e-3\n";
  cmd=cmd+" ***global_post_processing\n";
  cmd=cmd+"      **elset INTEG \n";
  cmd=cmd+"      **process average *list_var DWp DWe\n";

  cmd=cmd+" ***global_post_processing\n";
  cmd=cmd+"  **file integ\n";
  cmd=cmd+"  **elset INTEG\n";
  cmd=cmd+"  **deformed\n";
  cmd=cmd+"  **process gtheta\n";
  cmd=cmd+"   *crack_front FRONT\n";
  cmd=cmd+"   *ra "+dtoa(ra)+"\n";
  cmd=cmd+"   *rb "+dtoa(rb)+"\n";
  cmd=cmd+"   *nbnodes "+nb_fnodes+"\n";
  cmd=cmd+"   *lip_name SIDE0\n";
  if(if_Gmax)  cmd=cmd+"   *compute_angle\n";
  if(if_ebe)   cmd=cmd+"   *excludeBE\n";
  //cmd=cmd+"   *hmin "+dtoa(hmin)+"\n";
  if(rmax<0.) cmd=cmd+"   *hmin "+dtoa(-1.*rmax)+"\n";
  if(if_K)    cmd=cmd+"   *compute_K\n";
  if(if_Ki)   cmd=cmd+"   *Ki\n";
  if(if_mpa_m) cmd=cmd+"   *mpa_m\n";
  cmd=cmd+"   *sig sig\n";
  cmd=cmd+"   *eto eto\n";
  if((format == "zebulon_templated") + !thermal_field + if_transfert) {
    cmd=cmd+"   *eel eel\n";
  }
  cmd=cmd+"   *wcrack\n";
  cmd=cmd+"   *Dwp DWp\n";
  cmd=cmd+"   *Dwe DWe\n";
  
  if(!temperature_name) {
    tempn=temperature_name;
    if(tempn.start_with("GP_")) tempn=tempn.locate_and_cut_before("GP_");
    else tempn="gp"+tempn;
    cmd=cmd+"   *temperature "+tempn+"\n";
  }
  if(if_contact*if_contact_correction) cmd=cmd+"   *surface CRACK_LIPS\n";
  if(max_kink_angle!=90.) cmd=cmd+"   *max_angle " + max_kink_angle + "\n";
  if(remove_ext_hexa>0)   cmd=cmd+"   *remove_ext_hexa "+remove_ext_hexa+"\n";

  ret=write_mesher(in_mesh,in_mesh+".geo",cmd,integ_file+"_PPD.inp");

  return(ret);
}

// Post processing for MICHELIN
int compute_G_for_michelin(STRING &integ_file,STRING &in_mesh,double &rmax)
{
  STRING cmd;
  Zfstream outfile;

  // Write ut file
  outfile.open(integ_file+".ut",ios::out);
  outfile.setf(ios::scientific);

  outfile<<"**meshfile "<<in_mesh<<"r.geof"<<endl;
  outfile<<"**integ esh11 esh22 esh33 esh12 esh23 esh31 esh21 esh32 esh13"<<endl;
  outfile<<"**element"<<endl;
  outfile<<"1 1 1 1 1."<<endl;
  outfile.close();

  cmd="  **set_reduced\n";
  cmd=cmd+"****return\n";
  cmd=cmd+"****post_processing\n";
  cmd=cmd+" ***data_source Z7\n";
  cmd=cmd+"  **open "+integ_file+".ut\n";
  cmd=cmd+" ***global_post_processing\n";
  cmd=cmd+"  **file integ\n";
  cmd=cmd+"  **elset "+elset_name+"\n";
  cmd=cmd+"  **process gtheta\n";
  cmd=cmd+"   *crack_front FRONT\n";
  if(rmax<=0.)  cmd=cmd+"   *elem_radius "+nb_velem+"\n";
  else cmd=cmd+"   *ra "+dtoa(rmax)+"\n";
  cmd=cmd+"   *nbnodes "+nb_fnodes+"\n";
  cmd=cmd+"   *lip_name SIDE0\n";
  cmd=cmd+"   *esh esh\n";
  cmd=cmd+"   *error\n";
  if(if_Gmax)  cmd=cmd+"   *compute_angle\n";
  if(if_ebe)   cmd=cmd+"   *excludeBE\n";
  cmd=cmd+"   *legacy_zcpost_format\n";
  
  write_mesher(in_mesh,in_mesh+"r.geof",cmd,integ_file+".inp");
  cmd=ZRUN_CMD+" -m "+integ_file+".inp";
  
  system(cmd);

  if(smp>1) cmd=ZRUN_CMD+" -Ni -pp -smp "+itoa(smp)+integ_file+".inp";
  else cmd=ZRUN_CMD+" -Ni -pp "+integ_file+".inp";

  return(system(cmd));
}

// Plot fronts using zck file along propagation
int plot_fronts_zck(int direction)
{
  // Read zck file
  VECTOR xx,yy,zz; 

  Zfstream out; 
  ASCII_FILE inp;
  LIST<double> VN,PX,PY,PZ;
  LIST <int> PN;
  double DK,tmp;
  int i,j,k,l,nfront,nline,npoint;
  STRING line, str;

  nfront=0;
  nline=0;
  npoint=0;

  // Read data
  cout<<"nb_pt : "<<nb_pt<<endl;
  cout<<"nb_fnodes : "<<nb_fnodes<<endl;
  if(nb_pt!=0) {
    reshape_zck(cracked_name+"_PROPAG.zck",cracked_name+"_PROPAG_rs.zck",nb_pt,0.,1.);
    o_nb_pt=nb_pt;
  } else{
    cout<<"nb_pt=nb_fnodes copy files"<<endl;
    STD_CP(cracked_name+"_PROPAG.zck",cracked_name+"_PROPAG_rs.zck");
  }

  inp.open(cracked_name+"_PROPAG_rs.zck");
  inp.add_comment_char("#");

  if(format.end_with("_templated")) {
    STD_MKDIR(cracked_name+"_PROPAG.zres");
  }

  for(i=0;i>=0;i++) {
    DK=inp.getnumeral();
    if(!inp.ok) break;
    tmp=inp.getnumeral(); // DN
    DK=DK-tmp;
    VN.add(DK); // N
    inp.getint(); // icycle
    inp.getnumeral(); // time
    npoint=inp.getint(); // pt
    l=inp.getint(); // front_nb
    //if(l>nfront) nfront=l; // VC CORRECTION BUG WITH TEMPLATED???
    nfront=l;
    l=1;

    //cout << "INFO: " << DK << " " << i << " " << npoint << " " << nfront << flush << endl;
    out.open(cracked_name+"_PROPAG.zres/FRONTS_POSITIONS_"+itoa(i),ios::out);
    out.setf(ios::scientific);
    out.precision(64);
    out<<"# N="<<VN[i]<<endl;
    for(j=0;j<nfront;j++) {
      for(k=0;k<npoint;k++) {
        str=inp.getSTRING();
        if(str!="NaN") {
          if((k==0)) {
            l=fact_nc*DK;
            PN.add(l); 
            if(str.is_int()) tmp=str.to_int();
            else tmp=str.to_double();
            PX.add(tmp);
          }
          out<<str<<" ";
          str=inp.getSTRING();
          if((k==0)) {
            if(str.is_int()) tmp=str.to_int();
            else tmp=str.to_double();
            PY.add(tmp);
          }
          out<<str<<" ";
          str=inp.getSTRING();
          if((k==0)) {
            if(str.is_int()) tmp=str.to_int();
            else tmp=str.to_double();
            PZ.add(tmp);
          }
          out<<str<<endl;
        } else {
          inp.getSTRING();
          inp.getSTRING();
          out<<endl;
        }
        inp.getSTRING();
        inp.getSTRING();
        inp.getSTRING();
        inp.getSTRING();
        inp.getSTRING();
        inp.getSTRING();
        inp.getSTRING();
        inp.getSTRING();
        inp.getSTRING();
        l=l+1;
      }
      out<<endl;
      out<<endl;
    }
    out.close();
  }
  inp.close();

  if(direction==0) {
    str="set title '"+cracked_name+"_PROPAG - FRONTS positions"
            +"'; unset key ; set view equal xyz ; splot ";
    for(i=0;i<VN.size();i++) {
      str=str+"'"+cracked_name+"_PROPAG.zres/FRONTS_POSITIONS_"+itoa(i)+"' w l t 'N="+dtoa(VN[i])+"' ";
      //str=str+"'"+cracked_name+"_PROPAG.zres/FRONTS_POSITIONS_"+itoa(i)+"' w l t 'N="+dtoa(VN[i])+"' ";
      if((i+1)<VN.size()) str=str+",";
    }
    //str=str+"\"";
  } else {
    if(direction==1) line=" u 2:3 ";
    else if(direction==2) line= " u 3:1 ";
    else if(direction==3) line=" u 1:2 ";
    else {
      // Project on normal to dir
      xx=dir*(1./dir.norm());
      zz=normal*(1./normal.norm());
      xx=xx-zz*(xx|zz);
      if((xx|xx)<1.e-12) {
        xx[0]=1.;
        xx=xx-zz*(xx|zz);
        if((xx|xx)<1.e-12) {
          xx[1]=1.;
          xx=xx-zz*(xx|zz);
        }
      }
      xx=xx*(1./xx.norm());
      yy=zz*xx;
      line=" u (";
      for(i=1;i<=3;i++) {
        line=line+"($"+itoa(i)+")*"+dtoa(xx[i-1]);
        if(i<3) line=line+"+";
      }
      line=line+"):(";
      for(i=1;i<=3;i++) {
        line=line+"($"+itoa(i)+")*"+dtoa(yy[i-1]);
        if(i<3) line=line+"+";
      }
      line=line+") ";
      cout << "Crack path projected in (x,y) with x="<<xx<<" y="<<yy<<endl;
    }
    //str="gnuplot -persist -e \"set border linewidth 1.5 ; set style line 1 lc rgb '#0060ad' lt 1 lw 1.5 ; set tics out nomirror scale 0,0.001 ; set mxtics ; set mytics ; set style line 12 lc rgb '#ddccdd' lt 1 lw 1.5 ; set style line 13 lc rgb '#ddccdd' lt 1 lw 0.5 ; set grid xtics mxtics ytics mytics back ls 12, ls 13 ; set xtics 0.5 ; set ytics 0.5 ; set title '"+cracked_name+"_PROPAG - FRONTS positions"
    str=" set grid ; set key outside; set key right top ; set title '"+cracked_name+"_PROPAG - FRONTS positions"
//            +"'; set key outside ; set size ratio -1 ;  plot ";
            +"'; unset key ; set size ratio -1 ;  "; 

    if((gth_radius>0.)&&(rmax>0.)) {
      str=str+" ";
    } else {
     for(i=0;i<PN.size();i++) {
      j=PN[i];
      str=str+"set label '"+itoa(j)+"' at ";
      if(direction==1) str=str+dtoa(PY[i])+","+dtoa(PZ[i]);
      else if(direction==2) str=str+dtoa(PZ[i])+","+dtoa(PX[i]);
      else if(direction==3) str=str+dtoa(PX[i])+","+dtoa(PY[i]);
      else {
        tmp=PX[i]*xx[0]+PY[i]*xx[1]+PZ[i]*xx[2];
        str=str+dtoa(tmp)+",";
        tmp=PX[i]*yy[0]+PY[i]*yy[1]+PZ[i]*yy[2];
        str=str+dtoa(tmp);
      }
      str=str+" center tc ls 0 ;";
     }
    }
    str=str+" plot ";
    for(i=0;i<VN.size();i++) {
      str=str+"'"+cracked_name+"_PROPAG.zres/FRONTS_POSITIONS_"+itoa(i)+"' "+line+" w l t 'N="+dtoa(VN[i])+"' ";
      if((i+1)<VN.size()) str=str+",";
    }
    //str=str+"\"";
  }

  out.open("FRONT_POSITION.gplt",ios::out);
  out<<str<<endl;
  out.close();

  str="gnuplot -e \"load('FRONT_POSITION.gplt'); pause mouse close\" &";
  return(system(str));
}

void run_post_processing()
{ Zfstream inp;

  STRING new_elset_name,cmd,tempn,results_ext;
  int ret;
  double hhmin;

  if(if_esh) apply_mesher(cracked_name,cracked_name,"  **set_reduced");

  new_elset_name = elset_name;
  if( (new_elset_name != "AUTO") && (elset_radius>0.0) ) new_elset_name = "AUTO"; 

  if(format.start_with("abaqus"))      results_ext ="odb";
  else if(format.start_with("ansys"))  results_ext = "rst";
  else if(format.start_with("samcef")) results_ext = "u18";
  else                                 results_ext ="ut";

  hhmin = hmin;
  // VC: if not templated allow Gradius to be lower than min_size
  if(only_templated) {
    if(hhmin<=0.0) hhmin = min_size;
  }

  if(if_Dwpe) {
    hhmin=2.*hmin;
    //write_Dwpe(cracked_name+"_SIF",cracked_name,hmin,hhmin);
    write_Dwpe(cracked_name+"_SIF",cracked_name,gth_radius,rmax);
    STD_RM(cracked_name+"_SIF_PP.inp");
    cmd="ln -s "+cracked_name+"_SIF_PPD.inp "+cracked_name+"_SIF_PP.inp";
    system(cmd);
    cmd="Zrun -m "+cracked_name+"_SIF_PPD.inp";
    system(cmd);
  } else {
    inp.open(cracked_name+"_SIF_PP.inp",ios::out);
    inp.setf(ios::scientific);

    inp<<"%-----------------------------------------------------------  "<<endl;
    inp<<"% Calcul - SIF post-processing                             |  "<<endl;
    inp<<"%-----------------------------------------------------------  "<<endl;
    inp<<endl;
    inp<<"****post_processing"<<endl;

  if(nb_dd<=1) {
    if((results_ext == "rst")*(!mat_file)) {
       gpp <<" ***global_parameter " << endl;
       gpp <<"  RST.MatFile " << mat_file << endl;
    }
    inp<<" ***data_source ";
    if(results_ext=="ut") inp << "Z7"<<endl;
    else                  inp <<results_ext<<endl;
    
    if(format.start_with("aster")) {
        inp<<"  **open "<<cracked_name<<"_GPP_aster";
    }
    else inp<<"  **open "<<cracked_name<<"_SIF";
    if(format.start_with("samcef")) inp<<"_me";
    inp<<"."<<results_ext<<endl;
    inp <<"  **write_geo"<<endl;
    if(results_ext!="ut") {
       inp <<"  **retrieve_rst_sets"<<endl;
       inp <<"   *z7_mesh "<<cracked_name<<".geo"<<endl;
    }
    if(format.start_with("samcef") * (!thermal_field + if_transfert) ) {
        inp <<" ***local_post_processing"<<endl;
        for(i=0;i<!material_elsets;i++) {
           inp <<"  **elset "<<material_elsets[i]<<endl;
           inp <<"  **file integ"<<endl;
           if(i>0) inp <<"  **duplicate_no"<<endl;
           inp <<"  **process recover_elastic_strain"<<endl;
           inp <<"   *stress sig"<<endl;
           inp <<"   *elasticity "<<material_files[i]<<endl;
        }
    }
  }
    inp<<" ***global_post_processing"<<endl;
    if((!temperature_name)&&(!(temperature_name.start_with("GP_")))) {
       inp <<"  **file node"<<endl;
       inp <<"  **nset ALL_NODE"<<endl;
       inp <<"  **process node_interpolation"<<endl;
       inp <<"   *list_var "<<temperature_name<<endl;
       if(results_ext=="ut") {
         inp <<" ***shell ln -s "<<cracked_name<<"_GPP.utp "<<cracked_name<<"_SIF.utp"<<endl;
         inp <<" ***shell ln -s "<<cracked_name<<"_GPP.integp "<<cracked_name<<"_SIF.integp"<<endl;
         inp <<" ***global_post_processing"<<endl;
       }
    }
    inp<<"  **deformed"<<endl;
    if(results_ext=="rst") {
/*     Not needed anymore ... interpolation done in ANSYS_RST
       inp <<"  **file ctele"<<endl;
       inp <<"  **elset ALL_ELEMENT"<<endl;
       inp <<"  **process node_interpolation"<<endl;
       inp <<"   *list_var sig11 sig22 sig33 sig12 sig23 sig31"<<endl;
       inp <<"             eel11 eel22 eel33 eel12 eel23 eel31"<<endl;
*/
       if(!thermal_field + if_transfert) {
         inp <<"  **file node"<<endl;
         inp <<"  **nset ALL_NODE"<<endl;
         if(finite_strain){
            inp <<"  **process strain_measure"<<endl;
            inp <<"   *strain_prefix eto"<<endl;
            inp <<"   *rotate"<<endl;
            inp <<"   *measure log"<<endl;
         }
         else inp <<"  **process symmetric_gradient"<<endl;
       }
    }
    else if(results_ext=="u18") {
       inp <<"  **file node"<<endl;
       inp <<"  **nset ALL_NODE"<<endl;
       inp <<"  **process strain_measure"<<endl;
       inp <<"   *strain_prefix eto"<<endl;
       if(finite_strain){
         inp <<"   *rotate"<<endl;
         inp <<"   *measure log"<<endl;
       } else{
         inp <<"   *measure sd"<<endl;
       }
    }
    inp<<"  **file integ"<<endl;
    inp<<"  **elset ALL_ELEMENT"<<endl;

    inp<<"  **process gtheta"<<endl;
    inp<<"   *crack_front FRONT"<<endl;
    if(gth_radius>0.) { 
      inp <<"   *ra "<<gth_radius<<endl;
      if(rmax>0.) {
        if(rmax<gth_radius) inp <<"   *rb "<<rmax<<endl;
        else inp <<"   *rmax "<<rmax<<endl;
      }
    } else {
      inp <<"   *elem_radius "<<nb_velem<<endl;
      if(rmax>0.) inp <<"   *rmax "<<rmax<<endl;
    }
    inp<<"   *nbnodes "<<nb_fnodes<<endl;
    inp<<"   *lip_name SIDE0"<<endl;
    inp<<"   *error"<<endl;
    //inp<<"   *hmin "<<hhmin<<endl;
    if(rmax<0.) inp<<"   *hmin "<<(-1.*rmax)<<endl;
    if(if_esh) inp<<"   *esh esh"<<endl;
    else {
      if(if_K)    inp<<"   *compute_K"<<endl;
      if(if_Ki)   inp<<"   *Ki"<<endl;
      if(if_mpa_m)   inp<<"   *mpa_m"<<endl;
      if(results_ext=="rst") {
         inp <<"   *sig sig"<<endl;
         if(!thermal_field + if_transfert) {
           inp <<"   *eto eto"<<endl;
           inp <<"   *eel eel"<<endl;
         }
         else {
           inp <<"   *eto eel"<<endl;
           inp <<"   *eel_stored_as GAMMA"<<endl;
         }
         inp <<"   *stored_as GAMMA"<<endl;
      }
      else if(results_ext=="odb") {
         inp <<"   *sig sig"<<endl;
         /* name conversion in Zodb
         if(finite_strain)  inp <<"   *eto LE"<<endl;
         else               inp <<"   *eto eto"<<endl;
         */
         inp <<"   *eto eto"<<endl;
         if(!thermal_field + if_transfert + is_plastic) {
            if(!mat_file) { // Zmat file
               inp <<"   *eel eel"<<endl;
            }
            else {
               inp <<"   *eel EE"<<endl;
               inp <<"   *eel_stored_as GAMMA"<<endl;
            }
         }
         inp <<"   *stored_as GAMMA"<<endl;
      }
      else {
         inp <<"   *sig sig"<<endl;
         inp <<"   *eto ";
         if(finite_strain*(format == "zebulon_templated")) inp <<"ETO"<<endl;
         else                                              inp <<"eto"<<endl;
         if((format == "zebulon_templated") + !thermal_field + if_transfert) {
           inp <<"   *eel eel"<<endl;
         }
      }
    }
    if(if_Gmax) inp<<"   *compute_angle"<<endl;
    if(if_ebe)      inp <<"   *excludeBE"<<endl;
    if(!temperature_name) {
      tempn=temperature_name;
      if(tempn.start_with("GP_")) tempn=tempn.locate_and_cut_before("GP_");
      else tempn="gp"+tempn;
      inp<<"   *temperature "<<tempn<<endl;
    }
    if(sigy>0.) inp <<"   *sigy "<<sigy<<endl;

    if((constant_density>0.)&&format.start_with("abaqus")) {
      inp <<"   *density "<<constant_density<<endl;
      inp <<"   *eigen_abaqus "<<cracked_name<<"_SIF"<<endl;
      inp <<"   *eto EE"<<endl;
    }

    if(if_contact*if_contact_correction){ 
      inp<<"   *surface CRACK_LIPS"<<endl;
      if(finite_strain*(!format.start_with("zebulon"))) inp<<"   *finite_strain"<<endl;
    }
    if(max_kink_angle!=90.) inp << "   *max_angle "<<max_kink_angle<<endl;
    if(remove_ext_hexa>0)   inp << "   *remove_ext_hexa "<<remove_ext_hexa<<endl;

    if(nb_dd>1) inp <<"   *fronts_mesh FRONTS_MESH.geo"<<endl;

    inp<<"****return"<<endl;
    inp.close();
  }
 
  if(results_ext=="odb") {
     cmd = "Zodb ";
     if(!mat_file) cmd = cmd + "-s ODB.AutoConvert 1 ";
  }
  else cmd = ZRUN_CMD;
  if(nb_dd>1) {
    // Regenerate cracked_SIF and add GPP a the end
    STD_CP(cracked_name+"_SIF.inp",cracked_name+"_SIF_saved.inp");
    cmd = "cat "+cracked_name+"_SIF_PP.inp >> "+cracked_name+"_SIF.inp";
    ret=system(cmd);
    cmd = ZRUN_CMD+" -mpimpi "+itoa(nb_dd)+" ";
    if(smp>1) cmd = cmd + " -smp "+itoa(2*smp);
    cmd=cmd+" -pp "+cracked_name+"_SIF.inp";
  } else {
    if(smp>1) {
      cmd = cmd + " -smp "+itoa(smp);
    }
    cmd=cmd+" -pp "+cracked_name+"_SIF_PP.inp";
  }
  if(if_esh) cmd+=" -Ni"<<endl;
  ret = system(cmd);
  if(nb_dd>1) {
   STD_CP(cracked_name+"_SIF_saved.inp",cracked_name+"_SIF.inp");
  }

}

VECTOR set_vector3(double &a,double &b,double &c)
{
  VECTOR tmp;
  tmp.resize(3);
  tmp[0]=a;
  tmp[1]=b;
  tmp[2]=c;
  return tmp;
}

// Save current values (ie for gtheta information agregation)
void save_fronts(ARRAY<VECTOR> &fronts, MATRIX &Gvalues) {

  int h,k;
  saved_Gvalues.resize(Gvalues.n,Gvalues.m); 
  saved_fronts.resize(fronts.size());
  for(h=0;h<fronts.size();h++) {
    saved_fronts[h].resize(fronts[h].size());
    //saved_fronts[h]=fronts[h];
    for(k=0;k<fronts[h].size();k++) saved_fronts[h][k]=fronts[h][k];
  }
  saved_Gvalues=Gvalues;
/*  
  for(h=0;h<Gvalues.n;h++) {
    for(k=0;k<Gvalues.m;k++) {
      saved_Gvalues(h,k)=Gvalues(h,k);
    }
  }
*/
  saved_extrafield=extrafield; 
}

// Restore current values (ie for gtheta information agregation)
void restore_fronts(ARRAY<VECTOR> &fronts, MATRIX &Gvalues) {

  int h,k;
  Gvalues.resize(saved_Gvalues.n,saved_Gvalues.m); 
  fronts.resize(saved_fronts.size());
  for(h=0;h<fronts.size();h++) {
    fronts[h].resize(saved_fronts[h].size());
    //saved_fronts[h]=fronts[h];
    for(k=0;k<fronts[h].size();k++) fronts[h][k]=saved_fronts[h][k];
  }
  Gvalues=saved_Gvalues;
/*
  for(h=0;h<Gvalues.n;h++) {
    for(k=0;k<Gvalues.m;k++) {
      Gvalues(h,k)=saved_Gvalues(h,k);
    }
  }
*/
  extrafield=saved_extrafield; 
}


// Add current values to saved one using closed front node information
// mode=0 means just add value at the end
// mode=1 place at the end and compute derivative using front position
// mode=-1 place at the end and compute -derivative using front position
// mode>2 place at the end and compute derivative using front position mean front value window for linear filtering
// mode<2 place at the end and compute -derivative using front position mean front value
bool add_fronts_to_saved(ARRAY<VECTOR> &fronts, MATRIX &Gvalues,int mode,double DN)
{
  MATRIX nGvalues;
  int ifront,jfront,ipt,jpt,jmin,jfrontmin,i,j,k,h,n,n0,m,psz,pszmin,nblinemin,nbpt,nbpt0,ndx; // n is number of lines
  VECTOR pos0,pos1,fdata;
  double dst,dmin,x;

  cout<<"Mix fronts values... "; cflush();
  if(extrafield!=saved_extrafield) { cout<< "Uncoherent extrafield for multiple gtheta values"<<endl; return(1); }
  
  pos0.resize(3); pos1.resize(3);
  ndx=9;

  n0=saved_Gvalues.n;
  nGvalues.resize(saved_Gvalues.n,saved_Gvalues.m); 
  nGvalues=saved_Gvalues;

  // Resize to store convinent data
  n=n0+Gvalues.n;
  saved_Gvalues.resize(n,saved_Gvalues.m);
  // Put back initial data
  for(i=0;i<n0;i++) {
    for(j=0;j<saved_Gvalues.m;j++) saved_Gvalues(i,j)=nGvalues(i,j);
  }

  m=0;
  // Init nGvalues header
  for(h=n0;h<n;h++) {
    saved_Gvalues(h,0)=-Gvalues(h-n0,0); // Set as negative to specify previous values
    saved_Gvalues(h,1)=saved_Gvalues(0,1); // Always keep initial font nb
  }
  nbline=2;

  // Fill data looking for closest node
  for(ifront=0;ifront<saved_fronts.size();ifront++) {
    nbpt=saved_fronts[ifront][1];
    // Now do the work
    // Rewrite frontid and number of nodes
    for(h=n0;h<n;h++) {
      saved_Gvalues(h,nbline)=saved_Gvalues(0,nbline); 
      saved_Gvalues(h,nbline+1)=saved_Gvalues(0,nbline+1);
    }
    for(ipt=0;ipt<nbpt;ipt++) {
      // Loop on saved node ifront points
      for(k=0;k<3;k++) pos1[k]=saved_fronts[ifront][2+ndx*ipt+k];
      // Find corresponding front node
      dmin=1.e50;
      jfront_min=0;
      jmin=0;
      psz=0;
      pszmin=0;
      for(jfront=0;jfront<saved_fronts.size();jfront++) {
        nbpt0=fronts[jfront][1];
        for(jpt=0;jpt<nbpt0;jpt++) {
          for(k=0;k<3;k++) pos0[k]=fronts[jfront][2+ndx*jpt+k];
          dst=pos1.distance2(pos1,pos0);
          // cout << "dst: "<< dst << endl; cflush();
          if(dst<dmin) { dmin=dst; jfrontmin=jfront; jmin=jpt; pszmin=psz; }
        }
        psz=psz+nbpt0;
      }
      //cout << "fnd: "<< dmin << " " <<jfrontmin << " " << jmin << " " << pszmin <<endl; cflush();
      dmin=sqrt(dmin);
      if(dmin<(.1*min_size)) dmin=0.;
      else dmin=1./dmin;
      nbpt0=fronts[jfrontmin][1];
      // Point found -> Fill saved_Gvalues
      for(h=n0;h<n;h++) {
        for(k=0;k<4+extrafield;k++) {
          val=Gvalues(h-n0,4+(pszmin+jmin)*(4+extrafield)+jfrontmin*2+k);
          if(mode>=1) {
            // Compute derivative (delta_val)/distance
            val=DN*dmin*(saved_Gvalues(h-n0,nbline+2+ipt*(4+extrafield)+k)-val);
          } else if(mode<=-1) {
            // Compute derivative (delta_val)/distance
            val=DN*dmin*(val-saved_Gvalues(h-n0,nbline+2+ipt*(4+extrafield)+k));
          }
          saved_Gvalues(h,nbline+2+ipt*(4+extrafield)+k)=val;
        }
      }
    }
    // Increment index
    nbline=nbline+2+(4+extrafield)*nbpt;
  }
  cout<<(n-n0)<< " line(s) added."<<endl; cflush();

  if(mode<0) mode=-mode;
  if(mode>=2) {
    cout<<"Smoothing derivatives ("<<mode<< " nodes window)... "; cflush();
    nbline=2;
    for(ifront=0;ifront<saved_fronts.size();ifront++) {
      nbpt=saved_fronts[ifront][1];
      fdata.resize(nbpt);
      // Now do the work
      for(h=n0;h<n;h++) {
        for(k=0;k<4+extrafield;k++) {
          fdata=0.;
          for(ipt=0;ipt<nbpt;ipt++) {
            jpt=ipt-mode; 
            if(jpt<0) jpt=0;
            m=jpt+mode; 
            if(m>nbpt) m=nbpt;
            x=m-jpt;
            for(j=jpt;j<m;j++) {
              fdata[ipt]+=saved_Gvalues(h,nbline+2+j*(4+extrafield)+k);
            }
            fdata[ipt]=fdata[ipt]/x;
          }
          for(ipt=0;ipt<nbpt;ipt++) {
            saved_Gvalues(h,nbline+2+ipt*(4+extrafield)+k)=fdata[ipt];
          }
        }
      }
      // Increment index
      nbline=nbline+2+(4+extrafield)*nbpt;
    }
    cout<<" Done."<<endl; cflush();
  }

  return(0);
}


// Smooth fronts
int smooth_fronts(ARRAY<VECTOR> &fronts, MATRIX &Gvalues, int gsz,int if_eBE)
{
  int h,k,ifront,ipt,jpt,kpt,n,m,ret,nbpt,nnbpt,nbline,sz;
  VECTOR Gtime,Sfront,Cfront;
  MATRIX G,GII,ALPHA,TEMP;
  double ratio,x,y;
  ARRAY<int> nSZ;
  ARRAY<VECTOR> nfronts;
  MATRIX nGvalues;
 
  // Save current values (ie for zck output)
  oGvalues.resize(Gvalues.n,Gvalues.m); 
  ofronts.resize(fronts.size());
  for(h=0;h<fronts.size();h++) {
    ofronts[h].resize(fronts[h].size());
    for(k=0;k<fronts[h].size();k++) ofronts[h][k]=fronts[h][k];
  }
  for(h=0;h<Gvalues.n;h++) {
    for(k=0;k<Gvalues.m;k++) {
      oGvalues(h,k)=Gvalues(h,k);
    }
  }
 
  ret=0;
  sz=gsz; //(gsz+1)/4;
  // Noting to do is window size is lower than 2
  if(sz<=1) return(ret);

  // Sufficiently large nGvalues matrix;
  nGvalues.resize(Gvalues.n,Gvalues.m); 
  nfronts.resize(fronts.size());

  n=Gvalues.n;
  m=0;
  // Init nGvalues header
  for(h=0;h<n;h++) {
    nGvalues(h,0)=Gvalues(h,0);
    nGvalues(h,1)=Gvalues(h,1);
  }
  nbline=2;

  // Loop on front and get values that must be kept
  for(ifront=0;ifront<fronts.size();ifront++) {
    nbpt=fronts[ifront][1];
    if(get_front_info(fronts,Gvalues,ifront,Gtime,G,GII,ALPHA,TEMP,Sfront,Cfront)) return(-1);
    // Now do the work
    // Compute new size
    x=nbpt-1;
    y=sz;
    ratio=x/y;
    nnbpt=ratio;
    y=nnbpt;
    ratio=x/y;
    nnbpt=nnbpt+1; 
    if(nnbpt<3) { nnbpt=2; y=nnbpt; ratio=x/y; }
    interp_coef=1./ratio;
    // Resize nfronts and fill headers
    nfronts[ifront].resize(1+2+3*3*nnbpt);
    nfronts[ifront][0]=fronts[ifront][0];
    nfronts[ifront][1]=nnbpt;
    nfronts[ifront][2]=nbline;
    // Gvalues header
    for(h=0;h<n;h++) {
      nGvalues(h,nbline)=ifront;
      nGvalues(h,nbline+1)=nnbpt;
    } 
    for(ipt=0;ipt<nnbpt;ipt++) {
      x=ipt;
      y=x*ratio;
      if(ipt==0) { jpt=0; x=0.; }
      else if(ipt==(nnbpt-1)) { jpt=nbpt-2; x=1.; }
      else {
        // Linear interpolation
        jpt=y;
        if(jpt>nbpt-2) { jpt=nbpt-2; }
        x=jpt;
        x=y-x;
      }
      y=1.-x;
      // Fill nfront
      for(k=0;k<9;k++) nfronts[ifront][3+9*ipt+k]=y*fronts[ifront][3+9*jpt+k]+x*fronts[ifront][3+9*(jpt+1)+k];
      // Fill nGvalues
      for(h=0;h<n;h++) {
        nGvalues(h,nbline+2+ipt*(4+extrafield))=y*G(h,jpt)+x*G(h,jpt+1);
        nGvalues(h,nbline+2+ipt*(4+extrafield)+1)=y*GII(h,jpt)+x*GII(h,jpt+1);
        nGvalues(h,nbline+2+ipt*(4+extrafield)+2)=y*ALPHA(h,jpt)+x*ALPHA(h,jpt+1);
        nGvalues(h,nbline+2+ipt*(4+extrafield)+3)=y*TEMP(h,jpt)+x*TEMP(h,jpt+1);
        for(k=0;k<extrafield;k++) nGvalues(h,nbline+2+ipt*(4+extrafield)+4+k)=y*extraGvalues(h,jpt*extrafield+k)+x*extraGvalues(h,(jpt+1)*extrafield+k);
      }
    }
    if(if_eBE) {
      // Fill nGvalues
      ipt=0; jpt=1;
      for(h=0;h<n;h++) {
        for(k=0;k<4+extrafield;k++)
          nGvalues(h,nbline+2+ipt*(4+extrafield)+k)=nGvalues(h,nbline+2+jpt*(4+extrafield)+k);
      }
      ipt=nnbpt-1; jpt=nnbpt-2;
      for(h=0;h<n;h++) {
        for(k=0;k<4+extrafield;k++)
          nGvalues(h,nbline+2+ipt*(4+extrafield)+k)=nGvalues(h,nbline+2+jpt*(4+extrafield)+k);
      }
    }
    
    // Increment index
    nbline=nbline+2+(4+extrafield)*nnbpt;
  }
  m=nbline; 

  // Now fill data
  fronts.resize(nfronts.size());
  Gvalues.resize(n,m);
  for(ifront=0;ifront<nfronts.size();ifront++) {
    fronts[ifront].resize(nfronts[ifront].size());
    for(h=0;h<nfronts[ifront].size();h++) {
      fronts[ifront][h]=nfronts[ifront][h];  
    }
  }
  for(h=0;h<Gvalues.n;h++) {
    for(k=0;k<Gvalues.m;k++) {
      Gvalues(h,k)=nGvalues(h,k);
    }
  }

  return(ret); 
}

// Read a post g-theta post file
int read_zcpost(STRING &file_name,ARRAY<VECTOR> &fronts, MATRIX &Gvalues)
{
  ASCII_FILE inp;
  int i,j,nfront,frontid,nbpt,nbline, pos, n, mi,nbfield;
  STRING line, str;

  cout << endl<<" ** Reading: "<<file_name<<endl<<flush;
  nfront=0;
  inp.open(file_name);
  inp.add_comment_char("#");
  nfront = inp.getint();
  zcpost_nfronts=nfront;
  cout << endl<<" ** ZCPOST number of fronts: "<<nfront<<endl<<flush;
  if(!inp.ok + nfront<=0) return(1);

  // 1st stage front info
  nbline=2;
  fronts.resize(nfront);
  zcpost_ids.reset();
  for(i=0;i<nfront;i++) {
    frontid=inp.getint();
    zcpost_ids.add(frontid);
    if(!inp.ok) return(2);  
    nbpt=inp.getint();
    if(!inp.ok) return(3);  
    fronts[i].resize(1+2+3*3*nbpt);
    fronts[i][0]=frontid;
    fronts[i][1]=nbpt;
    fronts[i][2]=nbline;
    nbline=nbline+2+4*nbpt;
    for(j=3;j<fronts[i].size();j++) {
      fronts[i][j]=inp.getdouble();
      if(!inp.ok) return(4);  
    }
  }

  // Read zcpost_fields
  for(i=0;i>=0;i++) {
    line=inp.getfullline();
    if(!inp.ok) return(5);
    if(line.start_with("# Time")) {
       cout << endl<<" ** Reading ZCPOST fields: [ "<<flush;
       zcpost_fields.reset();
       line.locate_and_cut_after("#");
       for(j=0;!line;j++) {
         str=line.getSTRING();
         if(str.end_with("0")) {
           if(str.end_with("_0")) {
             str.locate_and_cut_before("_0");
           } else str="void";
           zcpost_fields.add(str);
           cout<<str<<" "<<flush;
         }
         if(str.end_with("_1")) break;
       }
       cout <<"]"<<endl<<flush;
       break;
    }
  }

  // Check extrafields
  extrafield=zcpost_fields.size()-4;
  if(extrafield<0) return(1); // Error in given fields

  for(i=0;i>=0;i++) {
    line = inp.getline();
    if(!inp.ok) return(5);
    if(!line>1) break;
  }
  inp.back();
  // save position of SIF for 1st increment
  pos = inp.get_position();

  // count m values stored for each increment
  n = 0; m = 0;
  for(i=0;i>=0;i++) {
     str = line.getSTRING();
     if(!str==0) break;
     m = m + 1; 
  } 
  // count n increments stored
  for(i=0;i>=0;i++) {
     line = inp.getline();
     if(!inp.ok) break;
     if(!line<=1) continue;
     n = n + 1;
  }
  
  zcpost_times.reset();
  Gvalues.resize(n,m);
  inp.goto_position(pos);
  cout << endl<<" ** Reading ZCPOST Times: [ "<<flush;
  for(i=0;i<n;i++) {
     for(j=0;j<m;j++) { 
       Gvalues(i,j) = inp.getnumeral(); 
       if(j==0) {
         zcpost_times.add(Gvalues(i,j));
         cout<<dtoa(Gvalues(i,j))<<" ";
       }
     }
  }
  cout << " ]"<<endl<<endl<<flush;
 
  nbfield=zcpost_fields.size();
  if(nbfield>4) {
    extrafield=nbfield-4;
    cout << "***WARNING: ZCPOST contains "<<extrafield<<" supplementary field(s)!"<<endl<<flush;
    // Change starting index
    nbline=2;
    for(i=0;i<nfront;i++) {
      nbpt=fronts[i][1];
      fronts[i][2]=nbline;
      nbline=nbline+2+nbfield*nbpt;
    }
  } else extrafield=0;

  return(0);
}

STRING zcfile_to_index(STRING &zcfile_input,int &i0,int &is, int &i1) {
  LIST<int> index;
  STRING zcfile,fname,s1,s2;
  int i;

  // Default step
  is=1;

  zcfile=zcfile_input;
  if(zcfile.locate("[")) {
    s1=zcfile_input;
    s1.locate_and_cut_before("[");
    s2=zcfile_input;
    s2.locate_and_cut_after("]");
    zcfile=s1+"@INT"+s2;
    s1=zcfile_input;
    s1.locate_and_cut_after("[");
    s1.locate_and_cut_before("]");
    s1.replace(":"," ");
    for(i=0;i<3;i++) {
      s2=s1.getSTRING();
cout << s1 << " " <<s2 <<" " << zcfile <<endl;
      if(s2.is_int()) {
        index.add(s2.to_int());
      } else break;
    }
    if(index.size()>=2) {
      i0=index[0];
      if(index.size()==2) {
        i1=index[1];
      } else {
        is=index[1];
        i1=index[2];
      }
    } else ERROR("Wrong zcfile format: "+zcfile_input);

    cout<<i0<<":"<<is<<":"<<i1<<endl;
    zcfile_input=zcfile;
    zcfile.replace("@INT",itoa(i0));
    cout<<zcfile<<" "<<zcfile_input<<endl<<flush;
  } else { i0=-1; }

  return(zcfile);

}

// zcpost data extractions
bool extrafields_to_gnuplot(STRING &zcfile_input) {
  int inter_pt,i,j,k,kk,ifile,i0,i1,is,icrb,err;
  int sz_data,idx,nbfield,ifront,ifront_inv,ifield,itime,ipos;
  ARRAY<VECTOR> fronts;
  LIST<int> file_index;
  LIST<STRING> zcfile_list;
  MATRIX Gvalues,gp_data;
  VECTOR Gtime,Sfront,Cfront;
  MATRIX CM,G,GII,ALPHA,TEMP;
  STRING cmd,gplt,fname,ff,ffs,zcfile;
  Zfstream datf,datt;
  double x,sx;

  if(select_fronts.size()==0) return(1);
  if(select_times.size()==0) return(1);
  if(select_fields.size()==0) return(1);

  // Compute interpol mat
  cat_mat(CM,tau);
  // interpolation points
  inter_pt=256;

  fname="zcpost_gp_FRONT";

  // Decompose file name
  zcfile=zcfile_input;
  zcfile_to_index(zcfile,i0,is,i1);

  if(i0>=0) {
    for(i=i0;i<=i1;i=i+is){
      fname=zcfile;
      fname.replace("@INT",itoa(i));
      zcfile_list.add(fname);
      file_index.add(i);
    }
  } else zcfile_list.add(zcfile);

  // Start gnuplot cmd
  zcfile=zcfile_input;
  zcfile.replace("_","-"); 
  if((select_fields.size()==1)&&(zcpost_fields.size()>select_fields[0])) 
    zcfile=zcpost_fields[select_fields[0]]+" - "+zcfile; 
  if((select_times.size()==1)&&(zcpost_times.size()>select_times[0])) 
    zcfile=zcfile+" at t="+dtoa(zcpost_times[select_times[0]]); 
  if((select_fronts.size()==1)&&(zcpost_nfronts>select_fronts[0])) 
    zcfile=zcfile+", FRONT"+itoa(zcpost_ids[select_fronts[0]]); 
  gplt="gnuplot -persist -e \"set title '"+zcfile+"' ; set xlabel 'Curvilinear abscissa along front' ;";
  gplt=gplt+" set grid ; set key outside; set key right top ; plot ";
  icrb=1;

  if(zcfile_list.size()>1) {
    // Build propag datafile
    datt.open("PROPAG_DATAFILE.dat",ios::out);
    datt.setf(ios::scientific);
    datt.precision(64);
    datt<<"# Gnuplot Zcracks PROPAG datafile"<<endl;
  }

  for(ifile=0;ifile<zcfile_list.size();ifile++) {

    // Set zcfile
    zcfile=zcfile_list[ifile];
    // read zcpost
    err=read_zcpost(zcfile,fronts,Gvalues);
    if(err) {
      cout<<endl<<"Invalid GPP results file: "<<zcfile<<" ... end"<<endl<<endl<<flush;
      break; 
    }

    nbfield=zcpost_fields.size();

    // data to be plotted: 
    // select_fields x select_times for select_fronts;
    zcfile.replace("_","-");
   
    // Loop on selected fronts
    for(ifront=0;ifront<select_fronts.size();ifront++) {
      ifront_inv=select_fronts[ifront];
      ifront=-ifront_inv-1; // to get correct Sfront
      get_front_info(fronts,Gvalues,ifront,Gtime,G,GII,ALPHA,TEMP,Sfront,Cfront);
      npt=Sfront.size(); //pb number
      // Build gp data
      gp_data.resize(npt+2,1+select_fields.size()*select_times.size());
      ff=fname+itoa(ifront)+"_"+itoa(ifile)+".dat";
      ffs=fname+itoa(ifront)+"_"+itoa(ifile)+"_rs.dat";
      // Get curvilinear length
      for(k=0;k<npt;k++) gp_data(k+1,0)=Sfront[k];
      gp_data(0,0)=gp_data(1,0);
      gp_data(k+1,0)=gp_data(k,0);
      ipos=1;
      for(i=0;i<select_times.size();i++) {
        itime=select_times[i];
        for(j=0;j<select_fields.size();j++) {
          ifield=select_fields[j];
          if(ifield>=zcpost_fields.size()) {
            // special case curvature
            for(k=0;k<npt;k++) gp_data(k+1,ipos)=Cfront[k];
            str="Curve";
          } else {
            idx=fronts[ifront][2]+2+ifield;
            for(k=0;k<npt;k++) {
              gp_data(k+1,ipos)=Gvalues(itime,idx);
              idx=idx+nbfield;
            }
            str="";
            if(select_fields.size()>1) str=zcpost_fields[ifield]; 
            if(select_times.size()>1) str=str+" t="+dtoa(zcpost_times[itime]);
          }
          if(select_fronts.size()>1) str=str+" FRONT"+itoa(ifront);
          if(zcfile_list.size()>1) str=str+" cyc="+itoa(file_index[ifile]);
          gp_data(0,ipos)=gp_data(1,ipos);
          gp_data(k+1,ipos)=gp_data(k,ipos);
          gplt=gplt+" '"+ffs+"' u 1:"+itoa(ipos+1)+" lt "+itoa(icrb)+" w l t '"+str+"' , ";
          gplt=gplt+" '"+ff+"' u 1:"+itoa(ipos+1)+" lt "+itoa(icrb)+" pt 7 w p t '' , ";
          ipos++;
          icrb++;
        }
      }
      // Write file
      datf.open(ff,ios::out);
      datf.setf(ios::scientific);
      datf.precision(64);
      datf<<"# Gnuplot Zcracks datafile"<<endl;
      datf<<"# Data along front"<<endl;
      if(zcfile_list.size()>1) datf<<"# cyc="<<itoa(file_index[ifile])<<endl;
      datf<<"# ";
      for(i=0;i<select_times.size();i++) {
        itime=select_times[i];
        for(j=0;j<select_fields.size();j++) { 
          ifield=select_fields[j];
          if(ifield>=zcpost_fields.size()) datf<<"Curve";
          else datf<<zcpost_fields[ifield];
          if(select_times.size()>1) datf<<"@t="<<dtoa(zcpost_times[itime]);
          datf<<" ";
        }
      }
      datf<<endl;
      for(k=0;k<npt;k++) {
        for(ipos=0;ipos<gp_data.m;ipos++) datf <<gp_data(k+1,ipos)<<" ";
        datf<<endl;
      }
      datf.close();

      // Reshaped
      sx=npt-1;
      x=inter_pt-1;
      sx=sx/x;
      x=0.;
      datf.open(ffs,ios::out);
      datf.setf(ios::scientific);
      datf.precision(64);
      datf<<"# Gnuplot Zcracks datafile"<<endl;
      datf<<"# Data along front"<<endl;
      if(zcfile_list.size()>1) datf<<"# cyc="<<itoa(file_index[ifile])<<endl;
      datf<<"# ";
      for(i=0;i<select_times.size();i++) {
        itime=select_times[i];
        for(j=0;j<select_fields.size();j++) { 
          ifield=select_fields[j];
          if(ifield>=zcpost_fields.size()) datf<<"Curve";
          else datf<<zcpost_fields[ifield];
          if(select_times.size()>1) datf<<"@t="<<dtoa(zcpost_times[itime]);
          datf<<" ";
        }
      }
      datf<<endl;
      for(i=0;i<inter_pt;i++) {
        catmullV(x,gp_data,CM,G);
        for(ipos=0;ipos<G.m;ipos++) datf <<G(0,ipos)<<" ";
        datf<<endl;
        x=x+sx;
      }
      datf.close();

      // Data file along propag
      if(zcfile_list.size()>1) {
        if((ifile==0)&&(ifront==0)) {
          datt<<"# Data along propag for 3 nodes loop on fronts "<<endl;
          datt<<"# ";
          // Point i coord are accessible in fronts[ifront][idx0+i_point*ndx+j_dim]
          datt<<" 1:cyc ";
          k=2;
          for(kk=0;kk<3;kk++) {
            datt<<k<<":X ";
            k++;
            datt<<k<<":Y ";
            k++;
            datt<<k<<":Z ";
            k++;
            datt<<k<<":s ";
            k++;
            for(i=0;i<select_times.size();i++) {
              itime=select_times[i];
              for(j=0;j<select_fields.size();j++) { 
                ifield=select_fields[j];
                if(ifield>=zcpost_fields.size()) datt<<k<<":Curve";
                else datt<<k<<":"<<zcpost_fields[ifield];
                if(select_times.size()>1) datt<<"@t="<<dtoa(zcpost_times[itime]);
                datt<<" ";
                k=k+1;
              }
            }
          }
          datt<<endl;
        }
        // Usual case
        if(ifront==0) datt<<itoa(file_index[ifile])<<" ";
        for(kk=0;kk<3;kk++) {
          if(kk==0) k=0;
          else if(kk==1) k=npt/2;
          else k=npt-1;
          for(j=0;j<3;j++) datt<<fronts[ifront][3+k*9+j]<<" ";
          for(ipos=0;ipos<gp_data.m;ipos++) datt <<gp_data(k+1,ipos)<<" ";
        }
      }
    }
    if(zcfile_list.size()>1) datt<<endl;
  }
  datt.close();
  
  gplt=gplt+" ; pause mouse close\" &";
  cout << "Gnuplot cmd = " << endl << gplt <<endl;
  i = system(gplt);
  return(i);
}

// zcpost data extractions for propag law
void extrafields_to_propag_law(int pos,int sz) {
  int i,k,j;
  STRING str;
  k=0;
  for(i=4;i<zcpost_fields.size();i++) { // add offset
    str=zcpost_fields[i];
    if(str=="G") {
      propag_law.info.G.resize(sz);
      for(j=0;j<sz;j++) propag_law.info.G[j] = extraGvalues(j,pos*extrafield+k);
    } else if(str=="K1") {
      propag_law.info.KI.resize(sz);
      for(j=0;j<sz;j++) propag_law.info.KI[j] = extraGvalues(j,pos*extrafield+k);
    } else if(str=="K2") {
      propag_law.info.KII.resize(sz);
      for(j=0;j<sz;j++) propag_law.info.KII[j] = extraGvalues(j,pos*extrafield+k);
    } else if(str=="K3") {
      propag_law.info.KIII.resize(sz);
      for(j=0;j<sz;j++) propag_law.info.KIII[j] = extraGvalues(j,pos*extrafield+k);
    } else if(str=="Tstress") {
      propag_law.info.TS.resize(sz);
      for(j=0;j<sz;j++) propag_law.info.TS[j] = extraGvalues(j,pos*extrafield+k);
    } else if(str=="G2") {
      propag_law.info.G2.resize(sz);
      for(j=0;j<sz;j++) propag_law.info.G2[j] = extraGvalues(j,pos*extrafield+k);
    } else if(str=="G3") {
      propag_law.info.G3.resize(sz);
      for(j=0;j<sz;j++) propag_law.info.G3[j] = extraGvalues(j,pos*extrafield+k);
    } else if(str=="T") {
      propag_law.info.TP.resize(sz);
      for(j=0;j<sz;j++) propag_law.info.TP[j] = extraGvalues(j,pos*extrafield+k);
    } else if(str=="Kerr") {
      propag_law.info.Kerr.resize(sz);
      for(j=0;j<sz;j++) propag_law.info.Kerr[j] = extraGvalues(j,pos*extrafield+k);
    } else if(str=="Rp") {
      propag_law.info.Rp.resize(sz);
      for(j=0;j<sz;j++) propag_law.info.Rp[j] = extraGvalues(j,pos*extrafield+k);
    } else if(str=="Gpe") {
      propag_law.info.Gpe.resize(sz);
      for(j=0;j<sz;j++) propag_law.info.Gpe[j] = extraGvalues(j,pos*extrafield+k);
    } else if(str=="K1pe") {
      propag_law.info.KIpe.resize(sz);
      for(j=0;j<sz;j++) propag_law.info.KIpe[j] = extraGvalues(j,pos*extrafield+k);
    } else if(str=="K2pe") {
      propag_law.info.KIIpe.resize(sz);
      for(j=0;j<sz;j++) propag_law.info.KIIpe[j] = extraGvalues(j,pos*extrafield+k);
    } else if(str=="K3pe") {
      propag_law.info.KIIIpe.resize(sz);
      for(j=0;j<sz;j++) propag_law.info.KIIIpe[j] = extraGvalues(j,pos*extrafield+k);
    } else if(str=="Gkpe") {
      propag_law.info.Gkpe.resize(sz);
      for(j=0;j<sz;j++) propag_law.info.Gkpe[j] = extraGvalues(j,pos*extrafield+k);
    } else if(str=="TSpe") {
      propag_law.info.TSpe.resize(sz);
      for(j=0;j<sz;j++) propag_law.info.TSpe[j] = extraGvalues(j,pos*extrafield+k);
    }
    k++;
  }
}





// Write_mesher file from a given STRING
int write_mesher(STRING &in_name,STRING &out_name, STRING &mesher, STRING &mesher_name)
{
  Zfstream inp;
  STRING cmd;

  STD_RM(mesher_name);

  inp.open(mesher_name,ios::out);
  inp.setf(ios::scientific);

  inp<<"% Mesher from write_mesh script"<<endl;
  inp<<"****mesher"<<endl;
  if(out_name!="") inp<<" ***mesh "<<out_name<<endl;
  if(in_name!="")  inp<<"  **open "<<in_name<<endl;
  inp<<mesher<<endl;
  inp<<"****return"<<endl;

  inp.close(); 
 
  return(0);
}

// Apply a mesher from a given STRING
int apply_mesher(STRING &in_name,STRING &out_name, STRING &mesher)
{
  return(apply_mesher(in_name,out_name,mesher,0));
}

int apply_mesher(STRING &in_name,STRING &out_name, STRING &mesher, int if_silent)
{
  STRING mesher_name,cmd;
  mesher_name="ZCRACKS_MESHER.inp";
  write_mesher(in_name,out_name,mesher,mesher_name);
  STD_RM("MESHER_REPORT");
  cmd=ZRUN_CMD+" -m "+mesher_name;
  if(if_silent){
    if(os != "win32") cmd=cmd+" > MESHER_REPORT";
    else              cmd=cmd+" >> MESHER_REPORT";
  }
  return(system(cmd));
}

// Apply transformation for easier periodic condition preservations
STRING replace_bset(STRING &kept,STRING &replaced,STRING &transform,double ltol)
{
  STRING mesher;
  mesher="  **remove_set *bsets SURF SURF_EXT *elsets SURF_EXT "+kept+" "+replaced+" *nsets INTERSECTION0 INTERSECTION1\n";
  mesher=mesher+"  **bset SURF *function 1.;\n"; // all surface
  mesher=mesher+"  **join_bsets SURF_EXT *bsets SURF "+kept+" "+replaced+" *remove *remove_duplicates\n"; // external surface
  mesher=mesher+"  **bset_to_elset *bsets "+kept+" "+replaced+" SURF_EXT *elsets "+kept+" "+replaced+" SURF_EXT\n";
  mesher=mesher+"  **nset_intersection *intersection_name INTERSECTION0 *nsets SURF_EXT "+replaced+"\n";
  mesher=mesher+"  **nset_intersection *intersection_name INTERSECTION1 *nsets SURF_EXT "+kept+"\n";
  mesher=mesher+"  **delete_elset "+replaced+"\n";
  mesher=mesher+"  **remove_set *bsets "+replaced+"\n";
  mesher=mesher+"  **save ZCRACKS_TMP.geo\n";
  mesher=mesher+"  **remove_set *bsets "+replaced+" *nsets INTERSECTION0\n";
  mesher=mesher+"  **delete_elset SURF_EXT\n";
  mesher=mesher+"  **rename_set *bsets "+kept+" "+replaced+" *nsets INTERSECTION1 INTERSECTION0\n";
  mesher=mesher+transform+"\n";
  mesher=mesher+"  **union *add ZCRACKS_TMP.geo *tolerance 0.\n";
  mesher=mesher+"  **fuse_nset *skip_reassign_numbers *cleanup_mesh *cleanup_nset INTERSECTION0 *iterate *tolerance "+dtoa(ltol)+"\n";
  mesher=mesher+"  **remove_set *bsets SURF SURF_EXT *elsets SURF_EXT "+kept+" "+replaced+" *nsets INTERSECTION0 INTERSECTION1\n";
  return(mesher);
}

// Extract edges shared by a faset and the "rest" of a surface mesh
STRING extract_inter_bset(STRING &bset_name, STRING &liset_name)
{
  STRING mesher;
  mesher="  **remove_set *bsets SURF_EXT SURF SHARED_EDGES TMP_LISET0 TMP_LISET1 SHARED SHARED_EXT0 SHARED_EXT\n";
  mesher=mesher+"   *nsets INTER_SURF SURF_EXT "+bset_name+" *elsets SHARED SHARED_EXT\n";
  mesher=mesher+"  **bset SURF *function 1.;\n"; // all surface
  mesher=mesher+"  **join_bsets SURF_EXT *bsets SURF "+bset_name+" *remove *remove_duplicates\n"; // external surface
  mesher=mesher+"  **nset_intersection *nsets SURF_EXT "+bset_name+" *intersection_name INTER_SURF\n"; // shared nodes
  mesher=mesher+"  **elset SHARED *attached_to_nset INTER_SURF\n"; // attached elements to intersection
  mesher=mesher+"  **bset SHARED *elset SHARED *function 1.;\n"; // attached elements to intersection
  mesher=mesher+"  **join_bsets SHARED_EXT0 *bsets SURF_EXT SHARED *intersection *remove_duplicates\n"; // attached elements to intersectio
  mesher=mesher+"  **join_bsets SHARED_EXT *bsets SHARED_EXT0 "+bset_name+" *remove *remove_duplicates\n"; // attached elements to intersection
  mesher=mesher+"  **bset_to_elset *bsets SHARED_EXT *elsets SHARED_EXT\n";
  mesher=mesher+"  **bset SHARED_EDGES *elset SHARED_EXT *use_dimension 1 *no_sort *function 1.;\n";
  mesher=mesher+"  **join_bsets TMP_LISET0 *bsets SHARED_EDGES SURF_EXT "+bset_name+" *intersection *remove_duplicates\n";
  mesher=mesher+"  **join_bsets TMP_LISET1 *bsets TMP_LISET0 "+liset_name+" *remove_duplicates\n";
  mesher=mesher+"  **remove_set *bsets SURF_EXT SURF SHARED_EDGES SHARED_EXT0 SHARED_EXT SHARED TMP_LISET0 "+liset_name+"\n";
  mesher=mesher+"   *nsets INTER_SURF SURF_EXT "+bset_name+" *elsets SHARED\n";
  mesher=mesher+"  **rename_set *bsets TMP_LISET1 "+liset_name+"\n";

  return(mesher);
}

// Get all informations related to one front
// Sfront: size=0 if closed front Sfront[inode]=approx distance to closest surface
// Scruve: local front curvature
int get_front_info(ARRAY <VECTOR> &fronts,MATRIX &Gvalues,int ifront,VECTOR &Gtime, MATRIX &G,MATRIX& GII,MATRIX &ALPHA,MATRIX &TEMP,VECTOR &Sfront,VECTOR &Cfront)
{
  int idx,i,j,k,nbpt,nbfield,jfront;
  jfront=ifront;
  if(ifront<0) { ifront=-ifront-1; } // to keep true s values
  if(ifront>=fronts.size()) return(1);
  nbpt=fronts[ifront][1];
  Gtime.resize(Gvalues.n);
  G.resize(Gvalues.n,nbpt);
  GII.resize(Gvalues.n,nbpt);
  ALPHA.resize(Gvalues.n,nbpt);
  TEMP.resize(Gvalues.n,nbpt);
  nbfield=zcpost_fields.size();
  if(nbfield>4) {
    extrafield=(nbfield-4);
    extraGvalues.resize(Gvalues.n,extrafield*nbpt);
    // cout << "***WARNING: ZCPOST contains "<<extrafield<<" supplementary field(s)!"<<endl;
    // ExtraGvalues is addressed by (lineindex,ptindex*extrafied+ifield)
  } else extrafield=0;
  for(i=0;i<Gvalues.n;i++) {
    Gtime[i]=Gvalues(i,0);
    for(j=0;j<nbpt;j++) {
      idx=fronts[ifront][2]+2+nbfield*j;
      G(i,j)=Gvalues(i,idx);
      GII(i,j)=Gvalues(i,idx+1);
      ALPHA(i,j)=Gvalues(i,idx+2);
      TEMP(i,j)=Gvalues(i,idx+3);
      for(k=0;k<extrafield;k++) 
        extraGvalues(i,j*extrafield+k)=Gvalues(i,idx+4+k);
    }
  }
  Sfront.resize(0);
  Cfront.resize(0);
  front_dist_curve(fronts,jfront,Sfront,Cfront);
/*
  cout << "FRONT" << ifront <<endl;
  cout << "Distance from surface: " << Sfront << endl;
  cout << "Local curvature: " << Cfront << endl << flush;
*/
  return(0);
}

void front_dist_curve(ARRAY <VECTOR> &fronts,int ifront,VECTOR &Sfront,VECTOR &Cfront)
{
  int idx0,idx0n,idx0b,ndx,i,j,nbpt,if_abs;
  double ds,dnds;
  VECTOR P0,Pn,Pnm1,Pnp1,P1,Tn,Tnm1,Tnp1,SfrontI,T,N,B,Diff;
  
  if(ifront<0) {
    if_abs=1;
    ifront=-ifront-1; // -1 for first
  } else if_abs=0;

  P0.resize(3);
  Pn.resize(3);
  Pnm1.resize(3);
  Pnp1.resize(3);
  P1.resize(3);
  Tn.resize(3);
  Tnm1.resize(3);
  Tnp1.resize(3);
  T.resize(3);
  N.resize(3);
  B.resize(3);
  Diff.resize(3);

  idx0=3;
  idx0n=6;
  idx0b=9;
  ndx=9;
  // Point i coord are accessible in fronts[ifront][idx0+i_point*ndx+j_dim]
  nbpt=fronts[ifront][1]; 
  Sfront.resize(nbpt);
  SfrontI.resize(nbpt);
  Cfront.resize(nbpt);
  Sfront[0]=0.;
  // Trivial case 2 nodes
  // Get P0 coordinates
  for(j=0;j<3;j++) P0[j]=fronts[ifront][idx0+0*ndx+j];
  if(nbpt==2) {
    Sfront[1]=0.;
    Cfront[0]=0.;
    for(j=0;j<3;j++) P1[j]=fronts[ifront][idx0+1*ndx+j];
    Diff=(P1-P0); 
    Cfront[1]=Diff.norm();
  } else {
    for(i=0;i<nbpt;i++) {
      for(j=0;j<3;j++) {
        Pn[j]=fronts[ifront][idx0+i*ndx+j];
        N[j]=fronts[ifront][idx0n+i*ndx+j];
        B[j]=fronts[ifront][idx0b+i*ndx+j];
      }
      Tn=N*B; 
      if(i<(nbpt-1)) {
        for(j=0;j<3;j++) {
          Pnp1[j]=fronts[ifront][idx0+(i+1)*ndx+j];
          N[j]=fronts[ifront][idx0n+(i+1)*ndx+j];
          B[j]=fronts[ifront][idx0b+(i+1)*ndx+j];
        }
        Tnp1=N*B; 
      }
      if(i>0) {
        for(j=0;j<3;j++) {
          Pnm1[j]=fronts[ifront][idx0+(i-1)*ndx+j];
          N[j]=fronts[ifront][idx0n+(i-1)*ndx+j];
          B[j]=fronts[ifront][idx0b+(i-1)*ndx+j];
        }
        Tnm1=N*B; 
      }
      P1=Pn; // Usefull for last case
      if(i==0) {
        Diff=(Pnp1-Pn);
        ds=Diff.norm();
        Diff=(Tnp1-Tn);
        dnds=Diff.norm()/ds;
        ds=0.;
      } else if(i==(nbpt-1)) {
        Diff=(Pn-Pnm1);
        ds=Diff.norm();
        Diff=(Tn-Tnm1);
        dnds=Diff.norm()/ds;
      } else {
        Diff=(Pnp1-Pnm1);
        ds=Diff.norm();
        Diff=(Tnp1-Tnm1);
        dnds=Diff.norm()/ds;
        Diff=(Pn-Pnm1);
        ds=Diff.norm();
      }
      if(i>0) Sfront[i]=Sfront[i-1]+ds;
      Cfront[i]=dnds;
    } 
  }
  if(if_abs==0) {
    // Check if front is closed
    Diff=P1-P0;
    if(Diff.norm()<1.e-6) {
      Sfront.resize(0); 
    } else {
      SfrontI[nbpt-1]=0.;
      for(i=(nbpt-2);i>=0;i--) {
        SfrontI[i]=SfrontI[i+1]+Sfront[i+1]-Sfront[i]; 
      }
      for(i=0;i<nbpt;i++) {
        if(SfrontI[i]<Sfront[i]) Sfront[i]=SfrontI[i];
      }
    } 
  }
}

double front_length(ARRAY <VECTOR> &fronts,int ifront)
{
  double length,tmp0,tmp1;
  int i,j,idx;

  length=0.;
  if(ifront>=fronts.size()) return(-1.);
  if(ifront==-1) {
    for(i=0;i<fronts.size();i++)
      length=length+front_length(fronts,i);
    return(length);
  }

  idx=3;

  for(i=1;i<fronts[ifront][1];i++) {
    tmp1=0.;
    for(j=0;j<3;j++) {
      tmp0=fronts[ifront][idx+j+9]-fronts[ifront][idx+j];
      tmp1=tmp1+tmp0*tmp0;
    }
    length+=sqrt(tmp1);
    idx=idx+9;
  }

  return length;
}

double front_propag_law(int ifront,int& faster_point,ARRAY <VECTOR> &fronts,VECTOR &Gtime,MATRIX &G,MATRIX& GII,MATRIX &ANGLE,MATRIX &TEMP,VECTOR &DX,VECTOR &DY)
{
  int i,j,nbpt,pos;
  double N, da,dx,dy,admax;
  VECTOR Gp, Ap, Tp;
  POINTER of;
  ARRAY< VECTOR > Mextra_info;

  nbpt=G.m;
  if(!propag_law.Null()) {
     of.set(propag_law.validate_output(cur_cyc));
     of<<"******** FRONT"<<itoa(ifront)<<" ********"<<endl;
  }

  // Resize in case it is not done...
  if(DX.size()!=nbpt) DX.resize(nbpt);
  if(DY.size()!=nbpt) DY.resize(nbpt);
  Mextra_info.resize(nbpt); 
  if(if_dGda) front_Mextra_info.resize(nbpt);

  Gp.resize(!Gtime); Ap.resize(!Gtime); Tp.resize(!Gtime);
  // Compute 1 cycle advance
  admax=0.;
  for(i=0;i<nbpt;i++) { // loop on front points
    // extract data for the current point
    for(j=0;j<!Gtime;j++) {
       Gp[j] = G(j,i); Ap[j] = ANGLE(j,i); Tp[j] = TEMP(j,i);
    }
    // Send distance to surface and curvature
    dx=DX[i]; dy=DY[i];
    // da : advance along the normal
    // dx,dy : advance in crack local frame,
    // accounting for bifurcation angle selected
    if(propag_law.Null()) da = paris_law(Gtime,Gp,Ap,Tp,dx,dy);
    else {
       propag_law.info.max_h = max_h;
       propag_law.info.pt_rk=i;
       propag_law.cyc = cur_cyc;
       propag_law.info.branch_id=branch_id;
       propag_law.info.i_propag = cur_cyc;
       pos = 3 + i*3*3; // header of size 3 + 3 3D vectors for each point
       for(j=0;j<3;j++) propag_law.info.coord[j] = fronts[ifront][pos+j]; pos = pos+3;
       for(j=0;j<3;j++) propag_law.info.N[j]     = fronts[ifront][pos+j]; pos = pos+3;
       for(j=0;j<3;j++) propag_law.info.B[j]     = fronts[ifront][pos+j]; pos = pos+3;
       if(extrafield>0) {
         // Get all SIF informations from post
         extrafields_to_propag_law(i,!Gtime);
       }
       da = propag_law.compute_propag(Gtime,Gp,Ap,Tp,dx,dy);
       // Check for number of branch
       if(branch_id==0) {
         if(propag_law.info.branch_id>max_branch) max_branch=propag_law.info.branch_id;
       }
       Mextra_info[i]=propag_law.info.extra_info;
       if(if_dGda) front_Mextra_info[i]=propag_law.info.extra_info;
    }
    if(abs(da)>abs(admax)) { admax=da; faster_point = i; }
    DX[i]=dx; DY[i]=dy; 
  }
  if(!propag_filter.Null()) {
     if(!propag_law.Null()) propag_filter.set_output(propag_law.validate_output(cur_cyc));
     propag_filter.cyc = cur_cyc;
     propag_filter.apply_filter(DX,DY,Mextra_info);
     //choose new fastest point, can be different from the unfiltered one
     admax=0.;
     for(i=0;i<!DX;i++) {
       double daf = sqrt(DX[i]*DX[i] + DY[i]*DY[i]);
       if(abs(daf)>abs(admax)) { admax=daf; faster_point = i; }
     }
  }
  return(admax);
}

double front_propag_loop(int ifront,int mode,double control,ARRAY <VECTOR> &fronts,VECTOR &Gtime,MATRIX &G,MATRIX& GII,
  MATRIX &ANGLE,MATRIX &TEMP,VECTOR &DX,VECTOR &DY)
{
  int i,j,nbpt,pos;
  double N,ret,dx,dy,max_ret;
  VECTOR Gp,Ap,Tp;
  ARRAY< VECTOR > Mextra_info;

  nbpt=G.m;
  Gp.resize(!Gtime); Ap.resize(!Gtime); Tp.resize(!Gtime);
  max_ret=0.0;
  Mextra_info.resize(nbpt);
  for(i=0;i<nbpt;i++) { // loop on front points
    // extract data for the current point
    for(j=0;j<!Gtime;j++) {
       Gp[j] = G(j,i); Ap[j] = ANGLE(j,i); Tp[j] = TEMP(j,i);
    }
    // dx,dy : advance in crack local frame,
    // accounting for bifurcation angle selected
    propag_law.info.max_h = max_h;
    propag_law.info.pt_rk=i;
    propag_law.cyc = cur_cyc;
    propag_law.info.branch_id=branch_id;
    propag_law.info.c_factor=-1.;
    propag_law.info.i_propag = cur_cyc;
    pos = 3 + i*3*3; // header of size 3 + 3 3D vectors for each point
    for(j=0;j<3;j++) propag_law.info.coord[j] = fronts[ifront][pos+j]; pos = pos+3;
    for(j=0;j<3;j++) propag_law.info.N[j]     = fronts[ifront][pos+j]; pos = pos+3;
    for(j=0;j<3;j++) propag_law.info.B[j]     = fronts[ifront][pos+j]; pos = pos+3;
    if(extrafield>0) {
      // Get all SIF informations from post
      extrafields_to_propag_law(i,!Gtime);
    }
    // mode=1 , number of loops to get an advance corresponding to "control"
    // mode=0 , advance after "control" loops 
    ret = propag_law.loop_propag(mode,control,Gtime,Gp,Ap,Tp,dx,dy);
    // Test if this branch doesn't advance
    if(mode==1) {
       if(i==0)             max_ret = ret;
       else if(ret<max_ret) max_ret = ret;
    }
    else if(ret>max_ret) max_ret=ret;
    DX[i]=dx; DY[i]=dy;
    // Check for number of branch
    if(branch_id==0) {
      if(propag_law.info.branch_id>max_branch) max_branch=propag_law.info.branch_id;
    }
    Mextra_info[i] = propag_law.info.extra_info;
  }
  // For not branching cracks
  if(propag_filter.Null()) {
     propag_filter.set_output(propag_law.validate_output(cur_cyc));
     propag_filter.cyc = cur_cyc;
     propag_filter.apply_filter(DX,DY,Mextra_info);
   
  }
  return(max_ret);
}

// Sample Paris law
double paris_law(VECTOR& Gtime, VECTOR& G, VECTOR& A, VECTOR& T, double& dx, double& dy)
{ int i;
  double Gmin, Gmax, Amax, Tmax, da;
  // Get min max
  Gmax = 0.0; Gmin = 1.e50; Amax = 0.0; Tmax = T[0];
  for(i=0;i<!Gtime;i++) {
      // Do not take into account initial transfered value
      if((!Gtime>2)&&(Gtime[i]<=0.0)&&(i==0)) continue;
      if(G[i]>Gmax) { Gmax = G[i]; Amax = A[i]; Tmax = T[i]; }
      if(G[i]<Gmin)   Gmin = G[i];
  }
  if(Gmin<0.0)  Gmin = 0.0;
  if(!Gtime==1) Gmin = 0.0;
  if((Gtime[0]<=0.)&&(Gmin>0.0)) Gmin = 0.0;

  paris_C.compute_value(Tmax); paris_m.compute_value(Tmax);

  da = paris_C()*(Gmax-Gmin)^paris_m();
  // using the angle corresponding to Gmax to compute (dx,dy)
  dx = da*cos(Amax);
  dy = da*sin(Amax);
  return(da);
}

// Compute advance for every point
int compute_advance(ARRAY <VECTOR> &fronts,MATRIX &Gvalues,double gadv_max)
{ int i,j,k,ifast,jfast,faster_pt,nbpt,is_nonlinear;
  VECTOR Gtime,DX,DY;
  ARRAY<VECTOR> aDX,aDY,oaDX,oaDY;
  MATRIX G,GII,ALPHA,TEMP;
  double max_advance,dmax,length,required_adv,x,y,Nloop,da;
  ARRAY<VECTOR> dg_correction;

  // Structure frot branching fronts
  ARRAY <VECTOR> Nfronts;
  MATRIX NGvalues;

  // Reset branching id
  branch_id=0; 
  max_branch=1;
  branches_DX.reset();
  branches_DY.reset();
  branches_base_front.reset();
  branches_number.reset();

  if(if_dGda) dg_correction.resize(fronts.size());
  else dg_correction.resize(0);

  // Set linear/nonlinear type for dGda
  if(propag_law.Null()) is_nonlinear = 0;
  else                  is_nonlinear = propag_law.is_nonlinear();

  // 4 stages
  // 1st stage: find fastest
  required_adv=gadv_max;
  aDX.resize(fronts.size());
  aDY.resize(fronts.size());
  length=front_length(fronts,-1);
  if(required_adv<0) {
    required_adv=min_size*abs(required_adv);
    if(if_lip_factor) {
      dmax=length/lip_factor;
      if(dmax>1.) required_adv=required_adv*dmax; // Only if increase advance
    }
  }
  ifast=0; jfast=0; max_advance=0.;
  for(i=0;i<fronts.size();i++) {
    if(get_front_info(fronts,Gvalues,i,Gtime,G,GII,ALPHA,TEMP,DX,DY)) return(-1);
    da=front_propag_law(i,faster_pt,fronts,Gtime,G,GII,ALPHA,TEMP,DX,DY);
    if(if_dGda) {
      // Get last term for dg correction
      dg_correction[i].resize(front_Mextra_info.size());
      for(j=0;j<dg_correction[i].size();j++) {
        dg_correction[i][j]=front_Mextra_info[j][front_Mextra_info[j].size()-1];
      }
    }
    // Init value
    aDX[i]=DX; aDY[i]=DY;
    // Get fastest advance
    // VC DEBUG DISLO // cout << i <<": "<<da << " --- " << max_advance <<endl<<flush;
    if(abs(da)>abs(max_advance)) { ifast=i; jfast=faster_pt; max_advance=da; }
  }
  if(abs(max_advance)<1.e-19) {
    ERROR("Got null advance = "+dtoa(max_advance)+" ... exiting");
    return(1);
  }

  if(max_branch>1) {
    base_fronts.resize(fronts.size());
    for(i=0;i<fronts.size();i++) {
      base_fronts[i].resize(fronts[i].size());
      for(k=0;k<fronts[i].size();k++) base_fronts[i][k]=fronts[i][k];
    }
  }

  if(is_nonlinear) {
    // dGda must be implemented directly for nonlinear propagation
    if(get_front_info(fronts,Gvalues,ifast,Gtime,G,GII,ALPHA,TEMP,DX,DY)) return(-1);
    // 2nd stage: for fastest front only calls front_propag_loop() (invert=TRUE)
    // to get get the number of loops to get the required_adv
    if(Nexplicit>0.) Nloop=Nexplicit;
    else {
      Nloop = front_propag_loop(ifast,1,required_adv,fronts,Gtime,G,GII,ALPHA,TEMP,DX,DY);
      aDX[ifast]=DX; aDY[ifast]=DY;
    }
    // 3rd stage: finish computation, do Nloop loops in front_propag_loop() (invert=FALSE)
    for(branch_id=0;branch_id<max_branch;branch_id++) {
      for(i=0;i<fronts.size();i++) {
         if(get_front_info(fronts,Gvalues,i,Gtime,G,GII,ALPHA,TEMP,DX,DY)) return(-1);
         da = front_propag_loop(i,0,Nloop,fronts,Gtime,G,GII,ALPHA,TEMP,DX,DY);
         if(branch_id>0) {
           if(da!=0.) { // A branch is created
             branches_DX.add(DX);
             branches_DY.add(DY);
             branches_base_front.add(i);
             branches_number.add(branch_id);
           }
         } else aDX[i]=DX; aDY[i]=DY;
      }
    }
  }
  else {
    // invert linear law for all fronts
    if(Nexplicit>0.) Nloop=Nexplicit;
    else { Nloop = required_adv/abs(max_advance);
      // Correct Nloop to agree with true advance
      // Apply derivative correction (will be approximately applied)
      if(if_dGda) {
        y=dg_correction[ifast][jfast];
        x=Nloop*y;
        if(abs(x)>.5) x=.5*x/abs(x); // Maximize correction
        Nloop = Nloop*(1.-x); 
        cout << "*** dG/da correction factor for fastest front point "<<x<<endl;cflush();
      }
    }
    if(if_dGda) {
      dmax=0.;
      for(i=0;i<fronts.size();i++) {
        for(j=0;j<aDX[i].size();j++) {
          x=Nloop*dg_correction[i][j];
          if(abs(x)>.5) x=.5*x/abs(x); // Maximize correction
          if(Nexplicit>0.) {
            if(abs(x)>abs(dmax)) dmax=x;
          }
          x=Nloop/(1.-x);
          aDX[i][j]=aDX[i][j]*x;
          aDY[i][j]=aDY[i][j]*x;
          if(Nexplicit<=0.) {
            y=aDX[i][j]*aDX[i][j]+aDY[i][j]*aDY[i][j];
            if(y>dmax) dmax=y;
          }
        }
      }
      if(Nexplicit>0.) {
        cout << "*** dG/da max correction factor = "<<dmax<<endl;cflush();
      } else {
        dmax=sqrt(dmax);
        cout << "*** dG/da correction computed advance = "<<dmax<<" for "<<required_adv<<" prescribed"<<endl;cflush();
      }
    } else {
      for(i=0;i<fronts.size();i++) { aDX[i] = aDX[i]*Nloop; aDY[i] = aDY[i]*Nloop; }
    }
    if(max_branch>1) {
      // Get and store extension for branches
      for(branch_id=1;branch_id<max_branch;branch_id++) {
        for(i=0;i<fronts.size();i++) {
          if(get_front_info(fronts,Gvalues,i,Gtime,G,GII,ALPHA,TEMP,DX,DY)) return(-1);
          DX.resize(G.m);
          DY.resize(G.m);
          da=front_propag_law(i,faster_pt,fronts,Gtime,G,GII,ALPHA,TEMP,DX,DY);
          if(da!=0.) {
            DX=DX*Nloop; DY=DY*Nloop;
            branches_DX.add(DX);
            branches_DY.add(DY);
            branches_base_front.add(i);
            branches_number.add(branch_id);
          }
        }
      }
    }
  }

  cout<<endl<<"Got max_advance="<<max_advance<<" , want: "<<required_adv<<", scaled with DN="<<Nloop<<endl<<endl; cflush();
  Ncycles=Ncycles+Nloop;
  cout << "Propagation law advance to Ncycles="<<Ncycles<<flush<<endl;

  // 4th stage: write output
  for(i=0;i<fronts.size();i++) {
    for(j=0;j<aDX[i].size();j++) {
      put_advance(fronts,i,j,aDX[i][j],aDY[i][j]);
    }
  }

  if(cur_cyc>0) {
     update_remesh_file(cur_cyc,required_adv,Nloop,ifast,jfast,fronts,Gvalues);
     if(if_ebe * (nb_fnodes>0) * (interp_coef>0.) ) {
       // Interpolation of advance values and use initial data
       oaDX.resize(fronts.size());
       oaDY.resize(fronts.size());
       for(i=0;i<fronts.size();i++) {
         nbpt=ofronts[i][1];
         oaDX[i].resize(nbpt);
         oaDY[i].resize(nbpt);
         x=0;
         for(j=0;j<nbpt;j++) {
           k=x;
           if(k>=(aDX[i].size()-1)) k=aDX[i].size()-2;
           y=k;
           z=x-y;
           y=1.-z;
           oaDX[i][j]=y*aDX[i][k]+z*aDX[i][k+1];
           oaDY[i][j]=y*aDY[i][k]+z*aDY[i][k+1];
           x=x+interp_coef;
         }
         for(j=0;j<oaDX[i].size();j++) {
           put_advance(ofronts,i,j,oaDX[i][j],oaDY[i][j]);
         }
       }
       update_zck_file(cur_cyc,Nloop,ofronts,oGvalues,oaDX,oaDY);
     } else update_zck_file(cur_cyc,Nloop,fronts,Gvalues,aDX,aDY);
  }
  return(0);
}

int put_advance(ARRAY <VECTOR> &fronts,int ifront,int ipos,double &DX,double &DY)
{
  VECTOR direction;
  int idx,i;
  if(ifront>=fronts.size()) return(1);
  if(ipos>=fronts[ifront][1]) return(2);
  idx=3+9*ipos;
  // Get vectors
  direction.resize(3); 
  for(i=0;i<3;i++) {
    direction[i]=DX*fronts[ifront][idx+i+3]+DY*fronts[ifront][idx+i+6];
  }
  for(i=0;i<3;i++) {
    fronts[ifront][idx+i+3]=direction[i];
  }
  return(0);
}


// NRNR Generate an advance file for adaptive CZM
//modif pour mettre la petite queue qui depasse sinon ca ne marche pas
int write_czm_advance(STRING &file_name,ARRAY<VECTOR> fronts)
{

  Zfstream inp;
  STRING cmd;
  int i,j,k,h,ret;
  double tempA, tempB, tempC, tempD, beta;
  inp.open(file_name,ios::out);
  inp.setf(ios::scientific);
  inp.precision(64);


  beta = adv_t; 
  alpha = adv_f;

  inp<<"# Automatic driven crack advance generated by write_czm_advance script"<<endl;
  inp<<fronts.size()<<endl; // front.size() = number of fronts
  for(i=0;i<fronts.size();i++) {
    k=fronts[i][0];
    inp<<"CZM_FRONT"<<k<<endl; // fronts[i][0] = front number 
    k=fronts[i][1]; // fronts[i][1] = number of nodes on the front number front[i][0]
    inp<<k<<endl;
    h=3;
    for(j=0;j<fronts[i][1];j++) { // boucle sur le nombre de noeuds dans le front i
        //inp<<"J = "<<j<<" "; 
      for(k=0;k<3;k++) {
        //inp<<"h"<<h<<" ";  
      // choper le premier noeud (A) et le deuxieme noeud (B) du front

        if (j==0) {
            tempA = ((-1.)*beta*fronts[i][h+3 +3 + 6 ]  + fronts[i][h]) ;
            tempB = ((-1.)*beta*fronts[i][h+3 +3 + 6 ]  + fronts[i][h+6+3]) ;
            inp<<((1.)*alpha*(tempB-tempA) + tempA)<<" ";

       } else if (j==(fronts[i][1]-2)) {
          inp<<((-1.)*beta*fronts[i][h+3] + fronts[i][h])<< " ";

       } else if (j==(fronts[i][1]-1)) {
           tempA = ((-1.)*beta*fronts[i][h+3 -3 - 6 ]  + fronts[i][h]) ;
          tempB = ((-1.)*beta*fronts[i][h+3 -3 - 6 ]  + fronts[i][h-6-3]) ; // le point a cote
          inp<<((1.)*alpha*(tempB-tempA) + tempA)<<" ";
  //        inp<<((1.)*beta*fronts[i][h+3] + fronts[i][h])<< " ";         
          //tempA = ((1.)*beta*fronts[i][h+3] + fronts[i][h]) ; // le point a shifter
          //tempB = ((1.)*beta*fronts[i][h+3 -3 - 6 ]  + fronts[i][h-6-3]) ; // le point a cote
         // inp<< ((1.)*alpha*(tempB-tempA) + tempA)<<" ";


        } else inp<<((-1.)*beta*fronts[i][h+3] + fronts[i][h])<< " "; //shift simple dans la direction contraire au vecteur ini 
    
        h++;
       }
      inp << endl;
      h=h+6;
    }
    h=6;
    for(j=0;j<fronts[i][1];j++) {
      for(k=0;k<3;k++) {
        //inp<<"h"<<h<<" ";
        //inp<<(beta*fronts[i][h] + fronts[i][h])<< " ";

        if (j==0) {
           inp<<fronts[i][h+3 + 6 ] <<" ";

         } else if (j==(fronts[i][1]-1)) {
            inp<<fronts[i][h-3 - 6 ] <<" ";
        } else

          inp<<fronts[i][h] << " ";

        h++;
      }
      inp << endl;
      h=h+6;
    }
  }
  inp.close();

  return(0);

}

// Remesh only from given advance file
// INPUT
// fichier adv : cracked_name+"_PROPAG.adv"
// maillage d'entree zset : TO_REMESH.geo
// maillage de sortie : REMESHED.geo
// Muse
double propag_with_adv()
{
   STRING cmd;
   write_remesh_new(1);
   cout<<endl<<"Perform remeshing..."<<endl<<endl<<flush;
   if(os != "win32") {
     cmd=ZRUN_CMD+" -m "+cracked_name+"_REMESH.inp > REMESH_REPORT";
   }
   else cmd=ZRUN_CMD+" -m "+cracked_name+"_REMESH.inp >> REMESH_REPORT";
   ret = system(cmd);
   if(ret==0) return(1.);
   else return(0.);
}

//ABR---11/2022...vtk.series file to access all the vtk file series written during propag cycles
void write_vtk_data(int nb_cyc, STRING vtk_series_file_name, STRING prefix){
  STRING fname;
  Zfstream vtk_series_file;

  vtk_series_file.open(vtk_series_file_name,ios::out);
  vtk_series_file<<"{"<<endl;
  
  vtk_series_file<<"  \"file-series-version\" : \"1.0\",\n  \"files\" : ["<<endl;
  for(int cyc=0;cyc<nb_cyc;cyc++) {
    fname = prefix+itoa(cyc+1)+".vtk";
    vtk_series_file<<"    {\"name\" : "<<"\""<<fname<<"\", "<<"\"time\" : "<<itoa(cyc+1)<<" },"<<endl;
  }
  vtk_series_file<<"  ]"<<endl;
  
  
  vtk_series_file<<"}"<<endl;
  vtk_series_file.close();
}


// Remesh in case of bad quality or error
int propag_and_remesh(int cyc,int max_remesh, double local_radius) {
  int iremesh,err,ret,ok;
  double adv_length,quality,DN,Nex;
  STRING geof_name,adv_name,gpp_name,name,cmd;
  ARRAY <VECTOR> fronts;
  MATRIX Gvalues;

  // set default local radius
  if(local_radius<=0.) local_radius=10.*min_size;

  // Save max_h
  adv_length=max_h;
  Nex=Nexplicit;
  gpp_name = cracked_name+"_GPP_PROPAG"+itoa(cyc);
  if(nb_dd>1) { 
    gpp_name = cracked_name+"_PROPAG"+itoa(cyc);
    geof_name = cracked_name+"_PROPAG"+itoa(cyc)+".geo";
  } else {
    if(cyc==1) geof_name = cracked_name+".geo";
    else       geof_name = cracked_name+"_PROPAG"+itoa(cyc-1)+".geo";
  }

  for(iremesh=0;iremesh<max_remesh;iremesh++) {
    ret = 0;
    if(STD_FILE_EXISTS("REMESHED.geo")) ret = STD_RM("REMESHED.geo");
    if(ret) {
       cout<<endl<<"Cannot clean file REMESHED.geo ... exiting remesh loop"<<endl<<endl;
       break;
    }
    name = gpp_name+".ZCPOST";
    cout<<endl<<" . reading SIF in file: "<<name<<endl; cflush();
    err = read_zcpost(name,fronts,Gvalues);
    if(err) {
      cout<<endl<<"Invalid GPP results file: "<<name<<" ... end"<<endl<<endl;
      return(1);
    }
    if(fronts.size()==0) {
       cout<<endl<<"No more crack front: calculation is finished."<<endl<<endl;
       return(1);
    }
    save_sif_files(fronts.size(), cyc);

    if(smooth_propag>1) {
      cout << "Reducing all fronts value by factor "<<smooth_propag<<"."<<endl;
      smooth_fronts(fronts,Gvalues,smooth_propag,if_remove_ext_propag);
    }

    // Add data for previous cycle
    if(if_dGda&&(cyc>1)) {
      cout << "Using previous data!"<<endl; cflush();
      save_fronts(fronts,Gvalues);
      name = cracked_name+"_GPP_PROPAG"+itoa(cyc-1)+".ZCPOST";

      cout<<endl<<" . reading previous SIF in file: "<<name<<endl; cflush();
      err = read_zcpost(name,fronts,Gvalues);
      if(err) {
        cout<<endl<<"Invalid GPP results file: "<<name<<" ... end"<<endl<<endl;
        return(1);
      }
      if(fronts.size()) {
        get_NDN_from_remesh(cyc-1, DN);
        DN=1.; // new version
        if(add_fronts_to_saved(fronts,Gvalues,4,DN)) {
          name = gpp_name+".ZCPOST";
          cout<<endl<<"Unable to perfom dG/da . reading SIF in file: "<<name<<endl; cflush();
        }
      }
      restore_fronts(fronts,Gvalues);
    } else if(if_dGda) { 
      max_h=max_h*.125;
      Nexplicit=Nexplicit*.125;
      cout << "Reduce advance for first step."<<endl; cflush();
    }

    compute_advance(fronts,Gvalues,max_h);
    // Write corresponding advance file
    adv_name = cracked_name+"_PROPAG"+itoa(cyc)+".adv";
    write_advance(adv_name,fronts);

    // o with abaqus node position can change because of contact options
    //   this updated position is stored in the odb file
    //   use geometry from odb when doing transfer
    // o with ansys order of nodes/elements is changed in the rst file
    //   so it's important to use the original geo file

    if(format.start_with("abaqus")*if_transfert) STD_CP(gpp_name+".geo","TO_REMESH.geo");
//    else if(if_2D&&(!if_2DE)&&(!if_shell))       STD_CP(geof_name+"3D","TO_REMESH.geo");
    else                                         STD_CP(geof_name,"TO_REMESH.geo");
    STD_CP(adv_name,cracked_name+"_PROPAG.adv");

    // Perform remeshing

    if(if_czm) { 
      cout<<endl<<" . Remeshing to extract CZM front... "<<endl<<endl; cflush();
      STD_RM("REMESH_REPORT");
      system("Zrun -m "+cracked_name+"_REMESH_CZM.inp > REMESH_REPORT");
      STD_MV("REMESHED.geo","TO_REMESH.geo");
      STD_CP("union.mesh","union_CZM.mesh");
      cout<<endl<<" Done. "<<endl<<endl; cflush();
    }

    write_remesh_new(1);
    cout<<endl<<"Perform remeshing..."<<endl<<endl<<flush;
    if(os != "win32") {
      //cmd=ZRUN_CMD+" -m "+cracked_name+"_REMESH.inp | tee REMESH_REPORT";
      cmd=ZRUN_CMD+" -m "+cracked_name+"_REMESH.inp > REMESH_REPORT";
    }
    else cmd=ZRUN_CMD+" -m "+cracked_name+"_REMESH.inp >> REMESH_REPORT";
    if(iremesh==0) STD_RM("REMESH_REPORT");
    ret = system(cmd);

    if(os != "win32") ret=system("grep CPU REMESH_REPORT");
    ok = STD_FILE_EXISTS("REMESHED.geo");
    if(!ok) {
      cout<<endl<<"Remeshing failed, no REMESHED.geo file ... Retry if possible"<<endl<<endl;
      max_h=.5*max_h;
      Nexplicit=.5*Nexplicit;
      if(iremesh>=(max_remesh-1)) {
         cout<<endl<<"Max number of remeshing attempt failed! -> Check your model or contact the hotline."<<endl<<endl;
         return(1);
      }
    } else {
      cout<<endl<<"Done."<<endl<<endl;
      // Save .mesh files
      if(if_2D) STD_CP("_mesh_out_.mesh",cracked_name+"_PROPAG"+itoa(cyc)+".mesh");
      else STD_CP("_mesh_out_to_ghs3d.mesh",cracked_name+"_PROPAG"+itoa(cyc)+".mesh");

      // Try to increase mesh quality
      if(!if_hexa) {
        quality=refine_bad_quality(max_quality,local_radius);
        write_remesh_new(1);
        if((quality<max_quality)||(iremesh>0)) break;
        else {
          cout<<endl<<"Quality not suitable: retry to improve once."<<endl<<endl;
          if(iremesh==0) { max_h=1.5*max_h; Nexplicit=.5*Nexplicit; }
          else { max_h=.5*max_h; Nexplicit=.5*Nexplicit; }
        }
      } else break;
    }
  }

  // Restore max_h
  max_h=adv_length;
  Nexplicit=Nex;
  STD_RM(cracked_name+"_PROPAG.adv");
  STD_RM("TO_REMESH.geo");
  if((ret==0)*(diff_mesh(geof_name,"REMESHED.geo")==0)) {
     cout<<endl<<"got the same mesh after remeshing ... stop"<<endl<<endl;
     ret = 1;   
  }
  return(ret);
}



// Generate an advance file
int write_advance(STRING &file_name,ARRAY<VECTOR> fronts)
{
  Zfstream inp;
  STRING cmd;
  int i,j,k,h,ret,nb_front,ifront,nbbf;
 
  nbbf=fronts.size();
  nb_front=nbbf+branches_base_front.size();

  // Rewrites if necessary
  if(nb_front>nbbf) {
    cout <<"** Regenerate remeshing file due to branches creation"<<endl<<flush;
    write_remesh_new(1);
  }

  inp.open(file_name,ios::out);
  inp.setf(ios::scientific);
  inp.precision(64);

  inp<<"# Automatic driven crack advance generated by write_advance script"<<endl;
  inp<<nb_front<<endl;
  for(i=0;i<nb_front;i++) {
    ifront=i;
    if(ifront<nbbf) {
      k=fronts[ifront][0];
      inp<<"FRONT"<<k<<endl;
    } else {
      // Deal with branches
      h=i-nbbf;
      ifront=branches_base_front[h];
      k=fronts[ifront][0];
      inp<<"FRONT"<<k<<"_"<<branches_number[h]<<endl;
      // Reset base front in current
      for(k=0;k<fronts[ifront].size();k++) fronts[ifront][k]=base_fronts[ifront][k];
      // No put advance
      for(j=0;j<branches_DX[h].size();j++) {
        put_advance(fronts,ifront,j,branches_DX[h][j],branches_DY[h][j]);
      }
    }
    k=fronts[ifront][1];
    inp<<k<<endl;
    h=3;
    for(j=0;j<fronts[ifront][1];j++) {
      for(k=0;k<3;k++) {
        inp<<fronts[ifront][h] << " ";
        h++;
      }
      inp << endl;
      h=h+6;
    }
    h=6;
    inp.precision(4);
    for(j=0;j<fronts[ifront][1];j++) {
      for(k=0;k<3;k++) {
        inp<<fronts[ifront][h] << " ";
        h++;
      }
      inp << endl;
      h=h+6;
    }
    inp.precision(64);
  }
  inp.close();
  return(0);
}

int kill(STRING what)
{
  STRING str;
  if(what=="REMESH") {
    str= "pkill mg; pkill cut";
    ret = system(str);
  }
  str="kill `ps ux --cols 512 | grep "+cracked_name+" | grep "+what+" | grep Zebulon | awk '{print $2}' `";
  ret = system(str);
}

int zcracks_main()
{ 
  //init_var(); // must be called by zcracks

  import_formats.reset();
  if(!only_templated) {
     import_formats.add("med");
     import_formats.add("mesh");
     import_formats.add("abaqus");
  }
  import_formats.add("abaqus_templated");
  import_formats.add("ansys_templated");
  import_formats.add("aster_templated");
  import_formats.add("samcef_templated");
  import_formats.add("zebulon_templated");

  datafile="zcrack.dat";
  init_values(0);
  if(init_values(1)==1) { init_values(0); write_data(); init_values(1); }
  
  version = "1.0";
  if(new_version) version = "2.2";
 
  zddv_path = getenv("Z7PATH");

  search = ".";
  find_files(search,"",data_files);

  cout<<endl<<endl;
  cout<<"==================================================================="<<endl;
  cout<<"Script ZCRACKS v"<<version<<endl;
  cout<<"==================================================================="<<endl;

  cout<<flush;

  open_crack_info();

  if (embedded!=-1) {
    if (embedded) build_dialog();
    else graphics_app.startup(do_command);
  }
  return(0);
}

int init_qsubserver()
{
  int ret;
  STRING cmd,cpwd;
  
  cpwd=getenv("PWD");
  SQS_RUN_SERVER_NAME_QUEUE="LARGE.q";
  SQS_RUN_SERVER_FILE_STATE=cpwd+"/"+SQS_RUN_SERVER_NAME_QUEUE+".SQS_RUN_STATE_"+itoa(qsubserver);
  
  cmd="createQsubServer.sh "+SQS_RUN_SERVER_NAME_QUEUE+" "+SQS_RUN_SERVER_FILE_STATE;
  ret=system(cmd);

  if(ret==0) {
    cmd=del_cmd+" ~/QSUB_CPWD SQS_RUN_SERVER_NAME_QUEUE SQS_RUN_SERVER_FILE_STATE";
    system(cmd);
    cmd="echo \""+cpwd+"\" > ~/QSUB_CPWD";
    system(cmd);
    cmd="echo \""+SQS_RUN_SERVER_NAME_QUEUE+"\" > SQS_RUN_SERVER_NAME_QUEUE";
    system(cmd);
    cmd="echo \""+SQS_RUN_SERVER_FILE_STATE+"\" > SQS_RUN_SERVER_FILE_STATE";
    system(cmd);
    // ZRUN_CMD="sendCommandToQsubServer.sh "+SQS_RUN_SERVER_NAME_QUEUE+" "+SQS_RUN_SERVER_FILE_STATE+" "+cpwd+" Zrun ";
    yams_prefix=getenv("Z7PATH")+"/bin/qsub";
    //yams_prefix=getenv("Z7PATH")+"/bin/sendCommandToQsubServer.sh "+SQS_RUN_SERVER_NAME_QUEUE+" "+SQS_RUN_SERVER_FILE_STATE+" "+cpwd+" "+distene_path+"/";
  } else {
    ZRUN_CMD="Zrun ";
    ERROR("Unable to init Qsubserver");
  }
  
  return(ret);
}

int close_qsubserver()
{
  int ret;
  STRING cmd;
  
  cmd="stopQsubServer.sh "+SQS_RUN_SERVER_NAME_QUEUE+" "+SQS_RUN_SERVER_FILE_STATE;
  ret=system(cmd);

  if(ret) {
    ERROR("Unable to close Qsubserver");
  }
  ZRUN_CMD="Zrun ";
  
  return(ret);  
}

void refinement(Zfstream &file)
{
  double R0,alpha,h,nh,nh2,C,a,b;
  STRING r2,rr;

  if(refine_function!="") {
    if(refine_origin=="DATAFILE") file << "   " << refine_function << endl;
    else file<<"   *refinement "<<refine_function<<endl;
  } else {

    if(refine_origin=="DATAFILE_ORIGIN") {
      file<<"  *refine_file "<<refinement_datafile<<endl;
    }

    // Distance
    r2="x*x+y*y+z*z";
    rr="sqrt("+r2+")";

    // Gradation
    C=1.-1./(gradation);

    // Sizes
    h=min_size;
    //if((gth_radius>0.)&&((rmax>0.)&&(rmax<gth_radius))) {
    if(if_dislo) {
      nh=nb_velem*h;
    } else nh=.333*nb_velem*h;
    nh2=nh*nh;
    
    // R0
    R0=nh; //refine_radius;

    file<<"   *refinement "<<h<<"+"<<"("<<rr<<">"<<nh<<")*"<<C<<"*("<<rr<<"-"<<R0<<");"<<endl;
    if(power_func_coef>0.0)
      file<<"   *smooth_refinement "<<power_func_coef<<endl;
  }
}

int convert_quad(STRING& mesh_name)
{
  Zfstream inp;
  STRING cmd;
  int i,ret;

  inp.open("CONVERT_QUAD.inp",ios::out);
  inp.setf(ios::scientific);

  inp<<"****mesher"<<endl;
  inp<<" ***mesh "<<mesh_name<<endl;
  inp<<"  **open "<<mesh_name<<endl;
  
  if(if_quad) {
    if(quad_opt) {
      inp<<"  **remove_set *elsets QUAD QUAD_EXT"<<endl;
      inp<<"   *nsets QUAD_EXT QUAD_INT QUAD_INTER"<<endl;
      inp<<"   *bsets QUAD_INTER QUAD_INTER_"<<endl;
      inp<<"  **elset_near_nset"<<endl;
      inp<<"   *elset QUAD"<<endl;
      inp<<"   *nset FRONT"<<endl;
      inp<<"   *radius "<<elset_radius<<endl;
      inp<<"   *connect"<<endl;

      inp<<"  **lin_to_quad"<<endl;
      inp<<"   *elset QUAD"<<endl;
      inp<<"   "<<endl;
 
    } else {
      inp<<"  **lin_to_quad"<<endl;
    }

    if(if_barsoum!=0) {
      for(i=0;i<nb_fronts;i++) {
        inp<<"  **crack_3d_quarter_nodes"<<endl;
        inp<<"   *liset FRONT"<<i<<endl;
      }
    }
  } else inp<<"  **quad_to_lin"<<endl;

  if(if_hexa) { 
    inp<<"  **remove_set *elsets FREEMESH"<<endl;
    inp<<"  **elset FREEMESH *use_elset AUTO *not_in_elset REGULAR"<<endl;
  }

  inp<<"****return"<<endl;
  inp.close();

  cmd=ZRUN_CMD+" -m CONVERT_QUAD.inp";
  ret = system(cmd);
  return(ret);
}

// Used for automatic mesh cutting
double check_max_quality(STRING fname)
{
  ASCII_FILE file;
  STRING str,field;
  int i;
  double wquality;
  
  wquality=-1.;
  file.open(fname);
  if(!file.ok) return(-1.);

  for(i=1;i>0;i++) { 
    str=file.getSTRING();
    if(!file.ok) break;
    if(str.start_with("WORST")) {
      str=file.getSTRING();
      if(!file.ok) return(-1.);
      if(str.start_with("ELEMENT")) {
        str=file.getSTRING();
        if(!file.ok) return(-1.);
        if(str.start_with("QUALITY")) {
          wquality=file.getdouble();
          if(!file.ok) {
            wquality=-1.;
            break;
          }
        }
      }
    }
  }
  file.close();

  return wquality;
}


// Used for automatic mesh cutting
double check_output(STRING fname)
{
  ASCII_FILE file;
  STRING str,field;
  int i,in_yams;
  double wquality;
  
  in_yams=0;

  wquality=-1.;
  file.open(fname);
  if(!file.ok) return(-1.);

  for(i=1;i>0;i++) { 
    str=file.getSTRING();
    if(!file.ok) break;
    if(in_yams) {
      if(str.start_with("WORST")) {
        str=file.getSTRING();
        if(!file.ok) return(-1.);
        if(str.start_with("ELEMENT")) {
          str=file.getSTRING();
          if(!file.ok) return(-1.);
          if(str.start_with("QUALITY")) {
            wquality=file.getdouble();
            if(!file.ok) {
              wquality=-1.;
              break;
            }
          }
        }
      } else if(str.start_with("END")) {
        str=file.getSTRING();
        if(!file.ok) return(-1.);
        if(str.start_with("OF")) {
          str=file.getSTRING();
          if(!file.ok) return(-1.);
          if(str.start_with("SESSION")) {
            in_yams=0;
          }
        }
      }
    } else if(str.start_with("YAMS")&&(!if_meshgems)) {
      str=file.getSTRING();
      if(!file.ok) return(-1.);
      if(str.start_with("COPYRIGHT")) {
        in_yams=1;
      }
    } else if(str.start_with("Running")&&(if_meshgems)) {
      str=file.getSTRING();
      if(!file.ok) return(-1.);
      if(str.start_with("MG-SurfOpt")) {
        in_yams=1;
      }
    } else if(str.start_with("ERROR")) {
      str=file.getSTRING();
      if(!file.ok) {
        wquality=-1.;
        break;
      }
      if(!file.ok) return(-1.);
      if(str.start_with("at")) {
        wquality=-2.; 
        break;
      }
    }
  }
  file.close();

  return wquality;
}

int init_values(int val)
{
  ASCII_FILE file;
  STRING str,field;
  int i,t,ret;

  if(val==0) {
    // STRINGs
    if(os=="win32") editor="write";
    else            editor="gedit";
    crack_name="crack";
    sane_name="";
    cracked_name="cracked";
    elset_name="AUTO";
    faset_names="";
    ridge_names="";
    liset_names="";
    geom_names="";
    qsub_file_name="";
    arch = 1;
    if(!if_meshgems) yams_options="-m 512 -FEM -Dridge=45. ";
    else yams_options="";
    temperature_name="";
       // -Dtolerance=1. -Dgeomapp=1.";
       //"-Dgradation=10.";
    // doubles
    filter_tol=1.e-6;
    grid_max=0.;
    lip_tol=1.e-5;
    ra=1.;
    elset_radius=2.;
    smooth_elset_radius=0.;
    rb=3.;
    sigy=0.;
    rmax=0.;
    max_size=0.;
    min_size=.1;
    max_quality=20.0;
    quality_threshold=0.;
    refine_radius=.35;
    hradius=1.;
    hnumber=1;
    n_length=0.1;
    power_func_coef=0.0;
    max_h=0.1;
    ext_dist=-1.;
    lip_factor=.5;
    fatigue_Ti=0.;
    fatigue_DT=2.;
    nb_cycles=10;
    fact_nc=1.0;
    // VECTORS
    center.resize(3);
    center[0]=0.; center[1]=0.; center[2]=0.;
    normal.resize(3);
    normal[0]=0.; normal[1]=0.; normal[2]=1.;
    dir.resize(3);
    dir[0]=1.; dir[1]=0.; dir[2]=0.;
    thickness.resize(0);
    if_2D=0;
    // ints
    if_must_define_elset=0;
    if_quad=0;
    quad_opt=0;
    if_ellipse=0;
    smooth_propag=0;
    if_remove_ext_propag=0;
    if_dGda=0;
    remove_ext_hexa=0;
    if_K=0;
    if_Ki=0;
    if_mpa_m=0;
    if_Gmax=0;
    if_exclude_BE=0;
    if_contact=0;
    if_ext=1;
    if_lip_factor=0;
    if_transfert=0;
    nb_pt=16;
    nb_fronts=128;
    crack_id=0;
    nb_iter=2;
    nb_fnodes=-8;
    nb_velem=3;
    paris_DN=1.0;
    // New stuff
    nset_names="";
    elset_names="";
    slice_name="";
    intersection_mesh="";
    gradation=1.3;
    if_barsoum=0;
    if_must_refine=0;
    if_czm=0;
    if_keep=0;
    if_growing_elset=1;
    if_var_refine=0;
    if_surface_refine=0;
    propag_model = "paris_std";
    old_propag_model = "paris_std";
    filter_type = "no_filter";
    tau = 0.5;
    if_hexa=0;
    nb_hexa=4;
    dr_hexa=-1.;
    prog_hexa=0.;
    th_hexa=8;
    nc_hexa=1;
    return(1);
  } else {
    file.open(datafile);
    if(!file.ok) return(2);
    ret = read_new_format(file);
    file.close();
    return(ret);
  } 
  return(0);
}

int read_config_file(STRING& fname)
{
  ASCII_FILE file;
  datafile = fname;

  file.open(datafile);
  if(!file.ok) ERROR("\nCannot open Z-cracks configuration file "+fname+"\n");
  read_new_format(file);
  file.close();
  return 0;
}

int read_new_format(ASCII_FILE& file)
{ STRING str;
  int i, j, ret;
  double d, pC, pm;
  Zfstream out;

  for(i=0;i>=0;i++) {
     str = file.getSTRING();
     if(!file.ok) break;
     if(str == "*editor") { editor = file.getSTRING(); continue; }
     if(str == "*smp") { smp = file.getint(); continue; }
     if(str == "*sane_name") { sane_name = file.getSTRING(); continue; }
     if(str == "*crack_name") { crack_name = file.getSTRING(); continue; }
     if(str == "*cracked_name") { cracked_name = file.getSTRING(); continue; }
     if(str == "*32_bits") { arch = 0; continue; }
     if(str == "*MedVersion") { MedVersion = file.getSTRING(); continue; }
     if(str == "*temperature_name") { temperature_name = file.getSTRING(); continue; }
     if(str == "*yams_options") {
        yams_options = "";
        for(j=0;j>=0;j++) {
           str = file.getSTRING();
           if(!file.ok) break;
           if(str.start_with("*")) { file.back(); break; }
           yams_options = yams_options + " " + str;
        }
        if(yams_options.locate("-Dridge")&&(if_meshgems)) yams_options="";
        continue;
     }
     if(str == "*curvature_refine") { if_var_refine = 1; continue; }
     if(str == "*surface_refine") { if_surface_refine = 1; continue; }
     if(str == "*gradation") { gradation = file.getdouble(); continue; }
     if(str == "*min_size") { min_size = file.getdouble(); continue; }
     if(str == "*max_size") { max_size = file.getdouble(); continue; }
     if(str == "*nb_iter_remeshing") { nb_iter = file.getint(); continue; }
     if(str == "*format") { format = file.getSTRING(); continue; }
     if(str == "*quadratic_input_mesh") { from_quad = 1; continue; }
     if(str == "*remesh_after_input") { import_remesh = 1; continue; }
     if(str == "*fuse_nodes_during_remeshing") { if_fuse_import = 1; continue; }
     if(str == "*volume_remeshing_only") { if_ghs_only = 1; continue; }
     if(str == "*hotspot_number") { hnumber = file.getint(); continue; }
     if(str == "*hotspot_zone_radius") { hradius  = file.getdouble(); continue; }
     if(str == "*crack_surface_id") { crack_id  = file.getint(); continue; }
     if(str == "*crack_center") {
        center.resize(3); 
        center = 0.0;
        for(j=0;j<3;j++) {
           d = file.getdouble();
           if(!file.ok) { file.back(); break; }
           center[j] = d; 
        }
        continue;
     }
     if(str == "*crack_normal") {
        normal.resize(3); 
        normal = 0.0;
        for(j=0;j<3;j++) {
           d = file.getdouble();
           if(!file.ok) { file.back(); break; }
           normal[j] = d; 
        }
        continue;
     }
     if(str == "*crack_radius") { ra = file.getdouble(); continue; }
     if(str == "*ellipse") { if_ellipse = 1; continue; }
     if(str == "*orthodir_radius") { rb = file.getdouble(); continue; }
     if(str == "*ellipse_direction") {
        dir.resize(3); 
        dir = 0.0;
        for(j=0;j<3;j++) {
           d = file.getdouble();
           if(!file.ok) { file.back(); break; }
           dir[j] = d; 
        }
        continue;
     }
     if(str == "*elset_names") {
        elset_names = "";
        for(j=0;j>=0;j++) {
           str = file.getSTRING();
           if(!file.ok) break;
           if(str.start_with("*")) { file.back(); break; }
           elset_names = elset_names + " " + str;
        }
        if((format=="abaqus_templated") || (format=="samcef_templated")) toupper(elset_names);
        continue;
     }
     if(str == "*faset_names") {
        faset_names = "";
        for(j=0;j>=0;j++) {
           str = file.getSTRING();
           if(!file.ok) break;
           if(str.start_with("*")) { file.back(); break; }
           faset_names = faset_names + " " + str;
        }
        if((format=="abaqus_templated") || (format=="samcef_templated")) toupper(faset_names);
        continue;
     }
     if(str == "*geom_names") {
        geom_names = "";
        for(j=0;j>=0;j++) {
           str = file.getSTRING();
           if(!file.ok) break;
           if(str.start_with("*")) { file.back(); break; }
           geom_names = geom_names + " " + str;
        }
        continue;
     }
     if(str == "*liset_names") {
        liset_names = "";
        for(j=0;j>=0;j++) {
           str = file.getSTRING();
           if(!file.ok) break;
           if(str.start_with("*")) { file.back(); break; }
           liset_names = liset_names + " " + str;
        }
        continue;
     }
     if(str == "*ridge_names") {
        ridge_names = "";
        for(j=0;j>=0;j++) {
           str = file.getSTRING();
           if(!file.ok) break;
           if(str.start_with("*")) { file.back(); break; }
           ridge_names = ridge_names + " " + str;
        }
        continue;
     }
     if(str == "*nset_names") {
        nset_names = "";
        for(j=0;j>=0;j++) {
           str = file.getSTRING();
           if(!file.ok) break;
           if(str.start_with("*")) { file.back(); break; }
           nset_names = nset_names + " " + str;
        }
        if((format=="abaqus_templated") || (format=="samcef_templated")) toupper(nset_names);
        continue;
     }
     if(str == "*elset_radius") { elset_radius = file.getdouble(); continue; }
     if(str == "*crack_surface_from_file") { surf_mesh = file.getSTRING(); continue; }
     if(str == "*2D") { if_2D=1; continue; }
     if(str == "*thickness") {
        j = file.getint();
        if(!file.ok || j<=0) { file.back(); break; }
        thickness.resize(j); thickness = 0.0;
        for(j=0;j<!thickness;j++) thickness[j] = file.getdouble();
        continue;
     }
     if(str == "*extract_elset") { if_must_define_elset = 1; continue; }
     if(str == "*frozen_elset") { if_moving_elset = 0; continue; }
     if(str == "*dynamic_elset") { if_growing_elset = 0; continue; }
     if(str == "*quadratic_output_mesh") { if_quad = 1; continue; }
     if(str == "*smooth_propag") { smooth_propag = file.getint(); continue; }
     if(str == "*if_remove_ext_propag") { if_remove_ext_propag = 1; continue; }
     if(str == "*if_dGda") { if_dGda = 1; continue; }
     if(str == "*remove_ext_hexa") { remove_ext_hexa = file.getint(); continue; }
     if(str == "*torus_with_hexa") { if_hexa = 1; continue; }
     if(str == "*nb_hexa") { nb_hexa = file.getint(); continue; }
     if(str == "*th_hexa") { th_hexa = file.getint(); continue; }
     if(str == "*nc_hexa") { nc_hexa = file.getint(); continue; }
     if(str == "*dr_hexa") { dr_hexa = file.getdouble(); continue; }
     if(str == "*prog_hexa") { prog_hexa = file.getdouble(); continue; }
     if(str == "*quadratic_options") { quad_opt = file.getint(); continue; }
     if(str == "*no_pyramid_layer") { if_pyra = 0; continue; }
     if(str == "*meshcleaner") { if_meshcleaner = 1; continue; }
     if(str == "*no_contact_correction") { if_contact_correction = 0; continue; }
     if(str == "*no_mpc_for_contact") { if_add_mpc_for_contact = 0; continue; }
     if(str == "*suppress_old_results") { if_suppress_old_res = 1; continue; }
     if(str == "*no_quarter_nodes") { if_barsoum = 0; continue; }
     if(str == "*has_quarter_nodes") { if_barsoum = 1; continue; }
     if(str == "*set_reduced") { set_reduced = 1; continue; }
     if(str == "*refine_before_insert") { if_must_refine = 1; continue; }
     if(str == "*czm") { if_czm = 1; continue; }
     if(str == "*keep") { if_keep = 1; continue; }
     if(str == "*nb_front_nodes") { nb_fnodes = file.getint(); continue; }
     if(str == "*CTOA_distance") { CTOA_distance = file.getdouble(); continue; }
     if(str == "*compute_SIF") { if_K = 1; continue; }
     if(str == "*compute_CTOA") { if_CTOA = 1; continue; }
     if(str == "*sig_mises_max") { sigy = file.getdouble(); continue; }
     if(str == "*interaction_integral") { if_Ki = 1; continue; }
     if(str == "*maximal_radius") { rmax = file.getdouble(); continue; }
     if(str == "*gth_radius") { gth_radius = file.getdouble(); continue; }
     if(str == "*mpa_sqrt_m_correction") { if_mpa_m = 1; continue; }
     if(str == "*outplane_propagation") { if_Gmax = 1; continue; }
     if(str == "*Dwpe_integral") { if_Dwpe = 1; continue; }
     if(str == "*Dislocation_mode") { if_dislo = 1; continue; }
     if(str == "*domain_decomposition") { nb_dd = file.getint(); continue; }
     if(str == "*exclude_both_ends") { if_exclude_BE = file.getint(); continue; }
     if(str == "*smooth_open_front") { if_ebe=1; continue; }
     if(str == "*lips_contact") { if_contact = 1; continue; }
     if(str == "*contact_file") { contact_cmds = file.getSTRING(); continue; }
     if(str == "*max_advance") { max_h = file.getdouble(); continue; }
     if(str == "*front_ini_length") { lip_factor = file.getdouble(); continue; }
     if(str == "*nb_output_points") { nb_pt = file.getint(); continue; }
     if(str == "*nb_cycles") { nb_cycles = file.getint(); continue; }
     if(str == "*fatigue_cycle") {
        fatigue_Ti = file.getdouble();
        fatigue_DT = file.getdouble();
        continue;
     }
     if(str == "*ductile_sim_time") {
        ductile_Tt = file.getdouble();
        ductile_DT = file.getdouble();
        continue;
     }
     if(str == "*paris_law") {
        // for compatibility with old syntax
        pC = file.getdouble();
        pm = file.getdouble();
        paris_DN = file.getdouble();
        propag_model = "paris_std";
        propag_mat_file = "paris_std.mat";
        out.open(propag_mat_file,ios::out);
        out.setf(ios::scientific);
        out<<"C "<<pC<<endl;
        out<<"m "<<pm<<endl;
        out.close();
        continue;
     }
     if(str == "*propag_model")    { propag_model = file.getSTRING(); continue; }
     if(str == "*propag_mat_file") { propag_mat_file = file.getSTRING(); continue; }
     if(str == "*propag_script")   { propag_script = file.getSTRING(); continue; }
     if(str == "*propag_filter")   { 
        filter_type = file.getSTRING(); 
        str = file.getSTRING();
        if(str.start_with("*")) file.back();
        else filter_inp = str;
        continue; 
     }
     if(str == "*fact_nc") { fact_nc = file.getdouble(); continue; }
     if(str == "*mat_file") {
        mat_file = file.getSTRING();
        continue;
     }
     if(str == "*scale_refinement") { if_lip_factor = 1; continue; }
     if(str == "*transfer_state") { if_transfert = 1; continue; }
     if(str == "*cracked_elset") { elset_name = file.getSTRING(); continue; }
     if(str == "*fe_command") { 
        fe_command = "";
        for(j=0;j>=0;j++) {
           str = file.getSTRING();
           if(!file.ok) break;
           if(str.start_with("*")) { file.back(); break; }
           fe_command = fe_command + " " + str;
        }
        continue; 
     }
     if(str == "*qsub_file_name") { qsub_file_name = file.getSTRING(); continue;}
     if(str == "*elset_to_cut") { elset_to_cut = file.getSTRING(); continue;}
     if(str == "*nb_element_layers") { nb_velem = file.getint(); continue; }
     if(str == "*constant_density") { constant_density = file.getdouble(); continue; }
     if(str == "*max_kink_angle") { max_kink_angle = file.getdouble(); continue; }
     if(str == "*filtering") { filter_tol = file.getdouble(); continue; }
     if(str == "*grid_max") { grid_max = file.getdouble(); continue; }
     if(str == "*lip_fuse") { lip_tol = file.getdouble(); continue; }
     if(str == "*normal_length") { n_length = file.getdouble(); continue; }
     if(str == "*extern_step") { ext_dist = file.getdouble(); continue; }
     if(str == "*max_fronts") { nb_fronts = file.getint(); continue; }
     if(str == "*dont_check_ext_nodes") { if_ext = 0; continue; }
     if(str == "*power_func_coef") {power_func_coef = file.getdouble(); continue; }
     if(str == "*fuse_length") {fuse_length = file.getdouble(); continue; }
     if(str == "*max_quality") { max_quality = file.getdouble(); continue; }
     if(str == "*quality_threshold") { quality_threshold = file.getdouble(); continue; }
     if(user_extention*read_new_format_extention(str,file)) { continue; }
     else {
        ERROR("\nInvalid option: "+str+" in zcrack.dat file\n");
        return(2);
     }
  }

  if(if_ebe * nb_fnodes<0) nb_fnodes = -nb_fnodes;
  zcpost_file=cracked_name+"_GPP_PROPAG[1:1:1].ZCPOST";

  return(0);
}

int write_data()
{
  int i;
  double dt;
  Zfstream file;

  if(is_ductile){
    write_data_ductile(); 
    return(0);
  }

  file.open(datafile,ios::out);
  file.setf(ios::scientific);
  file<<"%-----------------------------------------------------------  "<<endl;
  file<<"% ZCRACKS data file                                        | "<<endl;
  file<<"%-----------------------------------------------------------  "<<endl;
  file<<endl;
  file<<"% General options"<<endl;
  file<<endl;
  if(!editor) file<<"*editor "<<editor<<endl;
  if(smp>1)  file<<"*smp "<<smp<<endl;
  if(nb_dd>1)  file<<"*domain_decomposition "<<nb_dd<<endl;
  if(!sane_name)  file<<"*sane_name "<<sane_name<<endl;
  if(!crack_name) file<<"*crack_name "<<crack_name<<endl;
  if(!cracked_name) file<<"*cracked_name "<<cracked_name<<endl;
  if(arch==0) file<<"*32_bits"<<endl;
  if(!yams_options) file<<"*yams_options "<<yams_options<<endl;
  if(if_var_refine) file<<"*curvature_refine"<<endl;
  if(if_surface_refine) file<<"*surface_refine"<<endl;
  file<<"*gradation "<<gradation<<endl;
  file<<"*min_size "<<min_size<<endl;
  file<<"*max_size "<<max_size<<endl;
  file<<"*nb_iter_remeshing "<<nb_iter<<endl;
  if(MedVersion!="") file<<"*MedVersion "<<MedVersion<<";"<<endl;
  

  file<<endl;
  file<<"% Import options"<<endl;
  file<<endl;
  if(!format) file<<"*format "<<format<<endl;
  if(from_quad) file<<"*quadratic_input_mesh"<<endl;
  if(import_remesh) file<<"*remesh_after_input"<<endl;
  if(if_fuse_import) file<<"*fuse_nodes_during_remeshing"<<endl;
  if(if_ghs_only) file<<"*volume_remeshing_only"<<endl;
  file<<"*hotspot_number "<<hnumber<<endl;
  file<<"*hotspot_zone_radius "<<hradius<<endl;

  file<<endl;
  file<<"% Cracks options"<<endl;
  file<<endl;
  file<<"*crack_surface_id "<<crack_id<<endl;
  file<<"*crack_center"; 
  for(i=0;i<!center;i++) file<<" "<<center[i]; file<<endl;
  file<<"*crack_normal"; 
  for(i=0;i<!normal;i++) file<<" "<<normal[i]; file<<endl;
  file<<"*crack_radius "<<ra<<endl;
  if(if_ellipse)  {
     file<<"*ellipse"<<endl;
     file<<"*orthodir_radius "<<rb<<endl;
     file<<"*ellipse_direction";
     for(i=0;i<!dir;i++) file<<" "<<dir[i]; file<<endl;
  }

  if(!surf_mesh) file<<"*crack_surface_from_file "<<surf_mesh<<endl;

  file<<endl;
  file<<"% Insertion options"<<endl;
  file<<endl;
  if(!elset_names){
     if((format=="abaqus_templated") || (format=="samcef_templated")){ toupper(elset_names); }
     file<<"*elset_names "<<elset_names<<endl;
  }
  if(!faset_names) {
     if((format=="abaqus_templated") || (format=="samcef_templated")){ toupper(faset_names); }
     file<<"*faset_names "<<faset_names<<endl;
  }
  if(!geom_names)  file<<"*geom_names "<<geom_names<<endl;
  if(!liset_names) file<<"*liset_names "<<liset_names<<endl;
  if(!ridge_names) file<<"*ridge_names "<<ridge_names<<endl;
  if(!nset_names) {
     if((format=="abaqus_templated") || (format=="samcef_templated")){ toupper(nset_names); }
     file<<"*nset_names "<<nset_names<<endl;
  }
  if(!temperature_name) file<<"*temperature_name "<<temperature_name<<endl;
  file<<"*elset_radius "<<elset_radius<<endl;
  if(if_2D) file<<"*2D"<<endl;
  if(!thickness) {
     file<<"*thickness "<<!thickness;
     for(i=0;i<!thickness;i++) file<<" "<<thickness[i]; file<<endl;
  }
  if(if_must_define_elset) file<<"*extract_elset"<<endl;
  if(!if_moving_elset) file<<"*frozen_elset"<<endl;
  if(!if_growing_elset) file<<"*dynamic_elset"<<endl;
  if(if_quad) file<<"*quadratic_output_mesh"<<endl;

  if(smooth_propag>0) file<<"*smooth_propag "<<smooth_propag<<endl;
  if(if_remove_ext_propag) file<<"*if_remove_ext_propag"<<endl;
  if(if_dGda) file<<"*if_dGda"<<endl;
  if(remove_ext_hexa>0) file<<"*remove_ext_hexa "<<remove_ext_hexa<<endl;

  if(if_hexa) file<<"*torus_with_hexa"<<endl;
  file<<"*nb_hexa "<<nb_hexa<<endl;
  file<<"*th_hexa "<<th_hexa<<endl;
  file<<"*nc_hexa "<<nc_hexa<<endl;
  file<<"*dr_hexa "<<dr_hexa<<endl;
  file<<"*prog_hexa "<<prog_hexa<<endl;
  file<<"*quadratic_options "<<quad_opt<<endl;
  if(!if_pyra) file<<"*no_pyramid_layer"<<endl;
  if(if_meshcleaner) file<<"*meshcleaner"<<endl;
  if(!if_contact_correction) file<<"*no_contact_correction"<<endl;
  if(!if_add_mpc_for_contact) file<<"*no_mpc_for_contact"<<endl;
  if(!if_barsoum) file<<"*no_quarter_nodes"<<endl;
  if(if_barsoum) file<<"*has_quarter_nodes"<<endl;
  if(if_must_refine) file<<"*refine_before_insert"<<endl;
  if(if_czm) file<<"*czm"<<endl;
  if(if_keep) file<<"*keep"<<endl;

  file<<endl;
  file<<"% SIF options"<<endl;
  file<<endl;
  file<<"*nb_front_nodes "<<nb_fnodes<<endl;
  if(sigy>0.) file<<"*sig_mises_max "<< sigy<<endl;
  if(rmax!=0.) file<<"*maximal_radius "<< rmax<<endl;
  if(gth_radius>0.) file<<"*gth_radius "<< gth_radius<<endl;
  if(if_K) file<<"*compute_SIF"<<endl;
  if(if_Ki) file<<"*interaction_integral"<<endl;
  if(if_mpa_m) file<<"*mpa_sqrt_m_correction"<<endl;
  if(if_Gmax) file<<"*outplane_propagation"<<endl;
  if(if_Dwpe) file<<"*Dwpe_integral"<<endl;
  if(if_dislo) file<<"*Dislocation_mode"<<endl;
  //file<<"*exclude_both_ends "<<if_exclude_BE<<endl;
  if(if_ebe) file<<"*smooth_open_front"<<endl;
  if(if_contact) file<<"*lips_contact"<<endl;
  if(!contact_cmds) file<<"*contact_file "<<contact_cmds<<endl;

  file<<endl;
  file<<"% Propagation options"<<endl;
  file<<endl;
  file<<"*max_advance "<<max_h<<endl;
  file<<"*front_ini_length "<<lip_factor<<endl;
  file<<"*nb_output_points "<<nb_pt<<endl;
  file<<"*nb_cycles "<< nb_cycles <<endl;
  file<<"*fatigue_cycle "<<fatigue_Ti<<" "<<fatigue_DT<<endl; 
  file<<"*propag_model "<<propag_model<<endl;
  if(!propag_mat_file)  file<<"*propag_mat_file "<<propag_mat_file<<endl;
  if(!propag_script)  file<<"*propag_script "<<propag_script<<endl;
//  if(fact_nc>1.0) file<<"*fact_nc "<<fact_nc<<endl;
  if(filter_type != "no_filter")  {
     file<<"*propag_filter "<<filter_type;
     if(!filter_inp) file<<" "<<filter_inp;
     file<<endl;
  }
  file<<"*fact_nc "<<fact_nc<<endl;
  if(if_lip_factor) file<<"*scale_refinement"<<endl;
  if(if_transfert) file<<"*transfer_state"<<endl;
  if(!mat_file) file<<"*mat_file "<<mat_file<<endl;

  file<<endl;
  file<<"% Advanced options"<<endl;
  file<<endl;
  if(elset_name != "AUTO") file<<"*cracked_elset "<<elset_name<<endl;
  if(!fe_command) file<<"*fe_command "<<fe_command<<endl;
  if(!qsub_file_name) file<<"*qsub_file_name "<<qsub_file_name<<endl;
  if(!elset_to_cut) file<<"*elset_to_cut "<<elset_to_cut<<endl;
  file<<"*nb_element_layers "<<nb_velem<<endl;
  file<<"*constant_density "<<constant_density<<endl;
  file<<"*max_kink_angle "<<max_kink_angle<<endl;
  file<<"*filtering "<<filter_tol<<endl; // advanced
  if(!new_version) file<<"*grid_max "<<grid_max<<endl; // advanced
  file<<"*lip_fuse "<<lip_tol<<endl; // advanced
  file<<"*normal_length "<<n_length<<endl; // advanced
  file<<"*extern_step "<<ext_dist<<endl; // advanced
  file<<"*max_fronts "<<nb_fronts<<endl;
  if(!if_ext) file<<"*dont_check_ext_nodes"<<endl;
  file<<"*max_quality "<<max_quality<<endl;
  file<<"*quality_threshold "<<quality_threshold<<endl;
  file<<"*power_func_coef "<<power_func_coef<<endl;
  file<<"*fuse_length "<<fuse_length<<endl;
  
  
  // Set exclude BE associated vars
  /*
  if(if_exclude_BE<0) {
    if_ebe=1;
    nb_ext=-if_exclude_BE-1;
  } else {
    if_ebe=0;
    nb_ext=if_exclude_BE;
  }
  */

  if(user_extention) write_data_extention(file);

  file.close();
  return(0);
}

int build_dialog()
{
  // global dialog box
  // Various tabs:
  // Global parameters (ie files names, etc)
  // Remeshing parameters
  // Import/export
  // Build cracks
  // Insert cracks
  // Compute SIF
  // Compute propag

  int i, iformat;
  global STRING dname;
  ARRAY<STRING> strings,options;
  ARRAY<int>    defaults;
  STRING        field;
    

/*
  if(if_exclude_BE<0) {
    if_ebe=1;
    nb_ext=-if_exclude_BE-1;
  } else {
    if_ebe=0;
    nb_ext=if_exclude_BE;
  }
*/

  graphics_app.add_dialog(dname,false);
  graphics_app.add_label(dname,"Conform 3D crack propagation toolbox for finite elements fatigue analysis XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX","Conform 3D crack propagation toolbox");

  // Add tabs
  graphics_app.add_tabs_field(dname,"Tabs");
  graphics_app.set_add_target("Tabs");

  graphics_app.add_container(dname,"General");
//  graphics_app.add_container(dname,"Remeshing");
  graphics_app.add_container(dname,"Import/Export/Hotspots");
  graphics_app.add_container(dname,"Cracks");
  graphics_app.add_container(dname,"Insertion");
  graphics_app.add_container(dname,"SIF");
  graphics_app.add_container(dname,"Propagation");
  graphics_app.add_container(dname,"Advanced");
  if(user_extention){
    graphics_app.add_container(dname,"User Extention");
  }

  // Global informations
  graphics_app.set_add_target("General");
  graphics_app.piece_command(dname,"General","set number_of_items 3");
  graphics_app.set_grow_main(2); graphics_app.set_grow_other(2);

  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","Environment");
  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");
  if(only_templated) {
     graphics_app.add_label(dname,"","");
     graphics_app.add_label(dname,"","");
     graphics_app.add_label(dname,"","");
     graphics_app.add_file_selection(dname,"Sane name",sane_name);
  }
  else  graphics_app.add_text_field(dname,"Datafile",datafile);
  graphics_app.add_text_field(dname,"Editor",editor);
  graphics_app.add_text_field(dname,"#CPU for SMP",itoa(smp));

  if(!only_templated) {
    graphics_app.add_label(dname,"","");
    graphics_app.add_label(dname,"","");
    graphics_app.add_label(dname,"","");
    graphics_app.add_label(dname,"File names","File names (without extension)");
    graphics_app.add_label(dname,"","");
    graphics_app.add_label(dname,"","");
    graphics_app.add_file_selection(dname,"Sane name",sane_name);
    graphics_app.add_text_field(dname,"Crack name",crack_name);
    graphics_app.add_text_field(dname,"Cracked name",cracked_name);
  }

  graphics_app.set_grow_main(2); graphics_app.set_grow_other(2);

  // Remeshing
//  graphics_app.set_add_target("Remeshing");
//  graphics_app.set_grow_main(1); graphics_app.set_grow_other(2);

  graphics_app.add_label(dname,"",""); 
  graphics_app.add_label(dname,"",""); 
  graphics_app.add_label(dname,"",""); 
  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"Remeshing process parameters","Remeshing process parameters");
  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");
  if(only_templated) {
    graphics_app.add_label(dname,"","");
    graphics_app.add_label(dname,"","");
    graphics_app.add_label(dname,"","");
  }
  /*
  graphics_app.add_label(dname,"","Meshers version");
  options.resize(2);
  options[0]="32 bits";
  options[1]="64 bits";
  graphics_app.add_combo_group(dname,"Arch",options,arch);
  graphics_app.add_label(dname,"",""); 
  */

  options.resize(1);  options[0] = "plane 2D";
  defaults.resize(1); defaults[0]=if_2D;
  if(!only_templated) {
     graphics_app.add_text_field(dname,"Yams options",yams_options);
     graphics_app.add_check_group(dname,"plane2D",options,defaults);
     graphics_app.add_text_field(dname,"Gradation",dtoa(gradation));
     graphics_app.add_text_field(dname,"Min size",dtoa(min_size));
     graphics_app.add_text_field(dname,"Max size",dtoa(max_size));
     graphics_app.add_text_field(dname,"Iterations",itoa(nb_iter));
  }
  else {
     graphics_app.add_text_field(dname,"Min size",dtoa(min_size));
     graphics_app.add_text_field(dname,"Max size",dtoa(max_size));
     graphics_app.add_text_field(dname,"Gradation",dtoa(gradation));
     graphics_app.add_check_group(dname,"plane2D",options,defaults);
     graphics_app.add_label(dname,"","");
     graphics_app.add_label(dname,"","");
  }

  graphics_app.add_label(dname,"",""); 
  graphics_app.add_label(dname,"",""); 
  graphics_app.add_label(dname,"","");

  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");
  graphics_app.add_command_button(dname,"Save","Save");
  graphics_app.add_command_button(dname,"Open","Open");
  graphics_app.add_command_button(dname,"Quit","Quit");
  graphics_app.set_grow_main(2); graphics_app.set_grow_other(2);

  // Import/export
  graphics_app.set_add_target("Import/Export/Hotspots");
  if(only_templated){
    graphics_app.piece_command(dname,"Import/Export/Hotspots","set number_of_items 4");
    graphics_app.add_label(dname,"","");
    graphics_app.add_label(dname,"","");
    graphics_app.add_label(dname,"","");
    graphics_app.add_label(dname,"","");
  }
  else{
    graphics_app.piece_command(dname,"Import/Export/Hotspots","set number_of_items 3");
    graphics_app.add_label(dname,"","");
    graphics_app.add_label(dname,"","");
    graphics_app.add_label(dname,"","");
  }
  graphics_app.set_grow_main(1); graphics_app.set_grow_other(2);

  //graphics_app.add_text_field(dname,"Import format",format);
  if(!get_sel(import_formats,format,iformat)) {
     ERROR("\nUnknown import format: "+format+"\n");
     iformat = 0;
  }
  options.resize(!import_formats);
  for(i=0;i<!import_formats;i++) options[i] = import_formats[i];
  graphics_app.add_label(dname,"","Import format");
  graphics_app.add_combo_group(dname,"Format",options,iformat);

  if(only_templated) {
    options.resize(1);
    options[0] = "Quadratic input mesh";
    defaults.resize(1); defaults[0] = from_quad;
    graphics_app.add_label(dname,"","");
  } else {
    graphics_app.add_label(dname,"","");
    graphics_app.add_text_field(dname,"Scale factor",dtoa(scale));
    graphics_app.add_text_field(dname,"Get surfaces",dtoa(angle_criterion));
    graphics_app.add_label(dname,"","");

    options.resize(5);
    options[0] = "Quadratic input mesh"; options[1] = "Remesh after input";
    options[2] = "Fuse nodes during remeshing"; options[3] = "Surface input mesh";
    options[4] = "Volume remeshing only";
    defaults.resize(5); defaults[0] = from_quad;  defaults[1] = import_remesh;
    defaults[2] = if_fuse_import ; defaults[3] = if_2D ; defaults[4] = if_ghs_only;
  }
  graphics_app.set_grow_main(1); graphics_app.set_grow_other(2);
  graphics_app.add_check_group(dname,"Quadratic import",options,defaults);
  if(!only_templated) {
    graphics_app.add_label(dname,"","");
    graphics_app.add_label(dname,"","");
  }
  else {
    graphics_app.add_label(dname,"","");
    graphics_app.add_label(dname,"","");
    graphics_app.add_label(dname,"","");
    graphics_app.add_label(dname,"","");
  }
  graphics_app.add_command_button(dname,"Import","import_mesh");
  if(!only_templated) {
    graphics_app.add_command_button(dname,"Export","export_mesh");
  }
  graphics_app.add_command_button(dname,"Check import","check_import");
  graphics_app.add_command_button(dname,"Medit","view_vol_mesh");
  graphics_app.add_command_button(dname,"Zmaster","Zmaster_vol_mesh");

  if(only_templated) {
    graphics_app.add_label(dname,"","");
    graphics_app.add_label(dname,"","");
    graphics_app.add_label(dname,"","");
    graphics_app.add_label(dname,"","");
  }else{
    graphics_app.add_label(dname,"","");
    graphics_app.add_label(dname,"","");
    graphics_app.add_label(dname,"","");
  }

  if(!only_templated) {
    graphics_app.add_command_button(dname,"ParaView","PV_vol_mesh");
    graphics_app.add_label(dname,"","Hotspots detection (based on a von");
    graphics_app.add_label(dname,"","Mises max criterion)");
    graphics_app.add_label(dname,"",""); // Warning: modify cracks data
    graphics_app.add_text_field(dname,"Number",itoa(hnumber));
    graphics_app.add_text_field(dname,"Zone radius",dtoa(hradius));
    graphics_app.add_text_field(dname,"Init radius",dtoa(ra));
    graphics_app.add_command_button(dname,"Generate .inp","update_HS");
    graphics_app.add_command_button(dname,"Edit .inp","edit_HS");
    graphics_app.add_command_button(dname,"Compute","compute_HS");
    graphics_app.add_command_button(dname,"PostProcess","compute_PPHS");
    graphics_app.add_command_button(dname,"Zmaster","view_HS");
    graphics_app.add_command_button(dname,"ParaView","pv_HS");
  }

  if(only_templated){
    graphics_app.add_label(dname,"","");
    graphics_app.add_label(dname,"","");
    graphics_app.add_label(dname,"","");
    graphics_app.add_label(dname,"","");
  }
  graphics_app.add_label(dname,"","Z8 database");
  graphics_app.add_label(dname,"","(merge results databases)");
  graphics_app.add_label(dname,"","");
  if(only_templated){
    graphics_app.add_label(dname,"","");
    graphics_app.add_label(dname,"","");
    graphics_app.add_label(dname,"","");
    graphics_app.add_label(dname,"","");
    graphics_app.add_label(dname,"","");
  }
  graphics_app.add_command_button(dname,"Generate .inp","update_Z8");
  graphics_app.add_command_button(dname,"Edit .inp","edit_Z8");
  graphics_app.add_command_button(dname,"Export Z8","export_Z8");
  graphics_app.add_command_button(dname,"Zmaster","zmaster_Z8");
  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");

  graphics_app.set_grow_main(2); graphics_app.set_grow_other(2);

  // Build cracks
  graphics_app.set_add_target("Cracks");
  graphics_app.piece_command(dname,"Cracks","set number_of_items 3");
  graphics_app.set_grow_main(1); graphics_app.set_grow_other(2);
  graphics_app.add_text_field(dname,"Surface id",itoa(crack_id));
  graphics_app.add_command_button(dname,"Load","load_surface");
  graphics_app.add_command_button(dname,"Zmaster struct","Zmaster_vol_mesh");

  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");

  graphics_app.add_label(dname,"Crack description","Penny shape crack");
  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");
  field=dtoa(center[0])+" "+dtoa(center[1])+" "+dtoa(center[2]);
  graphics_app.add_text_field(dname,"Center",field);
  field=dtoa(normal[0])+" "+dtoa(normal[1])+" "+dtoa(normal[2]);
  graphics_app.add_text_field(dname,"Normal",field);
  graphics_app.add_text_field(dname,"Radius",dtoa(ra));
  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"Crack description","Ellipse shape crack");
  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");

  if(only_templated) {
    options.resize(1);
    options[0] = "Ellipse";
    defaults.resize(1); defaults[0] = if_ellipse; 
  } else {
    options.resize(2);
    options[0] = "Ellipse";
    options[1] = "Mesh with CZM elements";
    defaults.resize(2); defaults[0] = if_ellipse; defaults[1] = if_czm; 
  }
  graphics_app.add_check_group(dname,"Ellipse",options,defaults);
  field=dtoa(dir[0])+" "+dtoa(dir[1])+" "+dtoa(dir[2]);
  graphics_app.add_text_field(dname,"Direction",field);
  graphics_app.add_text_field(dname,"Ortho/dir radius",dtoa(rb));

  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");

  graphics_app.add_label(dname,"Crack description","User defined crack shape");
  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");

  graphics_app.add_file_selection(dname,"Surface mesh",surf_mesh);
  graphics_app.add_command_button(dname,"Convert","convert_surface");

  if(!only_templated){
    graphics_app.add_text_field(dname,"Refine file",refinement_datafile);
  } else {
    graphics_app.add_label(dname,"","");
  }

  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");

  graphics_app.add_command_button(dname,"Run","do_mesh_crack");
  graphics_app.add_command_button(dname,"Run all","mesh_all_crack");
  graphics_app.add_label(dname,"","");
 
  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");

  if(only_templated){
    graphics_app.add_label(dname,"","Visualization");
    graphics_app.add_label(dname,"","");
    graphics_app.add_label(dname,"","");
  }
  graphics_app.add_command_button(dname,"Medit","view_surf_mesh");
  graphics_app.add_command_button(dname,"Zmaster","Zmaster_crack");
  if(!only_templated)
    graphics_app.add_command_button(dname,"ParaView","PV_crack");

  graphics_app.set_grow_main(2); graphics_app.set_grow_other(2);

  // Insert
  graphics_app.set_add_target("Insertion");
  graphics_app.piece_command(dname,"Insertion","set number_of_items 3");
  graphics_app.set_grow_main(1); graphics_app.set_grow_other(2);

  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");

  graphics_app.add_label(dname,"Sane structure description","Sets to keep during remeshing");
  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");
  graphics_app.add_text_field(dname,"Elsets",elset_names);
  graphics_app.add_text_field(dname,"Fasets",faset_names);
  graphics_app.add_text_field(dname,"Lisets",liset_names);
  graphics_app.add_text_field(dname,"Ridges",ridge_names);
  graphics_app.add_text_field(dname,"Nsets",nset_names);
  if((format=="abaqus_templated") || (format=="samcef_templated")) {
    toupper(faset_names);
    toupper(elset_names);
    toupper(nset_names);
  }

  graphics_app.add_text_field(dname,"Fixed Fasets",geom_names);

  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");    
  graphics_app.add_label(dname,"","Remeshing zone");
  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");
  // Thickness 2D problem
  if(only_templated) {
    graphics_app.add_text_field(dname,"Cracked elset",elset_name);
    graphics_app.add_text_field(dname,"Elset radius",dtoa(elset_radius));
    graphics_app.add_command_button(dname,"Mesh intersection","intersect_mesh");
  } else {
    graphics_app.add_text_field(dname,"Elset radius",dtoa(elset_radius));
    graphics_app.add_label(dname,"","");
    field=itoa(thickness.size());
    for(i=0;i<thickness.size();i++) {
      field=field+" "+dtoa(thickness[i]);
    }
    graphics_app.add_text_field(dname,"Thickness",field);
  }

  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","Remeshing options");
  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");
  options.resize(6);
  options[0] = "Must extract elset";
  options[1] = "Moving elset";
  options[2] = "Boundaries refine";
  options[3] = "Refine near surface";
  options[4] = "Refine before insert";
  options[5] = "Cohesive zone model";
  //options[6] = "Keep external mesh part";
  defaults.resize(6); 
  defaults[0]=if_must_define_elset; defaults[1]=if_moving_elset;
  defaults[2]=if_var_refine; defaults[3]=if_surface_refine;
  defaults[4]=if_must_refine; defaults[5]=if_czm; 
  //defaults[6]=if_keep;
  graphics_app.add_check_group(dname,"Must extract elset",options,defaults);

  //quad options
  graphics_app.add_container(dname,"insert_quad_options");
  graphics_app.set_add_target("insert_quad_options");

  options.resize(1); options[0] = "Quadratic mesh";
  defaults.resize(1); defaults[0]=if_quad;
  graphics_app.add_check_group(dname,"Quadratic options 1",options,defaults);
  graphics_app.add_command_button(dname,"Quad options","set_quad_params");

  graphics_app.set_add_target("Insertion");
  graphics_app.add_container(dname,"insert_hexa_options");
  graphics_app.set_add_target("insert_hexa_options");

  //hexa options
  options.resize(1); options[0] = "Activate hexa";
  defaults.resize(1); defaults[0]=if_hexa;
  graphics_app.add_check_group(dname,"Hexa torus options",options,defaults);
  graphics_app.add_command_button(dname,"Hexa options","set_hexa_params");
  
  graphics_app.set_add_target("Insertion");

  if(new_version) {
    //graphics_app.add_command_button(dname,"Refine","nice_refine");
    //graphics_app.add_command_button(dname,"Insert","nice_cut");
    //graphics_app.add_label(dname,"","");
  } else {
    graphics_app.add_command_button(dname,"Run refine","do_refine_mesh");
    graphics_app.add_command_button(dname,"Run cut","do_cut_mesh");
  }
  if(new_version) graphics_app.add_command_button(dname,"Insert","nice_cut");
  graphics_app.add_command_button(dname,"Medit","view_vol_mesh");
  graphics_app.add_command_button(dname,"Zmaster","Zmaster_cut_mesh");
  if(!only_templated){
    graphics_app.add_command_button(dname,"ParaView","PV_vol_mesh");
    graphics_app.add_command_button(dname,"Kill","kill_meshes");
    graphics_app.add_command_button(dname,"Lin/Quad","lin_quad");
  }
  if(!new_version) graphics_app.add_command_button(dname,"Auto cut","nice_cut");

  graphics_app.set_grow_main(2); graphics_app.set_grow_other(2);

  // SIF computation
  graphics_app.set_add_target("SIF");
  graphics_app.piece_command(dname,"SIF","set number_of_items 3");
  graphics_app.set_grow_main(1); graphics_app.set_grow_other(2);

  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","G-theta parameters");
  graphics_app.add_label(dname,""," (default branching direction");
  graphics_app.add_label(dname,""," is obtained by a vectorial Gmax)");
  graphics_app.add_text_field(dname,"Front nodes",itoa(nb_fnodes));
//  graphics_app.add_text_field(dname,"Gmax ang step",dtoa(hnumber));
//  graphics_app.add_text_field(dname,"Gmax ang err",dtoa(astep));
  graphics_app.add_text_field(dname,"Gth radius",dtoa(gth_radius));
  graphics_app.add_text_field(dname,"2nd radius",dtoa(rmax));
  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");

  graphics_app.add_label(dname,"","Gnuplot visualization");
  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");
  graphics_app.add_text_field(dname,"Front#",itoa(front_view));
  graphics_app.add_text_field(dname,"Temperature",temperature_name);
  graphics_app.add_text_field(dname,"Sigma Y",dtoa(sigy));

  options.resize(2);
  options[0] = "Compute SIF";
  options[1] = "-> MPa*sqrt(m)";
  defaults.resize(2); 
  defaults[0] = if_K; defaults[1] = if_mpa_m;
  graphics_app.add_check_group(dname,"Options_SIF_1",options,defaults);

  options.resize(2);
  options[0] = "Interaction integral";
  options[1] = "Outplane propagation";
  defaults.resize(2); 
  defaults[0] = if_Ki; defaults[1] = if_Gmax;
  graphics_app.add_check_group(dname,"Options_SIF_2",options,defaults);
  
  options.resize(2);
  options[0] = "Smoothing";
  options[1] = "Lips contact";
  defaults.resize(2); 
  defaults[0] = if_ebe; defaults[1] = if_contact;
  graphics_app.add_check_group(dname,"Options_SIF_3",options,defaults);

  graphics_app.add_file_selection(dname,"Contact special",contact_cmds);
  graphics_app.add_command_button(dname,"Get default","get_default_contact");
  graphics_app.add_command_button(dname,"Edit contact","edit_contact");

  graphics_app.add_command_button(dname,"Generate .inp","update_SIF");
  graphics_app.add_command_button(dname,"Edit .inp","edit_SIF");
  graphics_app.add_command_button(dname,"Compute","compute_SIF");
  if(only_templated){
    graphics_app.add_label(dname,"","");
    graphics_app.add_label(dname,"","");
    graphics_app.add_label(dname,"","");
    graphics_app.add_label(dname,"","Visualization");
    graphics_app.add_label(dname,"","");
    graphics_app.add_label(dname,"","");
  }
  graphics_app.add_command_button(dname,"Zmaster","view_SIF");
  if(!only_templated){
    graphics_app.add_command_button(dname,"ParaView","paraview_SIF");
  }
  graphics_app.add_command_button(dname,"Post-process","pp_SIF");
  graphics_app.add_command_button(dname,"G/SIF values","print_SIF");
  graphics_app.add_command_button(dname,"Plot G","plot_G");
  graphics_app.add_command_button(dname,"Plot SIF","plot_SIF");
  graphics_app.add_command_button(dname,"Plot Extra","plot_T");
  graphics_app.add_command_button(dname,"Plot Branching","plot_a");
  graphics_app.add_command_button(dname,"Plot Front","plot_front");
  graphics_app.add_command_button(dname,"Advanced Plot","advanced_plot");
  if(!only_templated){
    graphics_app.add_command_button(dname,"Kill SIF","kill_SIF");
  }

  graphics_app.set_grow_main(2); graphics_app.set_grow_other(2);

  // Propagation
  graphics_app.set_add_target("Propagation");
  graphics_app.piece_command(dname,"Propagation","set number_of_items 3");
  graphics_app.set_grow_main(1); graphics_app.set_grow_other(2);

  graphics_app.add_label(dname,"Propagation parameters","Geometric parameters");
  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");
  graphics_app.add_text_field(dname,"Max advance",dtoa(max_h));

  graphics_app.add_text_field(dname,"Front ini length",dtoa(lip_factor));

  graphics_app.add_text_field(dname,"#Output",itoa(nb_pt));

  graphics_app.add_label(dname,"Propagation input","Fatigue cycles");
  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");
  graphics_app.add_text_field(dname,"Initial time",dtoa(fatigue_Ti));
  graphics_app.add_text_field(dname,"Cycle DeltaT",dtoa(fatigue_DT));
  graphics_app.add_text_field(dname,"#Cycles",itoa(nb_cycles));

  graphics_app.add_label(dname,"","Propagation law");
  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");
  if(!get_sel(propag_models,propag_model,iformat)) {
     cout<<"\nUnknown propag model: "<<propag_model<<"\n"<<endl; cflush();
     iformat = 0;
  }
  options.resize(!propag_models);
  for(i=0;i<!propag_models;i++) options[i] = propag_models[i];
  graphics_app.add_combo_group(dname,"Propagation model",options,iformat);
  graphics_app.add_command_button(dname,"Set coefs","set_propag_coefs");
  graphics_app.add_command_button(dname,"Advanced propag","advanced_propag");

  graphics_app.add_label(dname,"","Propagation filter");
  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");
  options.resize(!propag_filters);
  for(i=0;i<!propag_filters;i++) options[i] = propag_filters[i];
  if(!get_sel(propag_filters,filter_type,iformat)) {
     cout<<"\nUnknown propag model: "<<propag_model<<"\n"<<endl; cflush();
     iformat = 0;
  }
  graphics_app.add_combo_group(dname,"Propagation filter",options,iformat);
  graphics_app.add_file_selection(dname,"Filter input file",filter_inp);
  graphics_app.add_command_button(dname,"Load filter","load_filter");

  options.resize(2); defaults.resize(2);
  options[0] = "Scale refinement";
  options[1] = "Transfer state";
  defaults[0] = if_lip_factor; defaults[1] = if_transfert; 
  graphics_app.add_check_group(dname,"Options_PROPAG",options,defaults);
  options.resize(2); defaults.resize(2);
  options[0] = "Remove ext propag";
  options[1] = "Compute dG/da";
  defaults[0]=if_remove_ext_propag;
  defaults[1]=if_dGda;
  graphics_app.add_check_group(dname,"Options_PROPAG2",options,defaults);
  graphics_app.add_text_field(dname,"Smooth propag\n\n\n",itoa(smooth_propag));
  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","Projection normal");
  graphics_app.add_file_selection(dname,"Transfer mat file",mat_file);
  graphics_app.add_text_field(dname,"View Front$",itoa(front_view));
  options.resize(5);
  options[0]="3D";
  options[1]="X";
  options[2]="Y";
  options[3]="Z";
  options[4]="custom";
  graphics_app.add_combo_group(dname,"Projection",options,front_plane);
 
  graphics_app.add_command_button(dname,"Generate .inp","update_PROPAG");
  graphics_app.add_command_button(dname,"Edit .inp","edit_PROPAG");
  graphics_app.add_command_button(dname,"Compute","compute_PROPAG");
  if(only_templated){
    graphics_app.add_label(dname,"","");
    graphics_app.add_label(dname,"","");
    graphics_app.add_label(dname,"","");
    graphics_app.add_label(dname,"","Visualization");
    graphics_app.add_label(dname,"","");
    graphics_app.add_label(dname,"","");
  }
  if(!only_templated) graphics_app.add_command_button(dname,"Medit","view_vol_mesh");
  graphics_app.add_command_button(dname,"Zmaster","view_PROPAG");
  if(!only_templated) graphics_app.add_command_button(dname,"ParaView","paraview_PROPAG");
  graphics_app.add_command_button(dname,"Propag data","print_PROPAG");
  graphics_app.add_command_button(dname,"Plot a(N)","plot_AN");
  graphics_app.add_command_button(dname,"Plot V(N)","plot_VN");
  graphics_app.add_command_button(dname,"Plot SIF(N)","plot_KN");
  graphics_app.add_command_button(dname,"Plot T(N)","plot__TN");
  graphics_app.add_command_button(dname,"Plot pos(N)","plot_PN");
  graphics_app.add_command_button(dname,"Plot V(DK)","plot_VDK");
  graphics_app.add_command_button(dname,"Plot SIF(a)","plot_Ka");



  if(!only_templated){
    graphics_app.add_command_button(dname,"Plot T(a)","plot__Ta");
    graphics_app.add_command_button(dname,"Kill PROPAG","kill_PROPAG");
    graphics_app.add_command_button(dname,"Plot Quality","plot_quality");
    graphics_app.add_command_button(dname,"Edit .plw","edit_PLW");
  }

  graphics_app.set_grow_main(2); graphics_app.set_grow_other(2);

  // Advanced parameters
  graphics_app.set_add_target("Advanced");
  graphics_app.piece_command(dname,"Advanced","set number_of_items 3");
  graphics_app.set_grow_main(1); graphics_app.set_grow_other(2);

  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");

  graphics_app.add_label(dname,"Advanced global parameters","Advanced global parameters");
  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");
  if(!only_templated){
    graphics_app.add_text_field(dname,"Debug mode",debug);
    graphics_app.add_label(dname,"","");
    graphics_app.add_label(dname,"","");
  }
  if(!only_templated) {
    graphics_app.add_text_field(dname,"Cracked elset",elset_name);
    graphics_app.add_label(dname,"","");
    graphics_app.add_label(dname,"","");
  }
  graphics_app.add_text_field(dname,"External FE command",fe_command);
  if(only_templated){
    graphics_app.add_text_field(dname,"Cracked name",cracked_name);
  } else {
    graphics_app.add_label(dname,"","");
  }
  graphics_app.add_label(dname,"","");
  graphics_app.add_text_field(dname,"Run using qsub",qsub_file_name);
  graphics_app.add_text_field(dname,"Only cut elset",elset_to_cut);
  graphics_app.add_label(dname,"","");

  if(!only_templated) {
    graphics_app.add_text_field(dname,"Cracked elset",elset_name);
    graphics_app.add_label(dname,"","");
    graphics_app.add_label(dname,"","");
    graphics_app.add_text_field(dname,"Remove /hexa ext",itoa(remove_ext_hexa));
    graphics_app.add_label(dname,"","");
    graphics_app.add_label(dname,"","");
  }
  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");
  
  if(!only_templated){
    graphics_app.add_label(dname,"Advanced crack parameters","Advanced crack parameters");
    graphics_app.add_label(dname,"","");
    graphics_app.add_label(dname,"","");
    graphics_app.add_text_field(dname,"Element layers",itoa(nb_velem));
    graphics_app.add_text_field(dname,"Ref ext",itoa(nb_ext));
    graphics_app.add_text_field(dname,"Filtering",dtoa(filter_tol));
    if(!new_version) graphics_app.add_text_field(dname,"Grid max",dtoa(grid_max));
    graphics_app.add_text_field(dname,"Lip fuse",dtoa(lip_tol));
    graphics_app.add_text_field(dname,"Normal length",dtoa(n_length));
    graphics_app.add_text_field(dname,"XFEM radius",dtoa(TIP_radius));
    graphics_app.add_text_field(dname,"Extern step",dtoa(ext_dist));
    graphics_app.add_text_field(dname,"Max front",itoa(nb_fronts));
    if(new_version) {
     graphics_app.add_label(dname,"","");
    }
  } else {
    graphics_app.add_label(dname,"Advanced crack parameters","Advanced G-theta parameters");
    graphics_app.add_label(dname,"","");
    graphics_app.add_label(dname,"","");
    graphics_app.add_text_field(dname,"Element layers",itoa(nb_velem));
    graphics_app.add_text_field(dname,"Dynamic density",dtoa(constant_density));
    graphics_app.add_label(dname,"","");
    graphics_app.add_text_field(dname,"Max kink angle",dtoa(max_kink_angle));
    graphics_app.add_text_field(dname,"Remove /hexa ext",itoa(remove_ext_hexa));
    graphics_app.add_label(dname,"","");
  }
  options.resize(1);
  options[0] = "Apply contact correction";
  defaults.resize(1);
  defaults[0] = if_contact_correction;
  graphics_app.add_check_group(dname,"Options_gtheta_1",options,defaults);
  //graphics_app.add_label(dname,"","");
  options.resize(1);
  options[0] = "Add MPC for contact";
  defaults.resize(1);
  defaults[0] = if_add_mpc_for_contact;
  graphics_app.add_check_group(dname,"Options_gtheta_2",options,defaults);
  graphics_app.add_label(dname,"","");

  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"Advanced remeshing parameters","Advanced remeshing parameters");
  graphics_app.add_label(dname,"","");
  graphics_app.add_label(dname,"","");

  if(only_templated) {
     graphics_app.add_text_field(dname,"Yams options",yams_options);
     graphics_app.add_text_field(dname,"Iterations",itoa(nb_iter));
     graphics_app.add_label(dname,"","");
  }
  graphics_app.add_text_field(dname,"Quality",dtoa(max_quality));
  graphics_app.add_text_field(dname,"Power function coef",dtoa(power_func_coef));
  graphics_app.add_label(dname,"","");
  graphics_app.add_text_field(dname,"Fuse length",dtoa(fuse_length));
  graphics_app.add_text_field(dname,"Domain decomposition",itoa(nb_dd));
  graphics_app.add_label(dname,"","");
  
  // New options line (coalescing)
  if(only_templated) {
    graphics_app.add_label(dname,"","");
    graphics_app.add_label(dname,"","");
    graphics_app.add_label(dname,"","");
  }

  options.resize(3);
  options[0] = "Extend front on surface";
  options[1] = "Remesh fronts separately";
  options[2] = "Growing elset";
  defaults.resize(3);
  defaults[0] = if_ext; defaults[1] =  if_separate; defaults[2] =  if_growing_elset;
  graphics_app.add_check_group(dname,"Options_adv1",options,defaults);
  options.resize(3);
  options[0] = "Dwpe integral";
  //options[1] = "Dislocation propagation";
  options[1] = "Allow pyramid layer";
  options[2] = "Activate meshcleaner";
  defaults.resize(3);
  defaults[0] =  if_Dwpe; defaults[1] =  if_pyra; defaults[2] = if_meshcleaner;
  //defaults[0] =  if_Dwpe; defaults[1] =  if_dislo; defaults[2] = if_meshcleaner;
  graphics_app.add_check_group(dname,"Options_adv2",options,defaults);

//  Specific modifs for Michelin
//  graphics_app.add_command_button(dname,"Init QSUB","init_QS");
//  graphics_app.add_command_button(dname,"Close QSUB","close_QS");

  graphics_app.set_grow_main(2); graphics_app.set_grow_other(2);

  if(user_extention){
    graphics_app.set_add_target("User Extention");
    graphics_app.piece_command(dname,"User Extention","set number_of_items 2");
    graphics_app.set_grow_main(1); graphics_app.set_grow_other(2);
    build_dialog_extention();
  }

  // Release
  graphics_app.realize(dname);

  return(0);
}

//ABR---moving dialog build into seperate functions to avoid the error raised by
//ZP_GRAPHICS_APP::quit on centos8 and ubuntu for example!
void build_advanced_plot_dialog()
{
  ARRAY<STRING> strings,options;
  built_advanced_plot_dialog = 1;
  graphics_app.add_dialog("Advanced Plot");
  graphics_app.set_add_target("");
  graphics_app.add_file_selection("Advanced Plot",".ZCPOST file",zcpost_file);
  options.resize(0);
  graphics_app.add_label("Advanced Plot","Frontsl","Fronts / Fields / Times");
  graphics_app.add_list_group("Advanced Plot","Fronts",options,-1);
  graphics_app.add_list_group("Advanced Plot","Fields",options,-1);
  graphics_app.add_list_group("Advanced Plot","Times",options,-1);
  graphics_app.set_list_multivalue("Advanced Plot","Fronts");
  graphics_app.set_list_multivalue("Advanced Plot","Fields");
  graphics_app.set_list_multivalue("Advanced Plot","Times");

  graphics_app.add_command_button("Advanced Plot","Read","read_zcpost_file");
  graphics_app.add_command_button("Advanced Plot","Plot","plot_selec");
}

void build_advance_propag_dialog()
{
  built_advance_propag_dialog = 1;
  graphics_app.add_dialog("Advanced propag options");
  graphics_app.set_add_target("");
  graphics_app.add_file_selection("Advanced propag options","Propag coefs file",propag_mat_file);
  graphics_app.add_file_selection("Advanced propag options","Propag script file",propag_script);
  graphics_app.add_command_button("Advanced propag options","Edit coefs","edit_propag_coefs");
  graphics_app.add_command_button("Advanced propag options","Edit script","edit_propag_script");
  graphics_app.add_command_button("Advanced propag options","Get sample script","get_sample_script");
}

void build_edit_propag_coeff_dialog()
{
  built_edit_propag_coeff_dialog = 1;
  graphics_app.add_dialog("Edit propag coefs");
  graphics_app.add_label("Edit propag coefs","Edit coefs label","");
  graphics_app.add_text("Edit propag coefs","ADVANCED_PROPAG_EDIT");
  graphics_app.add_command_button("Edit propag coefs","Save","save_propag_coefs");
}

void build_edit_propag_script_dialog()
{
  built_edit_propag_script_dialog = 1;
  graphics_app.add_dialog("Edit propag script");
  graphics_app.add_label("Edit propag script","Edit script label","");
  graphics_app.add_text("Edit propag script","ADVANCED_PROPAG_SCRIPT");
  graphics_app.add_command_button("Edit propag script","Run test","test_propag_script");
  graphics_app.add_command_button("Edit propag script","Save","save_propag_script");
}

void build_hexa_dialog()
{
  built_hexa_dialog = 1;
  graphics_app.add_dialog("Set hexa params");
  graphics_app.set_add_target("");
  graphics_app.add_text_field("Set hexa params","--nb-hexa",itoa(nb_hexa));
  graphics_app.add_text_field("Set hexa params","--dr-hexa",dtoa(dr_hexa));
  graphics_app.add_text_field("Set hexa params","--th-hexa",itoa(th_hexa));
  graphics_app.add_text_field("Set hexa params","--nc-hexa",itoa(nc_hexa));
  graphics_app.add_text_field("Set hexa params","--prog-hexa",dtoa(prog_hexa));
  graphics_app.add_command_button("Set hexa params","Help","show_hexa_help");
}

int build_hexa_help_dialog()
{ 
  STRING help_str;

  help_str=read_hlp_file("hexa_options.hlp");

  built_hexa_help_dialog = 1;
  graphics_app.add_dialog("Help hexa params");
  graphics_app.set_add_target("");

  graphics_app.add_label("Help hexa params","",help_str);
  return(0);
}

int build_quad_help_dialog()
{
  STRING help_str;

  help_str=read_hlp_file("quad_options.hlp");

  built_quad_help_dialog = 1;
  graphics_app.add_dialog("Help quad params");
  graphics_app.set_add_target("");

  graphics_app.add_label("Help quad params","",help_str);
  return(0);
}


void build_quad_dialog()
{
  ARRAY<STRING> options;
  ARRAY<int>    defaults;

  built_quad_dialog = 1;
  graphics_app.add_dialog("Set quad params");
  graphics_app.set_add_target("");
  options.resize(2);
  options[0] = "Full model"; options[1] = "Remeshed zone";
  graphics_app.add_radio_group("Set quad params","Quadratic choice",options, quad_opt);

  options.resize(1); options[0] = "Quarter nodes";
  defaults.resize(1); defaults[0]=if_barsoum;
  graphics_app.add_check_group("Set quad params","Quadratic options 2",options,defaults);
  graphics_app.add_label("Set quad params","","");

  graphics_app.add_command_button("Set quad params","Help","show_quad_help");
}

STRING read_hlp_file(STRING& hlp_file_name)
{
  ASCII_FILE hlp;
  STRING hlp_fname, help_str;
  hlp_fname = getenv("Z7PATH")+"/lib/Scripts/zcracks_help/"+hlp_file_name;
  hlp.open(hlp_fname);

  if(!hlp.ok){
    ERROR("\n file: "+hlp_fname+" cannot be found\n");
  }

  for(i=0;i>=0;i++) {
     str = hlp.getfullline();
     if(!hlp.ok) break;
     if(str=="EMPTY_LINE"){
       help_str=help_str+"\n";
     }else{
       help_str=help_str+str+"\n";
     }
  }
  hlp.close();
  return(help_str);
}

// Read all informations set in Zcracks toolbox
int read_dialog()
{
  STRING cmd,str,field;
  ARRAY<int> opt_fic;
  int tsz,fview0,fview1,ok,iformat;
  double r_0,r_1;

  tsz=0;

  if(is_ductile){ 
    read_dialog_ductile(); 
    return(0);
  }
  
  if(batch_mode) return(0);

  // Read general
  graphics_app.set_add_target("General");

  if(! only_templated) {
    datafile = graphics_app.get_text_field(dname,"Datafile");
  }
    editor = graphics_app.get_text_field(dname,"Editor");
  cmd = graphics_app.get_text_field(dname,"#CPU for SMP");    
  ok = 1;
  if(!cmd.is_int()) ok = 0;
  else {
     smp = cmd.to_int();
     if(smp<1) { smp = 1; ok=0; }
  }
  if(!ok) {
    ERROR("\nInvalid number of CPUs: "+cmd+"\n");
    return(1);
  }

  get_sane_name();
  if(! only_templated) {
    crack_name = graphics_app.get_text_field(dname,"Crack name");
    cracked_name = graphics_app.get_text_field(dname,"Cracked name");
  }

  // arch = graphics_app.get_combo_group(dname,"Arch");

  // Read Remeshing
  opt_fic.resize(1);
  graphics_app.get_check_group(dname,"plane2D",opt_fic);
  if_2D = opt_fic[0];

  if(if_2D) {
    thickness.resize(1); thickness[0]=-1.;
  }
//  graphics_app.set_add_target("Remeshing");
  yams_options = graphics_app.get_text_field(dname,"Yams options");
  cmd = graphics_app.get_text_field(dname,"Min size");
  if(!cmd.is_double()) {
    ERROR("\nInvalid yams min_size value: "+cmd+"\n(float expected)\n");
    return(1);
  }
  min_size = cmd.to_double();
  cmd = graphics_app.get_text_field(dname,"Max size");
  if(!cmd.is_double()) {
    ERROR("\nInvalid yams max_size value: "+cmd+"\n(float expected)\n");
    return(1);
  }
  max_size = cmd.to_double();
  cmd = graphics_app.get_text_field(dname,"Iterations");
  if(!cmd.is_int()) {
    ERROR("\nInvalid crack remeshing iterations number: "+cmd+"\n(int expected)\n");
    return(1);
  }
  nb_iter = cmd.to_int();
/*
  cmd = graphics_app.get_text_field(dname,"Refine radius");
  if(!cmd.is_double()) {
    ERROR("\nInvalid refine_radius value: "+cmd+"\n(float expected)\n");
    return(1);
  }
  refine_radius = cmd.to_double();
  if(refine_radius<=0.0) {
    ERROR("\nInvalid refine_radius value: "+cmd+"\n(must be positive)\n");
    return(1);
  }
*/
  cmd = graphics_app.get_text_field(dname,"Gradation");
  if(!cmd.is_double()) {
    ERROR("\nInvalid gradation value: "+cmd+"\n(float expected)\n");
    return(1);
  }
  gradation = cmd.to_double();
  if(gradation<1.0) {
    ERROR("\nInvalid gradation value: "+cmd+"\n(must >=1.)\n");
    return(1);
  }

  // Read Import/Export
  graphics_app.set_add_target("Import/Export/Hotspots");

  //format = graphics_app.get_text_field(dname,"Import format");
  iformat = graphics_app.get_combo_group(dname,"Format");
  format = import_formats[iformat];

  if(! only_templated) {
    cmd = graphics_app.get_text_field(dname,"Scale factor");
    if(!cmd.is_double()) {
      ERROR("\nInvalid scale: "+cmd+"\n(float expected)\n");
      return(1);
    }
    scale = cmd.to_double();
    cmd = graphics_app.get_text_field(dname,"Get surfaces");
    if(!cmd.is_double()) {
      ERROR("\nInvalid angular criterion: "+cmd+"\n(float expected)\n");
      return(1);
    }
    angle_criterion = cmd.to_double();
    opt_fic.resize(5);
    graphics_app.get_check_group(dname,"Quadratic import",opt_fic);
    from_quad = opt_fic[0]; import_remesh = opt_fic[1];
    if_fuse_import =opt_fic[2] ; if_2D=opt_fic[3] ; if_ghs_only=opt_fic[4];

    // Read host spot
    cmd = graphics_app.get_text_field(dname,"Number");
    if(!cmd.is_int()) {
      ERROR("\nInvalid hotspot number: "+cmd+"\n(int expected)\n");
      return(1);
    }
    hnumber = cmd.to_int();
    cmd = graphics_app.get_text_field(dname,"Zone radius");
    if(!cmd.is_double()) {
      ERROR("\nInvalid hotspot zone size: "+cmd+"\n(float expected)\n");
      return(1);
    }
    hradius = cmd.to_double();
    cmd = graphics_app.get_text_field(dname,"Init radius");
    if(!cmd.is_double()) {
      ERROR("\nInvalid initial radius value: "+cmd+"\n(float expected)\n");
      return(1);
    }
    r_1 = cmd.to_double();
    if(r_1<=0.0) {
      ERROR("\nInvalid radius value: "+cmd+"\n(must be positive)\n");
      return(1);
    } 
  } else {
    opt_fic.resize(1);
    graphics_app.get_check_group(dname,"Quadratic import",opt_fic);
    from_quad = opt_fic[0];
  } 

  // Read crack

  graphics_app.set_add_target("Cracks");
  cmd = graphics_app.get_text_field(dname,"Center");
  str = cmd;
  for(i=0;i<3;i++) {
     field = str.getSTRING();
     if(field.is_int())         center[i]=field.to_int();
     else if(field.is_double()) center[i]=field.to_double();
     else  {
        ERROR("\nUnreadble crack center: "+cmd+"\n(3 float are expected)\n");
        return(1);
     }
  }
  cmd = graphics_app.get_text_field(dname,"Normal");
  str = cmd;
  for(i=0;i<3;i++) {
     field = str.getSTRING();
     if(field.is_int())         normal[i]=field.to_int();
     else if(field.is_double()) normal[i]=field.to_double();
     else  {
        ERROR("\nUnreadble crack normal: "+cmd+"\n(3 float are expected)\n");
        return(1);
     }
  }
  cmd = graphics_app.get_text_field(dname,"Direction");
  str = cmd;
  for(i=0;i<3;i++) {
     field = str.getSTRING();
     if(field.is_int())         dir[i]=field.to_int();
     else if(field.is_double()) dir[i]=field.to_double();
     else  {
        ERROR("\nUnreadble crack direction: "+cmd+"\n(3 float are expected)\n");
        return(1);
     }
  }
  if(only_templated) {
    opt_fic.resize(1);
    graphics_app.get_check_group(dname,"Ellipse",opt_fic);
    if_ellipse = opt_fic[0];
  } else {
    opt_fic.resize(2);
    graphics_app.get_check_group(dname,"Ellipse",opt_fic);
    if_ellipse = opt_fic[0];
    if_czm = opt_fic[1];
  }
  // For all cases
  cmd = graphics_app.get_text_field(dname,"Radius");
  if(!cmd.is_double()) {
    ERROR("\nInvalid radius value: "+cmd+"\n(float expected)\n");
    return(1);
  }
  r_0 = cmd.to_double();
  if(r_0<=0.0) {
    ERROR("\nInvalid radius value: "+cmd+"\n(must be positive)\n");
    return(1);
  }
  ra=r_0;

  if(if_ellipse) {
    cmd = graphics_app.get_text_field(dname,"Ortho/dir radius");
    if(!cmd.is_double()) {
      ERROR("\nInvalid ortho/dir radius value: "+cmd+"\n(float expected)\n");
      return(1);
    }
    rb = cmd.to_double();
    if(rb<=0.0) {
      ERROR("\nInvalid ortho/dir radius: "+cmd+"\n(must be positive)\n");
      return(1);
    }
  } 
  cmd = graphics_app.get_text_field(dname,"Surface id");
  if(!cmd.is_int()) {
    ERROR("\nInvalid crack id: "+cmd+"\n(int expected)\n");
    return(1);
  }
  crack_id = cmd.to_int();

  surf_mesh = graphics_app.get_file_selection(dname,"Surface mesh");

  if(!only_templated)
    refinement_datafile = graphics_app.get_text_field(dname,"Refine file");

  // Read Insertion
  graphics_app.set_add_target("Insertion");
  cmd = graphics_app.get_text_field(dname,"Elset radius");
  if(!cmd.is_double()) {
    ERROR("\nInvalid elset def dist: "+cmd+"\n(float expected)\n");
    return(1);
  }
  elset_radius = cmd.to_double();
  elset_names = graphics_app.get_text_field(dname,"Elsets");
  faset_names = graphics_app.get_text_field(dname,"Fasets");
  liset_names = graphics_app.get_text_field(dname,"Lisets");
  ridge_names = graphics_app.get_text_field(dname,"Ridges");
  nset_names = graphics_app.get_text_field(dname,"Nsets");
  geom_names = graphics_app.get_text_field(dname,"Fixed Fasets");

  if(!only_templated) {

    cmd = graphics_app.get_text_field(dname,"Thickness");
    field=cmd.getSTRING();
    if(field.is_int()) tsz=field.to_int();
    else {
      ERROR("\nUnreadble thickness: "+cmd+"\n(one int and floats are expected)\n");
      return(1);
    }
    thickness.resize(tsz);
    if(thickness.size()>0) if_2D=1; else if_2D=0;
    for(i=0;i<tsz;i++) {
      field = cmd.getSTRING();
      if(field.is_int())         thickness[i]=field.to_int();
      else if(field.is_double()) thickness[i]=field.to_double();
      else  {
        ERROR("\nUnreadble thickness: "+cmd+"\n(one int and floats are expected)\n");
        return(1);
      }
    }
  }
  opt_fic.resize(6);
  graphics_app.get_check_group(dname,"Must extract elset",opt_fic);
  if_must_define_elset = opt_fic[0];
  if_moving_elset = opt_fic[1];
  if_var_refine = opt_fic[2];
  if_surface_refine = opt_fic[3];
  if_must_refine = opt_fic[4];
  if_czm = opt_fic[5];
  //if_keep = opt_fic[6];

  opt_fic.resize(1);
  graphics_app.get_check_group(dname,"Quadratic options 1",opt_fic);
  if_quad = opt_fic[0];

  opt_fic.resize(1);
  graphics_app.get_check_group(dname,"Hexa torus options",opt_fic);
  if_hexa = opt_fic[0];

  // SIF
  graphics_app.set_add_target("SIF");
  cmd = graphics_app.get_text_field(dname,"Front nodes");
  if(!cmd.is_int()) {
    ERROR("\nInvalid front nodes for gtheta: "+cmd+"\n(int expected)\n");
    return(1);
  }
  nb_fnodes = cmd.to_int();

  cmd = graphics_app.get_text_field(dname,"Gth radius");
  if(!cmd.is_double()) {
    ERROR("\nInvalid gth radius: "+cmd+"\n(real expected)\n");
    return(1);
  }
  gth_radius = cmd.to_double();

  cmd = graphics_app.get_text_field(dname,"2nd radius");
  if(!cmd.is_double()) {
    ERROR("\nInvalid 2nd radius value: "+cmd+"\n(real expected)\n");
    return(1);
  }
  rmax = cmd.to_double();


  cmd = graphics_app.get_text_field(dname,"Front#");
  if(!cmd.is_int()) {
    ERROR("\nInvalid front number to view: "+cmd+"\n(int expected)\n");
    return(1);
  }
  fview0=cmd.to_int();

  opt_fic.resize(2);
  graphics_app.get_check_group(dname,"Options_SIF_1",opt_fic);
  if_K = opt_fic[0];
  if_mpa_m =opt_fic[1];
  graphics_app.get_check_group(dname,"Options_SIF_2",opt_fic);
  if_Ki = opt_fic[0];
  if_Gmax = opt_fic[1];
  graphics_app.get_check_group(dname,"Options_SIF_3",opt_fic);
  if_ebe = opt_fic[0];
  if_contact = opt_fic[1];
  if(if_ebe * nb_fnodes<0) {
    ERROR("\nFront nodes should be positive for the Smooth opened front option\n");
    return(1);
  }
  contact_cmds = graphics_app.get_file_selection(dname,"Contact special");
  temperature_name = graphics_app.get_text_field(dname,"Temperature");
  cmd = graphics_app.get_text_field(dname,"Sigma Y");
  if(!cmd.is_double()) {
    ERROR("\nInvalid Sigma Y value: "+cmd+"\n(real expected)\n");
    return(1);
  }
  sigy = cmd.to_double();

  // Propagation
  graphics_app.set_add_target("Propagation");
  cmd = graphics_app.get_text_field(dname,"Max advance");
  if(!cmd.is_double()) {
    ERROR("\nInvalid max advance: "+cmd+"\n(float expected)\n");
    return(1);
  }
  max_h = cmd.to_double();
  cmd = graphics_app.get_text_field(dname,"Front ini length");
  if(!cmd.is_double()) {
    ERROR("\nInvalid lip size: "+cmd+"\n(float expected)\n");
    return(1);
  }
  lip_factor= cmd.to_double();
  cmd = graphics_app.get_text_field(dname,"#Output");
  if(!cmd.is_int()) {
    ERROR("\nInvalid #Output: "+cmd+"\n(int expected)\n");
    return(1);
  }
  nb_pt = cmd.to_int();
//  if(nb_pt<2) nb_pt=2;
  cmd = graphics_app.get_text_field(dname,"Initial time");
  if(!cmd.is_double()) {
    ERROR("\nInvalid Fatigue Ti: "+cmd+"\n(float expected)\n");
    return(1);
  }
  fatigue_Ti= cmd.to_double();
  cmd = graphics_app.get_text_field(dname,"Cycle DeltaT");
  if(!cmd.is_double()) {
    ERROR("\nInvalid Fatigue DT: "+cmd+"\n(float expected)\n");
    return(1);
  }
  fatigue_DT= cmd.to_double();
  cmd = graphics_app.get_text_field(dname,"#Cycles");
  if(!cmd.is_int()) {
    ERROR("\nInvalid Fatigue cycles: "+cmd+"\n(int expected)\n");
    return(1);
  }
  nb_cycles = cmd.to_int();

  iformat = graphics_app.get_combo_group(dname,"Propagation model");
  propag_model = propag_models[iformat];
  if(propag_model!=old_propag_model) {
     if(propag_model != "paris_std") {
        if((propag_model == "z7p")*(!propag_script == 0)) {
          ERROR("\nCannot set coefs of a user model. Please define the script using the Advanced command\n");
          return(1);
        }
        propag_law.set(Create_object("ZCRACKS_PROPAG_LAW",propag_model));
        propag_law.get_coef_names(propag_script,propag_coef_names);
     }
     else {
        propag_coef_names.resize(2);
        propag_coef_names[0] = "C";
        propag_coef_names[1] = "m";
     }
     old_propag_model = propag_model;
  }

  // propag filter
  iformat = graphics_app.get_combo_group(dname,"Propagation filter");
  filter_type = propag_filters[iformat];
  filter_inp = graphics_app.get_file_selection(dname,"Filter input file");
  
  /*
  cmd = graphics_app.get_text_field(dname,"Cycle DeltaN");
  if(cmd.is_int()) paris_DN = cmd.to_int();
  else if(cmd.is_double()) paris_DN = cmd.to_double();
  else {
    ERROR("\nInvalid Delta N Paris value\n");
    return(1);
  }
  */
  opt_fic.resize(3);

  cmd = graphics_app.get_text_field(dname,"Smooth propag\n\n\n");
  if(!cmd.is_int()) {
    ERROR("\nInvalid smooth propag value: "+cmd+"\n(int expected)\n");
    return(1);
  }
  smooth_propag=cmd.to_int();

  graphics_app.get_check_group(dname,"Options_PROPAG",opt_fic);
  if_lip_factor = opt_fic[0];
  if_transfert = opt_fic[1];
  graphics_app.get_check_group(dname,"Options_PROPAG2",opt_fic);
  if_remove_ext_propag = opt_fic[0];
  if_dGda = opt_fic[1];
  mat_file = graphics_app.get_file_selection(dname,"Transfer mat file");

  cmd = graphics_app.get_text_field(dname,"View Front$");
  if(!cmd.is_int()) {
    ERROR("\nInvalid front number to view: "+cmd+"\n(int expected)\n");
    return(1);
  }
  fview1=cmd.to_int();

  //front_plane = graphics_app.get_text_field(dname,"Front plane");
  front_plane = graphics_app.get_combo_group(dname,"Projection");

  // Advanced
  graphics_app.set_add_target("Advanced");
  if(!only_templated)
    debug = graphics_app.get_text_field(dname,"Debug mode");

  elset_name = graphics_app.get_text_field(dname,"Cracked elset");
  fe_command = graphics_app.get_text_field(dname,"External FE command");
  qsub_file_name = graphics_app.get_text_field(dname,"Run using qsub");
  elset_to_cut = graphics_app.get_text_field(dname,"Only cut elset");

  if(only_templated)
    cracked_name = graphics_app.get_text_field(dname,"Cracked name");

  if(!only_templated) {
    cmd = graphics_app.get_text_field(dname,"Remove /hexa ext");
    if(!cmd.is_int()) {
      ERROR("\nInvalid remove_ext_hexa value: "+cmd+"\n(int expected)\n");
      return(1);
    }
    remove_ext_hexa=cmd.to_int();
    if(remove_ext_hexa<0) ERROR("\nInvalid remove_ext_hexa value: "+cmd+"\n(positive value expected)\n");
  }
 
  cmd = graphics_app.get_text_field(dname,"Element layers");
  if(!cmd.is_int()) {
    ERROR("\nInvalid volume elem number for gtheta support: "+cmd+"\n(int expected)\n");
    return(1);
  }
  nb_velem = cmd.to_int();

  if(only_templated){
    cmd = graphics_app.get_text_field(dname,"Dynamic density");
    if(!cmd.is_double()) {
      ERROR("\nInvalid constant density for dynamic calculations: "+cmd+"\n(double expected)\n");
      return(1);
    }
    constant_density = cmd.to_double();

    cmd = graphics_app.get_text_field(dname,"Max kink angle");
    if(!cmd.is_double()) {
      ERROR("\nInvalid value for kink angle: "+cmd+"\n(double expected)\n");
      return(1);
    } else if(cmd.is_double()<0.){
      ERROR("\nInvalid value for kink angle: "+cmd+"\n(positive value expected)\n");
      return(1);
    }
    max_kink_angle = cmd.to_double();

    cmd = graphics_app.get_text_field(dname,"Remove /hexa ext");
    if(!cmd.is_int()) {
      ERROR("\nInvalid remove_ext_hexa value: "+cmd+"\n(int expected)\n");
      return(1);
    }
    remove_ext_hexa=cmd.to_int();
    if(remove_ext_hexa<0) ERROR("\nInvalid remove_ext_hexa value: "+cmd+"\n(positive value expected)\n");

  }

  // gtheta checkbox
  opt_fic.resize(1);
  graphics_app.get_check_group(dname,"Options_gtheta_1",opt_fic);
  if_contact_correction = opt_fic[0];

  opt_fic.resize(1);
  graphics_app.get_check_group(dname,"Options_gtheta_2",opt_fic);
  if_add_mpc_for_contact = opt_fic[0];
  if((!if_add_mpc_for_contact)*(!format.start_with("abaqus"))) {
      ERROR("\n\"Add MPC on contact option\" can be deactivated only for Abaqus\n");
      return(1);
  }

  if(!only_templated){
    cmd = graphics_app.get_text_field(dname,"Max front");
    if(!cmd.is_int()) {
      ERROR("\nInvalid crack surface nodes number: "+cmd+"\n(int expected)\n");
      return(1);
    }
    nb_fronts = cmd.to_int();
    cmd = graphics_app.get_text_field(dname,"Filtering");
    if(!cmd.is_double()) {
      ERROR("\nInvalid face filtering value: "+cmd+"\n(float expected)\n");
      return(1);
    }
    filter_tol = cmd.to_double();
    if(!new_version) {
      cmd = graphics_app.get_text_field(dname,"Grid max");
      if(!cmd.is_double()) {
        ERROR("\nInvalid global tolerance value: "+cmd+"\n(float expected)\n");
        return(1);
      }
      grid_max = cmd.to_double();
    }
    tol_cut=0.; 
    cmd = graphics_app.get_text_field(dname,"Lip fuse");
    if(!cmd.is_double()) {
      ERROR("\nInvalid lip tolerance value: "+cmd+"\n(float expected)\n");
      return(1);
    }
    lip_tol = cmd.to_double();
    cmd = graphics_app.get_text_field(dname,"Normal length");
    if(!cmd.is_double()) {
      ERROR("\nInvalid Normal value for front output: "+cmd+"\n(float expected)\n");
      return(1);
    }
    n_length = cmd.to_double();
    cmd = graphics_app.get_text_field(dname,"XFEM radius");
    if(!cmd.is_double()) {
      ERROR("\nInvalid TIP radius for xfem enrichement: "+cmd+"\n(double expected)\n");
      return(1);
    }
    TIP_radius = cmd.to_double();
    cmd = graphics_app.get_text_field(dname,"Extern step");
    if(!cmd.is_double()) {
      ERROR("\nInvalid ext distance step: "+cmd+"\n(float expected)\n");
      return(1);
    }
    ext_dist= cmd.to_double();
    opt_fic.resize(4);
    cmd=graphics_app.get_text_field(dname,"Ref ext");
    if(!cmd.is_int()) {
      ERROR("\nInvalid front ext nodes numbers for gtheta refinement: "+cmd+"\n(int expected)\n");
      return(1);
    }
    nb_ext = cmd.to_int();
 
    if_exclude_BE=nb_ext;
    if(if_ebe) {
      if_exclude_BE=-1*if_exclude_BE;
      if_exclude_BE=if_exclude_BE-1;
    }
  }

  // Always read those info
  opt_fic.resize(3);
  graphics_app.get_check_group(dname,"Options_adv1",opt_fic);
  if_ext = opt_fic[0];
  if_separate = opt_fic[1];
  if_growing_elset=opt_fic[2]; 
  opt_fic.resize(3);
  graphics_app.get_check_group(dname,"Options_adv2",opt_fic);
  if_Dwpe = opt_fic[0];
  if_pyra = opt_fic[1];
  //if_dislo = opt_fic[1];
  if_meshcleaner = opt_fic[2];

  cmd = graphics_app.get_text_field(dname,"Quality");
  if(!cmd.is_double()) {
    ERROR("\nInvalid max quality value: "+cmd+"\n(double expected)\n");
    return(1);
  }
  if(cmd.to_double()<0.0) {
    ERROR("\nInvalid max quality value: "+cmd+"\n(positive value expected)\n");
    return(1);
  }
  max_quality = cmd.to_double();

  cmd = graphics_app.get_text_field(dname,"Power function coef");
  if(!cmd.is_double()) {
    ERROR("\nInvalid coefficient for power function: "+cmd+"\n(double expected)\n");
    return(1);
  }
  if(cmd.to_double()<0.0) {
    ERROR("\nInvalid coefficient for power function: "+cmd+"\n(positive value expected)\n");
    return(1);
  }
  power_func_coef = cmd.to_double();

  cmd = graphics_app.get_text_field(dname,"Fuse length");
  if(!cmd.is_double()) {
    ERROR("\nInvalid coalescing fuse length: "+cmd+"\n(double expected)\n");
    return(1);
  }
  fuse_length = cmd.to_double();

  cmd = graphics_app.get_text_field(dname,"Domain decomposition");
  if(!cmd.is_int()) {
    ERROR("\nInvalid domain decomposition number: "+cmd+"\n(int expected)\n");
    return(1);
  }
  nb_dd = cmd.to_int();
  if(nb_dd<0) ERROR("\nInvalid domain decomposition number: "+cmd+"\n(positive value expected)\n");

  if(fview1!=fview0) { 
    if(front_view!=fview1) front_view=fview1;
    else front_view=fview0;
    update_dialog();
  } else front_view=fview0;

  // For 2D problem reinit 2D mesh
  if_2DE=if_2D;
  if(if_2DE) {
    if_2DE=(thickness.size()==1);
    if(if_2DE) if_2DE=(thickness[0]==-1.);
    if_2DE=!if_2DE;
  }

  if(user_extention){
    ret=read_dialog_extention();
    if(ret) return(ret);
  }
 
  return(0);
}

// Update all fields in the toolbox
int update_dialog()
{
  STRING cmd,str,field;
  ARRAY<int> opt_fic;
  ARRAY<STRING> options;
  int tsz,iformat;

  tsz=0;
/*
  if(if_exclude_BE<0) {
    if_ebe=1;
    nb_ext=-if_exclude_BE-1;
  } else {
    if_ebe=0;
    nb_ext=if_exclude_BE;
  }
*/

  if(is_ductile){
    update_dialog_ductile();
    return(0);
  }

  if(batch_mode) return(0);

  // Set general
  graphics_app.set_add_target("General");

  if(!only_templated) graphics_app.set_text_field(dname,"Datafile",datafile);
  graphics_app.set_text_field(dname,"Editor",editor);
  graphics_app.set_text_field(dname,"#CPU for SMP",itoa(smp));    
  graphics_app.set_file_selection(dname,"Sane name",sane_name);
  if(!only_templated) graphics_app.set_text_field(dname,"Crack name",crack_name);
  if(!only_templated) graphics_app.set_text_field(dname,"Cracked name",cracked_name);
  graphics_app.set_text_field(dname,"Yams options",yams_options);
//  graphics_app.set_text_field(dname,"Refine radius",dtoa(refine_radius));
  graphics_app.set_text_field(dname,"Gradation",dtoa(gradation));
  graphics_app.set_text_field(dname,"Min size",dtoa(min_size));
  graphics_app.set_text_field(dname,"Max size",dtoa(max_size));
  graphics_app.set_text_field(dname,"Iterations",itoa(nb_iter));

  opt_fic.resize(1);
  opt_fic[0]=if_2D;
  graphics_app.set_check_group(dname,"plane2D",opt_fic);

  /*
  options.resize(2);
  options[0]="32 bits";
  options[1]="64 bits";
  graphics_app.set_combo_group(dname,"Arch",options,arch);
  */

  // Set Import/Export
  graphics_app.set_add_target("Import/Export/Hotspots");

  if(get_sel(import_formats,format,iformat)) {
     options.resize(!import_formats);
     for(i=0;i<!import_formats;i++) options[i] = import_formats[i];
     graphics_app.set_combo_group(dname,"Format",options,iformat);
  }

  if(!only_templated){  
    graphics_app.set_text_field(dname,"Scale factor",dtoa(scale));
    graphics_app.set_text_field(dname,"Get surfaces",dtoa(angle_criterion));
  }

  if(only_templated) {
    opt_fic.resize(1);
    opt_fic[0]=from_quad;
    graphics_app.set_check_group(dname,"Quadratic import",opt_fic);
  } else {
    opt_fic.resize(5);
    opt_fic[0]=from_quad;
    opt_fic[1]=import_remesh;
    opt_fic[2]=if_fuse_import;
    opt_fic[3]=if_2D;
    opt_fic[4]=if_ghs_only;
    graphics_app.set_check_group(dname,"Quadratic import",opt_fic);
    graphics_app.set_text_field(dname,"Number",itoa(hnumber));
    graphics_app.set_text_field(dname,"Zone radius",dtoa(hradius));
    graphics_app.set_text_field(dname,"Init radius",dtoa(ra));
  }

  // Set Cracks
  graphics_app.set_add_target("Cracks");
  str="";
  for(i=0;i<3;i++) str=str+dtoa(center[i])+" ";
  graphics_app.set_text_field(dname,"Center",str);
  str="";
  for(i=0;i<3;i++) str=str+dtoa(normal[i])+" ";
  graphics_app.set_text_field(dname,"Normal",str);
  str="";
  for(i=0;i<3;i++) str=str+dtoa(dir[i])+" ";
  graphics_app.set_text_field(dname,"Direction",str);
  if(only_templated) {
    opt_fic.resize(1);
    opt_fic[0]=if_ellipse;
  } else {
    opt_fic.resize(2);
    opt_fic[0]=if_ellipse;
    opt_fic[1]=if_czm;
  }
  graphics_app.set_check_group(dname,"Ellipse",opt_fic);
  graphics_app.set_text_field(dname,"Radius",dtoa(ra));
  graphics_app.set_text_field(dname,"Ortho/dir radius",dtoa(rb));
  graphics_app.set_text_field(dname,"Surface id",itoa(crack_id));

  // Set Insertion
  graphics_app.set_add_target("Insertion");
  graphics_app.set_text_field(dname,"Elsets",elset_names);
  graphics_app.set_text_field(dname,"Fasets",faset_names);
  graphics_app.set_text_field(dname,"Lisets",liset_names);
  graphics_app.set_text_field(dname,"Ridges",ridge_names);
  graphics_app.set_text_field(dname,"Nsets",nset_names);
  graphics_app.set_text_field(dname,"Fixed Fasets",geom_names);
  graphics_app.set_text_field(dname,"Elset radius",dtoa(elset_radius));
  if(!only_templated) {
    str=itoa(thickness.size());
    if(thickness.size()>0) {
      if_2D=1; 
      tsz=thickness.size();
      for(i=0;i<tsz;i++) 
        str=str+" "+dtoa(thickness[i]);
    } else if_2D=0;
    graphics_app.set_text_field(dname,"Thickness",str);
  }
  opt_fic.resize(6);
  opt_fic[0]=if_must_define_elset;
  opt_fic[1]=if_moving_elset;
  opt_fic[2]=if_var_refine;
  opt_fic[3]=if_surface_refine; 
  opt_fic[4]=if_must_refine;
  opt_fic[5]=if_czm;
  //opt_fic[6]=if_keep;
  graphics_app.set_check_group(dname,"Must extract elset",opt_fic);

  opt_fic.resize(1); opt_fic[0]=if_quad;
  graphics_app.set_check_group(dname,"Quadratic options 1",opt_fic);

  opt_fic.resize(1); opt_fic[0]=if_hexa;
  graphics_app.set_check_group(dname,"Hexa torus options",opt_fic);

  // SIF
  graphics_app.set_add_target("SIF");
  graphics_app.set_text_field(dname,"Front nodes",itoa(nb_fnodes));
  graphics_app.set_text_field(dname,"Gth radius",dtoa(gth_radius));
  graphics_app.set_text_field(dname,"2nd radius",dtoa(rmax));
//  graphics_app.set_text_field(dname,"Gmax ang err",dtoa(astep));
//  graphics_app.set_text_field(dname,"Gmax ang step",dtoa(hnumber));
  graphics_app.set_text_field(dname,"Front#",itoa(front_view));
  opt_fic.resize(2);
  opt_fic[0]=if_K;
  opt_fic[1]=if_mpa_m;
  graphics_app.set_check_group(dname,"Options_SIF_1",opt_fic);
  opt_fic[0]=if_Ki;
  opt_fic[1]=if_Gmax;
  graphics_app.set_check_group(dname,"Options_SIF_2",opt_fic);
  opt_fic[0]=if_ebe;
  opt_fic[1]=if_contact;
  graphics_app.set_check_group(dname,"Options_SIF_3",opt_fic);
  graphics_app.set_text_field(dname,"Temperature",temperature_name);
  graphics_app.set_text_field(dname,"Sigma Y",dtoa(sigy));

  // Propagation
  graphics_app.set_add_target("Propagation");
  graphics_app.set_text_field(dname,"Max advance",dtoa(max_h));
  graphics_app.set_text_field(dname,"Front ini length",dtoa(lip_factor));
  graphics_app.set_text_field(dname,"#Output",itoa(nb_pt));
  graphics_app.set_text_field(dname,"View Front$",itoa(front_view));
  //graphics_app.set_text_field(dname,"Front plane",front_plane);
  graphics_app.set_text_field(dname,"Initial time",dtoa(fatigue_Ti));
  graphics_app.set_text_field(dname,"Cycle DeltaT",dtoa(fatigue_DT));
  graphics_app.set_text_field(dname,"#Cycles",itoa(nb_cycles));
  if(get_sel(propag_models,propag_model,iformat)) {
     options.resize(!propag_models);
     for(i=0;i<!propag_models;i++) options[i] = propag_models[i];
     graphics_app.set_combo_group(dname,"Propagation model",options,iformat);
  }
  else ERROR("Unknown propag model: "+propag_model);

  opt_fic.resize(2);
  opt_fic[0]=if_lip_factor;
  opt_fic[1]=if_transfert;
  graphics_app.set_check_group(dname,"Options_PROPAG",opt_fic);
  opt_fic[0]=if_remove_ext_propag;
  opt_fic[1]=if_dGda;
  graphics_app.set_check_group(dname,"Options_PROPAG2",opt_fic);
  graphics_app.set_text_field(dname,"Smooth propag\n\n\n",itoa(smooth_propag));

  // Advanced
  graphics_app.set_add_target("Advanced");
  if(!only_templated){
    graphics_app.set_text_field(dname,"Debug mode",debug);
  }
  graphics_app.set_text_field(dname,"Cracked elset",elset_name);
  graphics_app.set_text_field(dname,"External FE command",fe_command);
  graphics_app.set_text_field(dname,"Run using qsub",qsub_file_name);
  graphics_app.set_text_field(dname,"Only cut elset",elset_to_cut);
  if(only_templated) graphics_app.set_text_field(dname,"Cracked name",cracked_name);

  graphics_app.set_text_field(dname,"Domain decomposition",itoa(nb_dd));
  graphics_app.set_text_field(dname,"Element layers",itoa(nb_velem));
  opt_fic.resize(1);
  opt_fic[0]=if_contact_correction;
  graphics_app.set_check_group(dname,"Options_gtheta_1",opt_fic);

  opt_fic.resize(1);
  opt_fic[0]=if_add_mpc_for_contact;
  graphics_app.set_check_group(dname,"Options_gtheta_2",opt_fic);

  if(!only_templated){
    graphics_app.set_text_field(dname,"Max front",itoa(nb_fronts));
    graphics_app.set_text_field(dname,"Filtering",dtoa(filter_tol));
    if(!new_version) graphics_app.set_text_field(dname,"Grid max",dtoa(grid_max));
    graphics_app.set_text_field(dname,"Lip fuse",dtoa(lip_tol));
    graphics_app.set_text_field(dname,"Normal length",dtoa(n_length));
    graphics_app.set_text_field(dname,"XFEM radius",dtoa(TIP_radius));
    graphics_app.set_text_field(dname,"Extern step",dtoa(ext_dist));
    graphics_app.set_text_field(dname,"Ref ext",itoa(nb_ext));
  }
  graphics_app.set_text_field(dname,"Power function coef",dtoa(power_func_coef));
  opt_fic.resize(3);
  opt_fic[0]=if_ext;
  opt_fic[1]=if_separate;
  opt_fic[2]=if_growing_elset;
  graphics_app.set_check_group(dname,"Options_adv1",opt_fic);
  opt_fic.resize(3);
  opt_fic[0]=if_Dwpe;
//  opt_fic[1]=if_dislo;
  opt_fic[1]=if_pyra;
  opt_fic[2]=if_meshcleaner;
  graphics_app.set_check_group(dname,"Options_adv2",opt_fic);

  return(0);
}

void convert_surface(STRING &surf_mesh_name)
{ ASCII_FILE file;
  ARRAY <VECTOR> points;
  Zfstream inp;
  STRING cmd,MG,tmp,extention,save_surf_mesh_name,zcfile,s1,s2;
  double sz,sz2;
  int npoint,i,j,n,ret,niter;

  niter=nb_iter;
  if(niter<0) niter=-niter;

  if(if_meshgems) MG="mesh_gems";
  else MG="yams_ghs3d";

  tmp = surf_mesh_name;
  extention=tmp.get_suffix();

  if(surf_mesh_name=="") {
    ERROR("Surface mesh must be specified");
  } else if ((extention==".geo") || (extention==".geof")){
    inp.open("CONVERT_SURF.inp",ios::out);
    inp.setf(ios::scientific);
    inp.precision(64);

    inp<<"****mesher"<<endl;
    inp<<" ***mesh "<<crack_name<<"_"<<crack_id<<".geo"<<endl;
    inp<<"  **open "<<surf_mesh_name<<endl;
    inp<<"  **quad_to_lin"<<endl;
    // inp<<"  **quad_to_tri"<<endl;
    inp<<"  **to_3d"<<endl;
    inp<<" ***mesh "<<crack_name<<"_"<<crack_id<<".geo"<<endl;
    inp<<"  **open "<<crack_name<<"_"<<crack_id<<".geo"<<endl;
    inp<<"  **to_3d"<<endl;
    if(if_remesh_surface) {
      for(i=0;i<niter;i++) {
        if(if_surface_refine)  inp<<"  **remove_set *nsets ORIGIN **nset ORIGIN *function 1.;"<<endl;
        else inp<<"  **remove_set *nsets ORIGIN **unshared_edges ORIGIN"<<endl;
        sz=min_size;
        sz2=nb_velem;
        sz2=sz2*sz;
        inp<<"  **"<<MG<<" *yams_only *refinement_gradation ORIGIN "
           <<dtoa(sz)<<" "<<dtoa(sz2)<<" "<<dtoa(gradation)<<" *nb_iter 1"<<endl;
        inp<<"   *options "<<yams_options<<endl;
      }
    }
    inp<<"  **unshared_edges "<<crack_name<<"_front"<<endl;
    inp<<"  **elset "<< crack_name <<endl;
    inp<<"   *function 1.;"<<endl;
    inp<<"   "<<endl;
    inp<<"  **nset "<< crack_name <<endl;
    inp<<"   *function 1.;"<<endl;
    inp<<"   "<<endl;

    if(crack_id>0) {
       inp<<" ***mesh "<<crack_name<<".geo"<<endl;
       inp<<"  **open "<<crack_name<<"_"<<crack_id<<".geo"<<endl;
       for(i=0;i<crack_id;i++) {
          inp<<"  **union"<<endl;
          inp<<"   *add "<<crack_name<<"_"<<i<<".geo"<<endl;
          inp<<"   *tolerance 0.0"<<endl;
       }
    }
    else {
       inp<<" ***mesh "<<crack_name<<".geo"<<endl;
       inp<<"  **open "<<crack_name<<"_0.geo"<<endl;
    }

    if((sane_name!="")&&(sane_name!="none")) {
      inp<<" ***mesh "<<sane_name<<"_CRACKI.geo"<<endl;
      inp<<"  **open "<<sane_name<<endl;
      if(from_quad) inp << "  **quad_to_lin"<<endl;
      inp<<"  **to_3d"<<endl;
      inp<<"  **union *add "<<crack_name<<".geo *append_id";
      if(max_node_id>0) inp<<" *from_node "<<max_node_id;
      if(max_ele_id>0)  inp<<" *from_element "<<max_ele_id;
      inp<<" *tolerance 0."<<endl;
      inp<<"  **bset _CRACK_ *use_nset "<<crack_name<<endl;
      inp<<"  **"<<MG<<endl;
      if(optim_style!="") inp << "   *optim_style "<<optim_style<<endl;
      if((arch==1)&&(!if_meshgems)) inp<<"   *m64"<<endl;
      inp<<"   *yams_only *preserve_faset _CRACK_ *yams copy"<<endl;
      inp<<"   *preserve_liset "<<crack_name<<"_front"<< endl;
    }

    inp<<"****return"<<endl;
    inp.close();

    cmd=ZRUN_CMD+" -m CONVERT_SURF.inp";
    ret = system(cmd);
  } else if(if_2D) {
    zcfile=surf_mesh_name;
    if(zcfile.locate("@")) {
      s1=zcfile;
      s1.locate_and_cut_before("@");
      s2=zcfile;
      s2.locate_and_cut_after("@");
      j=s2.to_int();
      zcfile=s1+"0";
    } else j=0;
    STD_RM("mesh_"+surf_mesh_name+".geof");
    cmd="**crack_from_2D_path *ascii_file "+zcfile+"\n";
    for(i=1;i<=j;i++) {
      cmd=cmd+"**crack_from_2D_path *ascii_file "+s1+itoa(i)+"\n";
      cmd=cmd+"**fuse_nset *cleanup_mesh *iterate *tolerance "+filter_tol+"\n";
    }
    apply_mesher("", "mesh_"+surf_mesh_name+".geo",cmd,1);
    //apply_mesher("", "mesh_"+surf_mesh_name+".geo","**crack_from_2D_path *ascii_file "+surf_mesh_name,1);
    convert_surface("mesh_"+surf_mesh_name+".geo");
  } else {
    STD_RM("mesh_"+surf_mesh_name+".geof");
    STD_RM("meshr_"+surf_mesh_name+".geo");
    STD_RM("meshr_"+surf_mesh_name+".geof");

    save_surf_mesh_name = surf_mesh_name;
    surf_mesh_name.locate_and_cut_after_last("/");
    if(surf_mesh_name.locate(".")) surf_mesh_name.remove_suffix();

// Create mast file and mesh
    inp.open("ASCII_TO_GEOF.inp",ios::out);
    inp.setf(ios::scientific);
    inp<<"****mesher"<<endl;
    inp<<" ***mesh do_not_save"<<endl;
    inp<<"  **ascii_to_mast"<<endl;
    inp<<"   *ascii_file "<<save_surf_mesh_name<<endl;
    inp<<"   *output mesh_"<<surf_mesh_name<<".mast"<<endl;
    inp<<"   *create_mesh"<<endl;
    inp<<"   *min_size "<<min_size<<endl;
    inp<<"****return"<<endl;
    inp.close();

    cmd=ZRUN_CMD+" -m ASCII_TO_GEOF.inp";
    ret = system(cmd);
   
//Refine mesh
    cmd="";
    cmd=cmd+"  **remove_set *nsets ORIGIN *bsets ORIGIN **unshared_edges ORIGIN\n";
    sz=min_size;
    sz2=nb_velem;
    sz2=sz2*sz;
    cmd=cmd+"  **"+MG+" *binary *yams_only *refinement_gradation ORIGIN "
           +dtoa(sz)+" "+dtoa(sz2)+" "+dtoa(gradation)+" *nb_iter "+itoa(niter)+"\n";
    cmd=cmd+"  **put_on_grid *nbdigit 4\n";
    apply_mesher("mesh_"+surf_mesh_name+".geof","meshr_"+surf_mesh_name+".geo",cmd);
    convert_surface("meshr_"+surf_mesh_name+".geo");
  } 
}

int import_mesh(STRING &file_name,STRING &file_format)
{ 
  Zfstream inp,med_ver_file;
  STRING cmd,ext,MG;
  int ret, is_z7;

  if(if_meshgems) MG="mesh_gems";
  else MG="yams_ghs3d";

  if((!file_format.start_with("zebulon"))*(is_ductile)) {
    ERROR("\nDuctile mode is available for zebulon_templated format only.\n");
    return(1);
  }

  if(!import_formats.is_in(file_format)) {
    ERROR("\nInvalid import format: "+file_format+" is unknown.\n");
    return(1);
  }

  if(file_format.start_with("zebulon")) is_z7 = 1;
  else if(file_format.start_with("aster"))  is_z7 = 1;
  else                                  is_z7 = 0;

  ext = ".inp";
  if(file_format=="med")                     ext=".med";
  else if(file_format=="aster_templated")    ext=".export";
  else if(file_format=="samcef_templated")   ext=".dat";
  else if(file_format=="mesh")               ext=".mesh";

  inp.open("IMPORT.inp",ios::out);
  inp.setf(ios::scientific);

  inp<<"****mesher"<<endl;
  if(!is_z7) inp<<" ***shell "<<del_cmd<<file_name<<".geof "<<file_name<<".geo "<<endl;

  if(is_z7)  inp<<" ***mesh do_not_save"<<endl;
  else       inp<<" ***mesh IMPORT-new.geo"<<endl;

  inp<<"  **import "<<file_format<<" "<<file_name<<ext<<endl;
//  inp<<"  **quad_to_lin"<<endl;//ABR-----------------------------------------------------------------------*********************** tmp for ZCRACKS_ANSYS
  if(file_format=="abaqus") {
    inp<<"  **inp_file"<<endl;
  }
  if(!is_z7) {
  //   inp<<"  **save "<<file_name<<".geo"<<endl;
     inp<<" ***mesh "<<file_name<<".geo"<<endl;
     inp<<"  **open IMPORT-new.geo"<<endl;
     if(from_quad*import_remesh) inp<<"  **quad_to_lin"<<endl;
     inp<<"  **scale "<<scale<<endl;
  //   inp<<" ***shell "<<del_cmd<<file_name<<".geof"<<endl;
     if(file_format=="abaqus") {
       inp<<" ***mesh "<<file_name<<".geo"<<endl;
       inp<<"  **open "<<file_name<<".geo"<<endl;
       inp<<"  **transform_fili"<<endl;
     }

     if(import_remesh) {
       inp<<" ***mesh "<<file_name<<".geo"<<endl;
       inp<<"  **open "<<file_name<<".geo"<<endl;
       if(if_fuse_import) inp<<"  **fuse_nset *skip_reassign_numbers *cleanup_mesh *iterate *tolerance "<<filter_tol<<endl;
       inp<<"  **degenerated_elset"<<endl;
       inp<<"  **delete_elset DEGENERATED_ELEMENTS"<<endl;
       inp<<"  **"<<MG<<endl;
       if(yams_prefix!="") {
          inp<<"  *yams "<<yams_prefix<<"yams"<<endl;
          inp<<"  *ghs3d "<<yams_prefix<<"ghs3d"<<endl;
          inp<<"  *meshadapt "<<yams_prefix<<"meshadapt"<<endl;
       }

       if(optim_style!="") inp << "   *optim_style "<<optim_style<<endl;
       if((arch==1)&&(!if_meshgems)) inp<<"   *m64"<<endl;
       inp<<"   *absolu *binary"<<endl;

       if(if_2D) inp<<"   *yams_only"<<endl;
       if(if_ghs_only) inp<<"   *ghs_only"<<endl;
       inp<<"   *options "<<yams_options<<endl;
       //inp<<"   *get_ridges"<<endl;
     }

     if(angle_criterion>0.) {
       inp<<" ***mesh "<<file_name<<".geo"<<endl;
       inp<<"  **open "<<file_name<<".geo"<<endl;
       inp<<"  **extract_surface *criterion "<<angle_criterion<<endl;
     }
  }

  inp<<"****return"<<endl;
  inp.close();

  cmd=ZRUN_CMD+" -m IMPORT.inp";
  ret = system(cmd);

  // Opens inp file for abaqus
  if(file_format=="abaqus") {
    cmd= editor+" "+"IMPORT-new.inp";
    ret = system(cmd);
  }

  //ABR---for writing med in same version as the input med
  if(file_format.start_with("aster"))
  {
    med_ver_file.open("MED_VER",ios::in);
    med_ver_file>>MedVersion;
  }
  return(0);
}

void export_mesh(STRING &file_name,STRING& file_format)
{ Zfstream inp;
  STRING cmd,ext,str,bset_name,tmp;
  int ret,i;
  double i_scale;

  if(file_format=="med") ext=".med";
  else if(file_format=="abaqus") ext="_EXPORT";
  i_scale=1./scale;

  inp.open("EXPORT.inp",ios::out);
  inp.setf(ios::scientific);
  inp.precision(64);

  inp<<"****mesher"<<endl;
  inp<<" ***mesh "<<endl;
  inp<<"  **open "<<file_name<<endl;
  inp<<"  **scale "<<i_scale<<endl;
  if(file_format=="med") {
    inp<<"  **remove_set *bsets SURFACE Nlip"<<endl;
  } else if(file_format=="abaqus") {
    // Generating nset from bsets
    if(if_quad) inp<<"  **to_c3d10_4"<<endl;
    inp<<"  **pyra_to_hexa"<<endl;
    //else inp<<"  **set_reduced"<<endl;
    tmp=faset_names;
    for(i=0;i>=0;i++) {
      bset_name=tmp;
      bset_name.locate_and_cut_before(" ");
      tmp.locate_and_cut_after(" "); 
      if(bset_name.start_with("NN")) continue;
      if(bset_name!="") {
        inp<<"  **nset "<<bset_name<<endl;
        inp<<"   *use_bset "<<bset_name<<endl;
      }
      if(bset_name==tmp) break;
    }
    tmp=liset_names;
    for(i=0;i>=0;i++) {
      bset_name=tmp;
      bset_name.locate_and_cut_before(" ");
      tmp.locate_and_cut_after(" ");
      if(bset_name.start_with("NN")) continue;
      if(bset_name!="") {
        inp<<"  **nset "<<bset_name<<endl;
        inp<<"   *use_bset "<<bset_name<<endl;
      }
      if(bset_name==tmp) break;
    }
  }
  inp<<"  **export "<<file_format<<" "<<file_name<<ext<<endl;
  if(format=="med") {
    if(MedVersion!="") inp<<"   *version "<<MedVersion<<endl;
  }
  if(format=="abaqus") {
    inp<<" ***shell "<<cop_cmd<<file_name<<ext<<".geof "<<file_name<<ext<<".inp"<<endl;
    inp<<" ***shell "<<del_cmd<<file_name<<ext<<".geof"<<endl;
  }
  inp<<" ***mesh "<<file_name<<"_R.geo"<<endl;
  inp<<"  **open "<<file_name<<endl;
  if(if_quad) inp<<"  **to_c3d10_4"<<endl;
  else inp<<"  **set_reduced"<<endl;
  inp<<"****return"<<endl;
  inp.close();

  str=ZRUN_CMD+" -m EXPORT.inp";
  ret = system(str);
}

void write_PROPAG()
{ Zfstream inp;

  int i;
  double filt2=4.*filter_tol;

  inp.open(cracked_name+"_PROPAG.inp",ios::out);
  inp.setf(ios::scientific);

  inp<<"%-----------------------------------------------------------  "<<endl;
  inp<<"% Calcul - PROPAG computation (must be filled)             | "<<endl;
  inp<<"%-----------------------------------------------------------  "<<endl;
  inp<<endl;
  inp<<"****calcul"<<endl;
  inp<<"  "<<endl;
  inp<<" ***mesh"<<endl;
  inp<<"  **file "<<cracked_name<<".geo"<<endl;
  inp<<"  "<<endl;
  inp<<" ***resolution"<<endl;
  inp<<"  **cycles "<<nb_cycles<<endl;
  inp<<"   *dtime 1. 1."<<endl;
  inp<<"  %**sequence"<<endl;
  inp<<"  % *time 1."<<endl;
  inp<<"   *increment 1"<<endl;
  inp<<"   *ratio automatic .01"<<endl;
  inp<<"   *algorithm p1p2p3"<<endl;
  inp<<"  "<<endl;
  inp<<" ***bc"<<endl;
  if(bc_conditions!="") inp<<bc_conditions<<endl;
  else {
    inp<<"  **impose_nodal_dof"<<endl;
    inp<<"    ..."<<endl;
  }
  inp<<"  "<<endl;
  inp<<" ***table"<<endl;
  inp<<"  **cycle cycle_load 0. 200."<<endl;
  inp<<"   *time 0. 1. 2."<<endl;
  inp<<"   *value 0. 1. 0."<<endl;
  inp<<"  "<<endl;
  inp<<" ***material"<<endl;
  inp<<"   *this_file"<<endl;
  inp<<"  "<<endl;
  inp<<"%***ZCRACKS***"<<endl;

  inp<<"  "<<endl;

  inp<<"%***ZCRACKS***"<<endl;
  inp<<"  "<<endl;
  inp<<" ***output"<<endl;
  inp<<"  **save_parameter"<<endl;
  inp<<"  **save_all_variables"<<endl;
  inp<<"  "<<endl;
  inp<<"****return"<<endl;
  inp<<"  "<<endl;
  inp<<"***behavior linear_elastic"<<endl;
  inp<<" **elasticity"<<endl;
  inp<<"   young 210000."<<endl;
  inp<<"   poisson 0.3"<<endl;
  inp<<" **coefficient"<<endl;
  inp<<"   masvol 7.8e-09"<<endl;
  inp<<"***return"<<endl;
  inp<<"  "<<endl;

  inp.close();
  update_PROPAG();
}

int write_HS()
{ ASCII_FILE inp;
  Zfstream out;
  int i,inpok;
  STRING cmd;

  out.open(sane_name+"_HOTSPOT.inp",ios::out);
  out.setf(ios::scientific);

  inp.open((sane_name+".inp"));
  cmd = inp.getline();
  inpok=0;
  if(inp.ok) {
    for(i=0;i>=0;i++) {
      inp.back();
      cmd = inp.getline();
      if(!inp.ok) break;
      if(cmd.locate("****return")) {
        inpok=1;
        break;
        inp.close();
      }
      if(cmd.locate("*Heading")) {
        inpok=0;
        break;
        inp.close();
      }
    }
    if(inpok) { 
      inp.open((sane_name+".inp"));
      cmd = inp.getline();
      inpok=inp.ok;
    } else {
      inp.open(("IMPORT-new.inp"));
      cmd = inp.getline();
      inpok=inp.ok;
    }
  }
  
  if(!inpok) {
     inp.close();
     out<<"%---------------------------------------------------------------  "<<endl;
     out<<"% Calcul - HOTSPOT computation (must be filled with loading)   | "<<endl;
     out<<"%---------------------------------------------------------------  "<<endl;
     out<<endl;
     out<<"****calcul"<<endl;
     out<<"  "<<endl;
     out<<" ***mesh"<<endl;
     out<<"  **file "<<sane_name<<".geo"<<endl;
     out<<"  "<<endl;
     out<<" ***resolution"<<endl;
     out<<"  %**cycles 500"<<endl;
     out<<"  % *dtime 1. 1."<<endl;
     out<<"  **sequence"<<endl;
     out<<"   *time 1."<<endl;
     out<<"   *increment 1"<<endl;
     out<<"   *ratio automatic .01"<<endl;
     out<<"  "<<endl;
     out<<" ***bc"<<endl;
     if(bc_conditions!="") out<<bc_conditions<<endl;
     else {
       out<<"  **impose_nodal_dof"<<endl;
       out<<"    ..."<<endl;
     }
     out<<"  "<<endl;
     out<<" ***table"<<endl;
     out<<"  **cycle cycle_load 0. 200."<<endl;
     out<<"   *time 0. 1. 2."<<endl;
     out<<"   *value 0. 1. 0."<<endl;
     out<<"  "<<endl;
     out<<" ***material"<<endl;
     out<<"   *this_file"<<endl;
     out<<"  "<<endl;
     out<<" ***output"<<endl;
     out<<"  **save_parameter"<<endl;
     out<<"  **save_all_variables"<<endl;
     out<<"  "<<endl;
     out<<"****return"<<endl;
     out<<"  "<<endl;
     out<<"***behavior linear_elastic"<<endl;
     out<<" **elasticity"<<endl;
     out<<"   young 210000."<<endl;
     out<<"   poisson 0.3"<<endl;
     out<<" **coefficient"<<endl;
     out<<"   masvol 7.8e-09"<<endl;
     out<<"***return"<<endl;
     out<<"  "<<endl;
     out<<"%***ZCRACKS***"<<endl;
     out<<"  "<<endl;
     out<<"%***ZCRACKS***"<<endl;
     out<<"  "<<endl;

  } else {
     inp.back();
     for(i=0;i>=0;i++) {
        cmd = inp.getline();
        if(!inp.ok) break;
        else if(cmd.locate("***mesh")) {
           out<<cmd<<endl;
           cmd = inp.getline();
           out<<"    **file "<<sane_name<<".geo"<<endl;
        } else if(cmd.locate("***resolution")) {
           out<<cmd<<endl;
           out<<"  %**cycles 500"<<endl;
           out<<"  % *dtime 1. 1."<<endl;
        } else if(cmd.locate("***material")) {
           out<<"  %***table"<<endl;
           out<<"  %**cycle cycle_load 0. 200."<<endl;
           out<<"  %*time 0. 1. 2."<<endl;
           out<<"  %*value 0. 1. 0."<<endl;
           out<<cmd<<endl;
        }
        else if(cmd.locate("****return")) {
           out<<cmd<<endl;
           out<<"  "<<endl;
           out<<"%***ZCRACKS***"<<endl;
           out<<"  "<<endl;
           out<<"%***ZCRACKS***"<<endl;
        }
        else out<<cmd<<endl;
     }
     inp.close(); 
  }
  out.close();

  return(update_HS());
}

int write_SIF()
{ ASCII_FILE inp;
  Zfstream out;
  int i,inpok;
  STRING cmd;
  double h2;

  h2=2.*hmin;
  out.open(cracked_name+"_SIF.inp",ios::out);
  out.setf(ios::scientific);

  inp.open((sane_name+".inp"));
  cmd = inp.getline();
  inpok=0;
  if(inp.ok) {
    inp.back();
    for(i=0;i>=0;i++) {
      cmd = inp.getline();
      if(!inp.ok) break;
      if(cmd.locate("****return")) {
        inpok=1;
        inp.close();
        break;
      }
      if(cmd.locate("*Heading")) {
        inpok=0;
        inp.close();
        break;
      }
    }
    if(inpok) {
      inp.open((sane_name+".inp"));
      cmd = inp.getline();
      inpok=inp.ok;
    } else {
      inp.open((sane_name+"_HOTSPOT.inp"));  
      cmd = inp.getline();
      inpok=inp.ok;
      if(!inpok) {
        inp.open(("IMPORT-new.inp"));
        cmd = inp.getline();
        inpok=inp.ok;
      }
    }
  }

  if(!inpok) {

     out<<"%-----------------------------------------------------------  "<<endl;
     out<<"% Calcul - SIF computation (must be filled with loading)   | "<<endl;
     out<<"%-----------------------------------------------------------  "<<endl;
     out<<endl;
     out<<"****calcul"<<endl;
     out<<"  "<<endl;
     out<<" ***mesh"<<endl;
     out<<"  **file "<<cracked_name<<".geo"<<endl;
     out<<"  "<<endl;
     out<<" ***resolution"<<endl;
     out<<"  %**cycles 500"<<endl;
     out<<"  % *dtime 1. 1."<<endl;
     out<<"  **sequence"<<endl;
     out<<"   *time 1."<<endl;
     out<<"   *increment 1"<<endl;
     out<<"   *ratio automatic .01"<<endl;
     out<<"   *algorithm p1p2p3"<<endl;
     out<<"  "<<endl;
     out<<" ***bc"<<endl;
     if(bc_conditions!="") out<<bc_conditions<<endl;
     else {
       out<<"  **impose_nodal_dof"<<endl;
       out<<"    ..."<<endl;
     }
     out<<"  "<<endl;
     out<<" ***table"<<endl;
     out<<"  **cycle cycle_load 0. 200."<<endl;
     out<<"   *time 0. 1. 2."<<endl;
     out<<"   *value 0. 1. 0."<<endl;
     out<<"  "<<endl;
     out<<" ***material"<<endl;
     out<<"   *this_file"<<endl;
     out<<"  "<<endl;
     out<<"%***ZCRACKS***"<<endl;
     out<<"  "<<endl;
     out<<"%***ZCRACKS***"<<endl;
     out<<"  "<<endl;
     out<<" ***output"<<endl;
     out<<"  **save_parameter"<<endl;
     out<<"  **save_all_variables"<<endl;
     out<<"  "<<endl;
     out<<"****return"<<endl;
     out<<"  "<<endl;
     out<<"***behavior linear_elastic"<<endl;
     out<<" **elasticity"<<endl;
     out<<"   young 210000."<<endl;
     out<<"   poisson 0.3"<<endl;
     out<<" **coefficient"<<endl;
     out<<"   masvol 7.8e-09"<<endl;
     out<<"***return"<<endl;
     out<<"  "<<endl;

  } else {
     inp.back();
     for(i=0;i>=0;i++) {
        cmd = inp.getline();
        if(!inp.ok) break;
        else if(cmd.locate("***mesh")) {
           out<<cmd<<endl;
           cmd = inp.getline();
           out<<"    **file "<<cracked_name<<".geo"<<endl;
        } else if(cmd.locate("***resolution")) {
           out<<cmd<<endl;
           out<<"  %**cycles 500"<<endl;
           out<<"  % *dtime 1. 1."<<endl;
        } else if(cmd.locate("***material")) {
           out<<"  %***table"<<endl;
           out<<"  %**cycle cycle_load 0. 200."<<endl;
           out<<"  %*time 0. 1. 2."<<endl;
           out<<"  %*value 0. 1. 0."<<endl;
           out<<cmd<<endl;
        }
        else if(cmd.locate("****return")) {
           out<<"  "<<endl;
           out<<"%***ZCRACKS***"<<endl;
           out<<"  "<<endl;
           out<<"%***ZCRACKS***"<<endl;
           out<<"  "<<endl;
           out<<cmd<<endl;
        }
        else out<<cmd<<endl;
     } 
     inp.close(); 
  }
  out.close();

  return(update_SIF());
}

int update_PROPAG()
{ 
  Zfstream inp;
  ASCII_FILE file,ppropag_law;
  STRING str;
  int i,ret,irs,nb_iters=nb_iter+1;
  double filt2=10.*filter_tol;
  double new_h=1.1*max_h,max_h3=.5*elset_radius;
  double rext_dist=ext_dist*10.;
  double rmin_size=8.*min_size,
         flip_tol=sqrt(lip_tol*min_size);
  double TIP_radius2=.5*TIP_radius;
  STRING new_elset_name;

  if(if_barsoum && !mat_file && !is_ductile){
    ERROR("\nQuarter nodes elements can not be used in plasticity.\nUncheck \"Quarter nodes\" option and rebuild the cracked mesh.");
  }

  new_elset_name = elset_name;
  if( (new_elset_name != "AUTO") && (elset_radius>0.0) ) new_elset_name = "AUTO"; 

  if(ext_dist<=0.) {
    ext_dist=-min_size;
    rext_dist=-ext_dist*10.;
  }

  file.open(cracked_name+"_PROPAG.inp");
  if(!file.ok) { 
    STD_CP((cracked_name+"_SIF.inp"),(cracked_name+"_PROPAG.inp"));
    write_PROPAG(); 
    return(update_PROPAG());
  }
  inp.open(cracked_name+"_PROPAG2.inp",ios::out);
  inp.setf(ios::scientific);
  for(i=1;i>0;i++) { 
    str=file.getfullline();
    if(!file.ok) return(1);
    if(str.start_with("%***ZCRACKS***"))
      break;
    inp<<str<<endl;
  }
  for(i=1;i>0;i++) { 
    str=file.getfullline();
    if(!file.ok) return(1);
    if(str.start_with("%***ZCRACKS***"))
      break;
  }
  inp<<"%***ZCRACKS***"<<endl;

  // Chose Z8 output format
  inp<<" ***global_parameter"<<endl;
  inp<<"    Solver.OutputFormat  Z8"<<endl;
  inp<<"    Zmaster.OutputFormat Z8"<<endl;
   
  if(if_2DE)
    inp<<" ***shell "<<cop_cmd<<cracked_name<<"_TO_REMESH_2D_ini.geo "<<cracked_name<<"_TO_REMESH_2D.geo "<<endl;

  if(if_contact) {
    inp<<"  ***bsets_contact"<<endl;
    inp<<"   **sides SIDE0 SIDE1"<<endl;
    inp<<"   **stiffness 1.e8"<<endl;
  }

  for(i=0;i<1;i++) {
    inp<<" ***compute_G_by_gth FRONT"<<i<<endl;
    inp<<"  **crack_front FRONT"<<i<<endl;
    inp<<"  **nbnodes "<<nb_fnodes<<endl;
    if(gth_radius>0.) inp<<"  **theta "<<gth_radius<<" 0."<<endl;
    else if(TIP_radius>0.) {
      inp<<"  **TIP "<<TIP_radius<<endl;
      inp<<"  **theta "<<TIP_radius2<< " 0."<<endl;
    } else inp<<"  **elem_radius "<<nb_velem<<endl;
    inp<<"  **elset "<<new_elset_name<<endl;
    inp<<"  **lip lip"<<endl;
    // inp<<"  **hmin "<<hmin<<endl;
    inp<<"  **h "<<max_h<<endl;
    if(nb_pt>0)
      inp<<"  **nb_output_pt "<<nb_pt<<endl;
    if(if_K) 
      inp<<"  **compute_K"<<endl;
    if(if_Ki) 
      inp<<"  **compute_Ki"<<endl;
    if(if_Gmax) { 
      if(if_Ki) {
        if(if_K) inp<<"  **optim_dir 1. 1."<<endl;
        else inp<<"  **vectorial"<<endl;
      } else inp<<"  **vectorial"<<endl;
    }
    if(if_ebe) 
      inp<<"  **excludeBE"<<endl;
    if(n_length>0)
      inp<<"  **print_front "<<n_length<<endl;
    // If a propagation law file exist use it instead of Paris law
    ppropag_law.open(sane_name+".plw");
    if(ppropag_law.ok) {
      while(1) {
        str=ppropag_law.getfullline();
        if(!ppropag_law.ok) break;
        inp<<str<<endl;
      } 
      ppropag_law.close();
    } else {
      if(1) { 
        inp<<"  **fatigue "<<fatigue_Ti<<" "<<fatigue_DT<<endl;
        inp<<"  **C "<<paris_C()<<endl;
        inp<<"  **m "<<paris_m()<<endl;
        inp<<"  **Delta_N "<<paris_DN<<endl;
      } else ERROR("Only fatigue crack growth is supported");
    }
  } 
  inp<<"  "<<endl;

  // DG for quad near front
  if(if_quad*quad_opt) {
    inp<<" ***equation"<<endl;
    inp<<"  **unshared_middle_nodes"<<endl;
    inp<<"  "<<endl;
  }

  // Remeshing part
  inp<<" ***auto_remesh"<<endl;
  inp<<"  **each_incr"<<endl;
  inp<<"  **no_deform_mesh %assumed in order properly propagates"<<endl; 
  if(!if_transfert) {
    inp<<"  **skip_integ_transfer"<<endl;
    inp<<"  **skip_nodal_transfer"<<endl;
  } else {
    inp<<"  **integ_var_transfer default"<<endl;
    inp<<"   *locator bb_tree"<<endl;
    inp<<"   *integ_transfer nearest_gp"<<endl;
    if(elset_names!="")
      inp<<"   *elset_by_elset "<<elset_names<<endl;
    inp<<"   **dont_use_deformed_mesh"<<endl;
  }
  inp<<"  "<<endl;

  inp<<"  **save TO_REMESH.geo"<<endl;
// New version automatic remeshing test process

  if(before_remeshing!="") inp<<endl<<before_remeshing<<endl;

  inp<<"  **drive_crack"<<endl;
  inp<<"   *mesher "<<cracked_name<<"_REMESH.inp"<<endl;
//  inp<<"   *mesher2 "<<cracked_name<<"_SREMESH.inp"<<endl;
  inp<<"   *geo_in TO_REMESH.geo"<<endl;
  inp<<"   *geo_out REMESHED.geo"<<endl;
  inp<<"   *advance "<<cracked_name<<"_PROPAG.adv"<<endl;
  if(if_separate) {
    if(new_version==0) inp<<"   *separate"<<endl;
  }
  //inp<<"   *quality 200."<<endl;
  if(new_version&&if_2D) inp<<"   *no_coarse"<<endl;

  if(after_remeshing!="") inp<<endl<<after_remeshing<<endl;

  inp<<"  **open REMESHED.geo"<<endl;
 
  inp<<"  "<<endl;
  inp<<"%***ZCRACKS***"<<endl;
  for(i=1;i>0;i++) { 
    str=file.getfullline();
    if(!file.ok) 
      break;
    inp<<str<<endl;
  }
  inp.close();
  file.close();

  STD_RM((cracked_name+"_PROPAG.inp"));

  STD_MV((cracked_name+"_PROPAG2.inp"),(cracked_name+"_PROPAG.inp"));
  if(new_version) write_remesh_new(1); // new method
  else do_write_advance_remesh();

  return(0);
}

int do_drive_remesh(double &mquality)
{
  Zfstream inp;
  STRING str;
  int ret;
  double aquality;

  aquality=abs(mquality);
  
  STD_RM((cracked_name+"_DRIVE_REMESH.inp")); 
  STD_RM(("REMESHED.geo")); 
  STD_RM(("AUTO_ADVANCE.geo")); 

  // DRIVE REMESHING FILE
  inp.open(cracked_name+"_DRIVE_REMESH.inp",ios::out);
  inp.setf(ios::scientific);

  inp<<"# Automatic remeshing"<<endl;
  inp<<"****mesher "<<endl;
  inp<<" ***mesh AUTO_ADVANCE.geo"<<endl;

  if(before_remeshing!="") inp<<endl<<before_remeshing<<endl;

  inp<<"  **drive_crack"<<endl;
  inp<<"   *mesher "<<cracked_name<<"_REMESH.inp"<<endl;
  inp<<"   *geo_in TO_REMESH.geo"<<endl;
  inp<<"   *geo_out REMESHED.geo"<<endl;
  inp<<"   *advance "<<cracked_name<<"_PROPAG.adv"<<endl;
  inp<<"   *quality "<<aquality<<endl;
  inp<<"   *min_advance .25"<<endl;
  //if(new_version==1) inp<<"   *no_coarse "<<endl;
  if(if_separate) {
    inp<<"   *separate"<<endl;
  }

  if(after_remeshing!="") inp<<endl<<after_remeshing<<endl;

  inp<<"****return"<<endl; 
  inp.close();

  str=ZRUN_CMD+" -m "+cracked_name+"_DRIVE_REMESH.inp";
  if(mquality>=0.) ret = system(str);

  return ret;  
}


int update_HS()
{ Zfstream inp;
  ASCII_FILE file;
  STRING str;
  int i,ret;

  file.open(sane_name+"_HOTSPOT.inp");
  if(!file.ok) { 
    ret=write_HS(); return(ret); 
    if(!file.ok) return(1);
  } else {
    str=file.getline();
    if(!file.ok) {    
      ret=write_HS(); return(ret);
    } else file.back();
  }
  inp.open(sane_name+"_HOTSPOT2.inp",ios::out);
  inp.setf(ios::scientific);
  for(i=1;i>0;i++) { 
    str=file.getfullline();
    if(!file.ok) return(1);
    if(str.start_with("%***ZCRACKS***"))
      break;
    inp<<str<<endl;
  }
  for(i=1;i>0;i++) { 
    str=file.getfullline();
    if(!file.ok) return(1);
    if(str.start_with("%***ZCRACKS***"))
      break;
  }
  inp<<"%***ZCRACKS***"<<endl;

  inp<<"****post_processing"<<endl;
  inp<<"%"<<endl<<"% Compute Mises and the principal stresses and directions"<<endl<<"%"<<endl;
  inp<<" ***global_post_processing"<<endl;
  inp<<"  **file node"<<endl;
  inp<<"  **nset ALL_NODE"<<endl;
  inp<<"  **process crack_hot_spot"<<endl;
  inp<<"   *radius      "<<hradius<<endl;
  inp<<"   *num         "<<hnumber<<endl;
  inp<<"   *output_file "<<crack_name<<" "<<ra<<endl;
  inp<<"****return"<<endl;

  inp<<"%***ZCRACKS***"<<endl;

  for(i=1;i>0;i++) { 
    str=file.getfullline();
    if(!file.ok) 
      break;
    inp<<str<<endl;
  }
  inp.close();
  file.close();
  
  STD_RM((sane_name+"_HOTSPOT.inp"));

  STD_MV((sane_name+"_HOTSPOT2.inp"),(sane_name+"_HOTSPOT.inp"));

  return(0);
}

int update_SIF()
{ Zfstream inp;
  ASCII_FILE file;
  STRING str;
  int i,ret;
  double TIP_radius2=.5*TIP_radius;
  STRING new_elset_name;

  new_elset_name = elset_name;
  if( (new_elset_name != "AUTO") && (elset_radius>0.0) ) new_elset_name = "AUTO"; 
  
  if(format.end_with("templated")) return update_SIF_templated();

  file.open(cracked_name+"_SIF.inp");
  if(!file.ok) { 
    write_SIF(); 
    ret=update_SIF();
    return(ret);
  }
  inp.open(cracked_name+"_SIF2.inp",ios::out);
  inp.setf(ios::scientific);
  for(i=1;i>0;i++) { 
    str=file.getfullline();
    if(!file.ok) return(1);
    if(str.start_with("%***ZCRACKS***"))
      break;
    inp<<str<<endl;
  }
  for(i=1;i>0;i++) { 
    str=file.getfullline();
    if(!file.ok) return(1);
    if(str.start_with("%***ZCRACKS***"))
      break;
  }
  inp<<"%***ZCRACKS***"<<endl;

if(use_pp==0) {  
  if(if_contact) {
    inp<<"  ***bsets_contact"<<endl;
    inp<<"   **sides SIDE0 SIDE1"<<endl;
    inp<<"   **stiffness 1.e8"<<endl;
  }
  inp<<"  "<<endl;

//  for(i=0;i<nb_fronts;i++) {
  for(i=0;i<1;i++) {
    inp<<" ***compute_G_by_gth FRONT"<<i<<endl;
    inp<<"  **crack_front FRONT"<<i<<endl;
    inp<<"  **nbnodes "<<nb_fnodes<<endl;
    if(gth_radius>0.) inp<<"  **theta "<<gth_radius<<" 0."<<endl;
    else if(TIP_radius>0.) {
      inp<<"  **TIP "<<TIP_radius<<endl;
      inp<<"  **theta "<<TIP_radius2<< " 0."<<endl;
    } else inp<<"  **elem_radius "<<nb_velem<<endl;
    inp<<"  **elset "<<new_elset_name<<endl;
    inp<<"  **lip lip"<<endl;
    //inp<<"  **hmin "<<hmin<<endl;
    if(if_K) 
      inp<<"  **compute_K"<<endl;
    if(if_Ki) 
      inp<<"  **compute_Ki"<<endl;
    if(if_Gmax) { 
      if(if_Ki) {
        if(if_K) inp<<"  **optim_dir 1. 1."<<endl;
        else inp<<"  **vectorial"<<endl;
      } else inp<<"  **vectorial"<<endl;
    }
    if(if_ebe) 
      inp<<"  **excludeBE"<<endl;
    if(n_length>0)
      inp<<"  **print_front "<<n_length<<endl;
    inp<<"  "<<endl;
  }

  // DG for quad near front
  if(if_quad*quad_opt) {
    inp<<" ***equation"<<endl;
    inp<<"  **unshared_middle_nodes"<<endl;
    inp<<"  "<<endl;
  }
}
  inp<<"%***ZCRACKS***"<<endl;

  for(i=1;i>0;i++) { 
    str=file.getfullline();
    if(!file.ok) 
      break;
    inp<<str<<endl;
  }
  inp.close();
  file.close();

  STD_RM((cracked_name+"_SIF.inp"));

  STD_MV((cracked_name+"_SIF2.inp"),(cracked_name+"_SIF.inp"));

  return(0);
}


int open_crack_info()
{ ASCII_FILE file;
  STRING str,field;
  int i,t;
  double x;
 
  file.open(crack_name+crack_id+".dat");
  if(!file.ok) return(2);
  if_ellipse=file.getint();
  if(!file.ok) return(2);
  ra=file.getdouble();
  if(!file.ok) return(2);
  rb=file.getdouble();
  if(!file.ok) return(2);
  center[0]=file.getdouble();
  if(!file.ok) return(2);
  center[1]=file.getdouble();
  if(!file.ok) return(2);
  center[2]=file.getdouble();
  if(!file.ok) return(2);
  normal[0]=file.getdouble();
  if(!file.ok) return(2);
  normal[1]=file.getdouble();
  if(!file.ok) return(2);
  normal[2]=file.getdouble();
  if(!file.ok) return(2);
  dir[0]=file.getdouble();
  if(!file.ok) return(2);
  dir[1]=file.getdouble();
  if(!file.ok) return(2);
  dir[2]=file.getdouble();
  if(!file.ok) return(2);
  
  return(0);
}

void write_mesh_crack()
{ Zfstream inp;
  STRING MG;

  VECTOR NN;
  int i,j,niter,auto_nb_pt;
  double sgradation,dmin;
  double x0,y0,z0,n0,n1,n2;
  dmin=min_size*.5;
  sgradation=gradation;

  auto_nb_pt = (2.*pi*ra/min_size)*10 + 1;

  if(if_meshgems) MG="mesh_gems";
  else MG="yams_ghs3d";
  niter=nb_iter;
  if(niter<0) niter=-niter;

  x0=center[0];
  y0=center[1];
  z0=center[2];
  NN=normal*(1./normal.norm());
  n0=NN[0];
  n1=NN[1];
  n2=NN[2];

  inp.open(crack_name+crack_id+".dat",ios::out);
  inp.setf(ios::scientific);
  inp.precision(64);
  inp<<if_ellipse<<" "<<ra<<" "<<rb<<endl;
  inp<<center[0]<<" "<<center[1]<<" "<<center[2]<<endl;
  inp<<normal[0]<<" "<<normal[1]<<" "<<normal[2]<<endl;
  inp<<dir[0]<<" "<<dir[1]<<" "<<dir[2]<<endl;
  inp.close();

  inp.open(crack_name+".inp",ios::out);
  inp.setf(ios::scientific);
  inp.precision(64);

  inp<<"%-----------------------------------------------------------  "<<endl;
  inp<<"% Mesher - build initial crack surface                     | "<<endl;
  inp<<"%-----------------------------------------------------------  "<<endl;
  inp<<endl;
  inp<<"****mesher"<<endl;
  inp<<" ***mesh "<<crack_name<<".geo"<<endl;
  inp<<"  **build_ellipse"<<endl; 
  inp<<"   *center ( "; for(i=0;i<!center;i++) inp<<center[i]<<" "; inp<<")"<<endl;
  inp<<"   *normal ( "; for(i=0;i<!normal;i++) inp<<NN[i]<<" "; inp<<")"<<endl;
  inp<<"   *dir ( "; for(i=0;i<!dir;i++) inp<<dir[i]<<" "; inp<<")"<<endl;
  if(if_ellipse) {
    inp<<"   *ra "<< ra <<endl;
    inp<<"   *rb "<< rb <<endl;
  } else {
    inp<<"   *r "<< ra <<endl;
  }
  
  if((auto_nb_pt>128))
    inp<<"   *nb_nodes "<<auto_nb_pt<<endl;
  else
    inp<<"   *nb_nodes 128"<<endl;
  inp<<"   *name "<< crack_name <<endl;
  inp<<"   "<<endl;
  for(i=0;i<niter;i++) {
    inp<<"  **nset ORIGIN *use_bset "<<crack_name<<"_front"<< endl;
    inp<<"  **"<<MG<<endl;
    if(yams_prefix!="") { 
      inp<<"  *yams "<<yams_prefix<<"yams"<<endl; 
      inp<<"  *ghs3d "<<yams_prefix<<"ghs3d"<<endl; 
      inp<<"  *meshadapt "<<yams_prefix<<"meshadapt"<<endl; 
    }  

    if(if_meshgems) {
      inp<<"   *options --chordal_error="<<dtoa(.1*min_size)<<" --geometric_approximation_angle=2. "<<yams_options;
      if(i==0) inp << " --remove_bad_input_surface_elements=no ";
      inp<<endl;
    } else inp<<"   *options "<<yams_options<<endl; 
    if(optim_style!="") inp << "   *optim_style "<<optim_style<<endl;
    if((arch==1)&&(!if_meshgems)) inp<<"   *m64"<<endl;
    inp<<"   *binary"<<endl;
    inp<<"   *nb_iter_surf 1"<<endl;
    inp<<"   *yams_only"<<endl;
    inp<<"   *preserve_liset "<<crack_name<<"_front"<< endl;
    inp<<"   *absolu"<<endl;
    if(min_size>0.)
      inp<<"   *min_size "<< dmin <<endl;
    if(gradation>=1.) {
      if(if_czm) inp<<"   *max_size "<< min_size <<endl;
      else {
        gradation=2.;
        refinement(inp);
        gradation=sgradation;
        if(refine_origin!="DATAFILE") inp<<"   *refinement_origin ORIGIN"<<endl;
//        if(if_var_refine) 
//          inp<<"   *liset_front crack_front"<<endl;
        if(max_size>=0.) 
          inp<<"   *max_size "<< max_size <<endl;
      }
    } else file<<"   *refinement "<<min_size<<";"<<endl;
    inp<<"   "<<endl;
  }
  inp<<"  **continuous_liset"<<endl;
  inp<<"   *liset_name crack_front"<<endl;

  // Reproject on coordinates and respect normal
  inp<<"  **function "<<endl;
  inp<<"   *xtrans x-((x-"<<x0<<")*"<<n0<<"+(y-"<<y0<<")*"<<n1<<"+(z-"<<z0<<")*"<<n2<<")*"<<n0<<";"<<endl;
  inp<<"   *ytrans y-((x-"<<x0<<")*"<<n0<<"+(y-"<<y0<<")*"<<n1<<"+(z-"<<z0<<")*"<<n2<<")*"<<n1<<";"<<endl;
  inp<<"   *ztrans z-((x-"<<x0<<")*"<<n0<<"+(y-"<<y0<<")*"<<n1<<"+(z-"<<z0<<")*"<<n2<<")*"<<n2<<";"<<endl;

  inp<<"  **elset "<< crack_name <<endl;
  inp<<"   *function 1.;"<<endl;
  inp<<"   "<<endl;
  inp<<"  **nset "<< crack_name <<endl;
  inp<<"   *function 1.;"<<endl;
  inp<<"   "<<endl;

  inp<<"  **save "<<crack_name<<"_"<<crack_id<<".geo"<<endl;
  inp<<"  **shell "<<cop_cmd<<crack_name<<".inp "<<crack_name<<"_"<<crack_id<<".inp"<<endl;
  inp<<"   "<<endl;
  for(i=0;i<crack_id;i++) {
    inp<<"  **union"<<endl;
    inp<<"   *add "<<crack_name<<"_"<<i<<".geo"<<endl;
    inp<<"   *append_id" <<endl;
    if(max_node_id>0) inp<<"   *from_node "<<max_node_id<<endl;
    if(max_ele_id>0)  inp<<"   *from_element "<<max_ele_id<<endl;
    inp<<"   *tolerance 0."<< endl;
    inp<<"   "<<endl;
  }

  if((sane_name!="")&&(sane_name!="none")) {
    inp<<" ***mesh "<<sane_name<<"_CRACKI.geo"<<endl;
    inp<<"  **open "<<sane_name<<endl;
    inp<<"  **quad_to_lin"<<endl;
    if(if_2D) inp << "  **to_3d"<<endl; 
    inp<<"  **union *add "<<crack_name<<".geo *append_id";
    if(max_node_id>0) inp<<" *from_node "<<max_node_id;
    if(max_ele_id>0)  inp<<" *from_element "<<max_ele_id;
    inp<<" *tolerance 0."<<endl;
    inp<<"  **bset _CRACK_ *use_nset "<<crack_name<<endl;
    inp<<"  **"<<MG<<endl;

    if(optim_style!="") inp << "   *optim_style "<<optim_style<<endl;
    if((arch==1)&&(!if_meshgems)) inp<<"   *m64"<<endl;
    inp<<"   *yams_only *preserve_faset _CRACK_ *yams copy"<<endl;
    inp<<"   *preserve_liset "<<crack_name<<"_front"<< endl;
  }

  inp<<"****return"<<endl;
  inp.close();

}

STRING gauge(int nmax,STRING &message)
{
  STRING out;
  
  nmax=(nmax/68)+1;
  cout<<message<<endl;
  cout<<"0%=============================================================100%"
      <<endl<<flush;
  out=" | awk '/.*/ {I=(I+1); if(I%"+itoa(nmax)+"==0) printf(\"#\")}; END {print \"\";print I}'";

  out="";
  return(out);
}

int do_mesh_crack(int nowait)
{
  int i,ret,lsz,niter;
  double Imin_size,wquality;
  STRING str;
  niter=nb_iter;
  if(niter<0) niter=-niter;
/*
  if(niter==0) lsz=124;
  else if(niter==1) lsz=264;
  else lsz=264+140*(niter-1);
  str=gauge(lsz,"Building crack surface #"+itoa(crack_id)+"...");
*/
 
  cout << "Meshing crack surface..."<<endl<<flush; 
  if(os != "win32") {
     //str= ZRUN_CMD+" -m "+crack_name+".inp | tee MESHING_OUTPUT"+str;
     str= ZRUN_CMD+" -m "+crack_name+".inp >> MESHING_OUTPUT"+str;
/*
     if(embedded!=-1) {
       if(nowait) str=str+" &";
     }
*/
  }
  else  str= ZRUN_CMD+" -m "+crack_name+".inp >> MESHING_OUTPUT"+str;
  STD_RM("MESHING_OUTPUT");
  ret = system(str);
  cout << "Done."<<endl<<flush; 
  return(ret);
}

int do_refine_mesh(int nowait)
{     
  int i,ret,lsz;
  double Imin_size,wquality;
  STRING str;

  if(new_version) {
    STD_RM("TO_REMESH.geo");
    STD_RM("REMESHED.geo");
    STD_RM(cracked_name+"_refined.geo");
    if(nice_refine(100.)<0.) ERROR("\nRemeshing before insert failed!\nCheck wheither the intial mesh contains unconnected parts");
    apply_mesher("REMESHED.geo",cracked_name+"_refined.geo","");
    return(0);
  } 

  if(niter==0) lsz=440;
  else if(niter==1) lsz=640;
  else lsz=620+330*(niter-1);
  if(if_must_define_elset) lsz=lsz+200;
  str=gauge(lsz,"Refining mesh...");
  if(os != "win32") {
     str= del_cmd+cracked_name+"_refined.geo ; Zrun -m "+cracked_name+"_refine.inp | tee MESHING_OUTPUT"+str;
     if(embedded!=-1) {
       if(nowait) str=str+" &";
     }
  }
  else str = ZRUN_CMD+" -m "+cracked_name+"_refine.inp  >> MESHING_OUTPUT"+str;
  STD_RM("MESHING_OUTPUT");
  ret = system(str);
  return(ret);
}

int do_cut_mesh(int nowait)
{
  int i,ret,lsz;
  double Imin_size,wquality;
  STRING str;

  if(n_iter==0) lsz=1500;
  else if(nb_iter==1) lsz=1700;
  else lsz=1700+330*(nb_iter-1);
  if(if_must_define_elset) lsz=lsz+200;
  str=gauge(lsz,"Cutting mesh...");
  if(os != "win32") {
     str= "rm -f "+cracked_name+".geo ; Zrun -m "+cracked_name+"_cut.inp | tee MESHING_OUTPUT"+str;
     STD_RM("MESHING_OUTPUT");
     if(embedded!=-1) {
       if(nowait) str=str+" &";
     }
  }
  else str = ZRUN_CMD+" -m "+cracked_name+"_cut.inp";
  ret = system(str);
  return(ret);
}

double display_quality()
{
  double wquality;
  wquality=check_output("MESHING_OUTPUT");
  cout <<endl<<"Resulting mesh worst element quality:" << wquality << endl <<endl<< flush ;
  return(wquality);
}


void smooth_region(int mode)
{
  Zfstream inp;
  STRING str,MG;
  int i,ret,nb_iters=nb_iter+1;
  double filt2=10.*filter_tol;
  double new_h=1.1*max_h,max_h3=.5*elset_radius,rcoarse=min_size*100.;
  double rext_dist=ext_dist*10.;
  double rmin_size=8.*min_size,
         flip_tol=sqrt(lip_tol*min_size);
  STRING new_elset_name;

  if(if_meshgems) MG="mesh_gems";
  else MG="yams_ghs3d";

  new_elset_name = elset_name;
  if( (new_elset_name != "AUTO") && (elset_radius>0.0) ) new_elset_name = "AUTO"; 

  STD_RM((cracked_name+"_REMESH.inp"));

  // REMESHING FILE
  inp.open(cracked_name+"_REMESH.inp",ios::out);
  inp.setf(ios::scientific);

  
  inp<<"****mesher"<<endl;

  inp<<"****return"<<endl;
  inp.close();

}


// New way to insert or advance
// mode=0 initial insertion
// mode=1 advance
// mode=2 insert new front and remove current extension
// mode=10 refinement only based on datafile or crack position
// mode=11 refinement only + local smoothing for 2D shell only

void write_remesh_new(int mode)
{
  Zfstream inp;
  STRING str,MG, hexa_options;
  int i,ret,niter,nb_iters,f2D;
  double filt2=10.*filter_tol;
  double new_h=1.1*max_h,max_h3=.5*elset_radius,rcoarse=min_size*100.;
  double rext_dist=ext_dist*10.;
  double rmin_size=8.*min_size,
         flip_tol=sqrt(lip_tol*min_size);

  STRING new_elset_name;
  f2D=0;

  hexa_options="";

  if(if_meshgems) MG="mesh_gems";
  else MG="yams_ghs3d";
  niter=nb_iter;
  if(niter<0) niter=-niter;
  nb_iters=niter+1;

  new_elset_name = elset_name;
  if( (new_elset_name != "AUTO") && (elset_radius>0.0) ) new_elset_name = "AUTO"; 

  STD_RM((cracked_name+"_REMESH.inp"));

  // REMESHING FILE
  inp.open(cracked_name+"_REMESH.inp",ios::out);
  inp.setf(ios::scientific);

  // For 2D problem reinit 2D mesh
  if_2DE=if_2D;
  if(if_2DE) {
    if_2DE=(thickness.size()==1);
    if(if_2DE) if_2DE=(thickness[0]==-1.);
    if_2DE=!if_2DE;
  }
   
  inp<<"****mesher"<<endl;

  inp<<" ***shell "<<del_cmd<<cracked_name<<"_TO_REMESH_2DT.geo "<<cracked_name<<"_REMESHED.geo"
                   <<" REMESHED.geo TO_REMESH_QUADID.geo "<< crack_name <<"_PROPAG_COMPO.geo TOCUTMESH.geo"
                   <<" ORIG_MESH_TO_REMESH.geo TO_REASSIGN.geo ELSET_TO_KEEP.geo"<<endl;

  if(elset_to_cut!="") {
    // For the sake of simplicity would be faster if done only on the local remeshing zone 
    inp<<" ***mesh ELSET_TO_KEEP.geo"<<endl;
    inp<<"  **open TO_REMESH.geo"<<endl;
    inp<<"  **elset to_del" << endl;
    inp<<"   *use_elsets ALL_ELEMENT"<<endl;
    inp<<"   *not_in_elsets "<<elset_to_cut<<endl;
    inp<<"  **delete_elset to_del"<<endl;
  }

  if(elset_inside!="") {
    // For shake of simplicity would be faster if done only on the local remeshing zone 
    inp<<" ***mesh ELSET_INSIDE.geo"<<endl;
    inp<<"  **open TO_REMESH.geo"<<endl;
    inp<<"  **elset to_del" << endl;
    inp<<"   *use_elsets ALL_ELEMENT"<<endl;
    inp<<"   *not_in_elsets "<<elset_inside<<endl;
    inp<<"  **delete_elset to_del"<<endl;
  }

  if(if_2D) {
    inp<<" ***mesh "<<cracked_name<<"_TO_REMESH_2DT.geo"<<endl;
    if(if_2DE) {
      inp<<"  **open "<<cracked_name<<"_TO_REMESH_2D.geo"<<endl;
      if(mode==11) {
        // VC A VOIR...
        // Update local remeshing zone
        inp<<"  **elset_near_nset"<<endl;
        inp<<"   *elset SMOOTHED_"<<new_elset_name<<endl;
        if(refinement_datafile!="") inp<< "   *refine_file "<<refinement_datafile<<endl;
        else if(crack_name!="") {
          inp<<"   *nset "<<crack_name<<endl;
        } else if((refine_origin!="DATAFILE")&&(refine_origin!="")) {
          inp<<"   *nset "<<refine_origin<<endl;
        }
        inp<<"   *radius "<<smooth_elset_radius<<endl;

        inp<<"  **save "<<cracked_name<<"_TO_REMESH_2D.geo"<<endl;
      }
    }
    else inp<<"  **open TO_REMESH.geo"<<endl;

    if(bset_to_elset!="") {
      inp<<"  **bset_to_elset *reverse *bsets "<<bset_to_elset<<" *elsets "<<bset_to_elset<<endl;
    } else if((faset_names=="")&&(elset_names!="")) {
      faset_names=elset_names;
      f2D=1;
      inp<<"  **bset_to_elset *reverse *bsets "<<elset_names<<" *elsets "<<elset_names<<endl;
    }

  } else {
    if(if_must_define_elset) inp<<" ***mesh "<<cracked_name<<"_REMESHED.geo"<<endl;
    else                     inp<<" ***mesh REMESHED.geo"<<endl;
    inp<<"  **open TO_REMESH.geo"<<endl;
  }

  if((mode==1)&&(branches_base_front.size()>0)) {
    inp<<endl;
    for(i=0;i<branches_base_front.size();i++) {
      str="FRONT"+itoa(branches_base_front[i]);
      ret=branches_number[i];
      if(if_2D) {
        inp<<"  **remove_set *nsets "<<str<<"_"<<ret<<endl;
        inp<<"  **nset "<<str<<"_"<<ret<<" *use_nset "<<str<<endl;
      } else {
        inp<<"  **remove_set *bsets "<<str<<"_"<<ret<<endl;
        inp<<"  **join_bsets "<<str<<"_"<<ret<<" *bsets "<<str<<endl;
      }
    }
    inp<<endl;
  }
 
  if(set_reduced){
    inp<<"  **to_c3d13"<<endl;
  }

  inp<<"  **degenerated_cleaner"<<endl;
  
  if(((mode==0) || (mode==10) || (mode==1))*from_quad*!(if_quad)) {
    inp<<"  **quad_to_lin"<<endl;
  }

  if(if_quad*(!if_must_define_elset)) {
    if(!if_2DE) {
       inp<<"  **quad_to_lin"<<endl;
       if(quad_opt) inp<<"   *elset QUAD"<<endl;
       inp<<"  "<<endl;
    }
  }

  if(if_czm) {
/*
    // Fuse interface nodes en remove elset
    inp<<"  **remove_set *nsets CZM_nodes"<<endl;
    inp<<"  **nset CZM_nodes *use_elset INTERFACE *function 1.;"<<endl;
    inp<<"  **fuse_nset"<<endl;
    inp<<"   *skip_reassign_numbers"<<endl;
    inp<<"   *cleanup_mesh"<<endl;
    inp<<"   *cleanup_nset CZM_nodes"<<endl;
    inp<<"   *tolerance 2.e-7"<<endl;
    inp<<"   *iterate"<<endl;
    inp<<"   *relative"<<endl;
    inp<<"  **remove_set *nsets CZM_nodes"<<endl;
*/
    inp<<"  **delete_elset INTERFACE"<<endl;
    inp<<"  **degenerated_elset *elset DEGENERATED_ELEMENTS"<<endl;
    inp<<"  **delete_elset DEGENERATED_ELEMENTS"<<endl;
  }

  if(if_2D) {
    inp<<"  **to_3d"<<endl;
    // inp<<"  **quad_to_tri"<<endl;
    if(if_must_define_elset) inp<<" ***mesh "<<cracked_name<<"_REMESHED.geo"<<endl;
    else                     inp<<" ***mesh REMESHED.geo"<<endl;
    inp<<"  **open "<<cracked_name<<"_TO_REMESH_2DT.geo"<<endl;
  } else if(mode!=1) {
    // Create bset SURFACE 
    inp<<"  **remove_set *bsets SURFACE _SURFACE *nsets SURFACE"<<endl;
    inp<<"  **unshared_faces _SURFACE"<<endl;
    inp<<"  **join_bsets SURFACE *bsets _SURFACE SIDE0 SIDE1 *remove *remove_duplicates" <<endl;
    inp<<"  **remove_set *bsets _SURFACE"<<endl;
  }

  if(if_must_define_elset) {
    inp<<"  **remove_set *elsets "<<new_elset_name<<"_OLD "<<new_elset_name<<"_AUTO" <<endl;
    if(new_elset_name!="AUTO") {
      inp<<"  **elset "<<new_elset_name<<"_OLD"<<endl;
      inp<<"   *use_elsets "<<new_elset_name<<endl;
      inp<<"   *function 1.;"<<endl;
    }
    inp<<"  **remove_set"<<endl;
    inp<<"   *elsets "<<new_elset_name<<"_EXT AUTOEXT ";
//  moving elset becomes growing elset, which adds new elements into it when the FRONT advances
    if((elset_radius>0.)&&(if_moving_elset)&&(!if_growing_elset)) inp<<new_elset_name<<" ";
    inp<<endl;
    inp<<"   *nsets INTER_EXT INTER_INT INTER_SURFACE0 INTER_SURFACE"<<endl;
    inp<<"   *bsets INTER_EXT INTER_INT INTER_SURFACE0 INTER_SURFACE INTER_SRF"<<endl; 
    inp<<"   "<<endl;
    if((elset_radius>0.)&&(if_moving_elset||(mode!=1))) { // else assume only given elset is cut
      if((mode==0)||((mode==10)&&(refinement_datafile=="")&&(if_refine_only==0))&&(crack_name!="")) {
         inp<<"  **union"<<endl;
         inp<<"    *add "<<crack_name<<" *tolerance 0. *elset TODEL_CRACK"<<endl;
         inp<<"    *append_id"<<endl;
         if(max_node_id>0) inp<<"   *from_node "<<max_node_id<<endl;
         if(max_ele_id>0)  inp<<"   *from_element "<<max_ele_id<<endl;
      }
      inp<<"  **elset_near_nset"<<endl;
//      inp<<"   *all_in"<<endl;
      inp<<"   *elset "<<new_elset_name<<endl;
      if(mode>=1) {
        if((mode==10)||(mode==11)) {
          if(refinement_datafile!="") inp<< "   *refine_file "<<refinement_datafile<<endl;
          else if(crack_name!="") {
            inp<<"   *nset "<<crack_name<<endl;
          } else if((refine_origin!="DATAFILE")&&(refine_origin!="")) {
            inp<<"   *nset "<<refine_origin<<endl;
          }
        } else {
          // Based on advance file
          inp<<"   *advance_file "<<cracked_name<<"_PROPAG.adv"<<endl;
          inp<<"   *nset FRONT"<<endl;
          inp<<"   *connect"<<endl;
          if(!if_growing_elset) inp<<"   *mesh_size_auto"<<endl;
        }
      } else inp<<"   *nset "<<crack_name<<endl; 
      inp<<"   *radius "<<elset_radius<<endl;
      if(elset_name != "AUTO") {
         inp<<"   *restricted_to "<<elset_name<<endl;
      }
      if(mode!=1) inp<<"  **delete_elset TODEL_CRACK"<<endl;
      inp<<"  **remove_set *elsets "<<new_elset_name<<"_PREV"<<endl;
    }

    // Simple algo
    inp<<"  **elset "<< new_elset_name << "_EXT" << endl;
    inp<<"   *use_elsets ALL_ELEMENT"<<endl;
    inp<<"   *not_in_elsets "<<new_elset_name<<endl;

    if(if_2D) {
      inp<<"  **unshared_edges INTER_INT *elsets "<< new_elset_name << endl;
      inp<<"  **unshared_edges INTER_EXT *elsets "<< new_elset_name << "_EXT" <<endl;
    } else {
      inp<<"  **unshared_faces INTER_INT *elsets "<< new_elset_name << endl;
      inp<<"  **unshared_faces INTER_EXT *elsets "<< new_elset_name << "_EXT" <<endl;
    }
    inp<<"  **join_bsets INTER_SURFACE0"<<endl;
    inp<<"   *intersection"<<endl;
    inp<<"   *bsets INTER_EXT INTER_INT"<<endl;
    inp<<"   *remove_duplicates"<<endl;
 
    if(if_quad) {
       inp<<"  **save TO_REMESH_QUADID.geo"<< endl;
/*       if(!if_2DE) { */
          inp<<"  **quad_to_lin"<<endl;
          //if(quad_opt) inp<<"   *elset QUAD"<<endl;
          inp<<"  "<<endl;
/*       } */
    }
    inp<<"  **save TO_REMESH_COMPO.geo"<< endl;
    inp<<"  **delete_elset "<<new_elset_name<<"_EXT"<<endl;
    inp<<"  **save TO_REASSIGN.geo"<< endl;
    if(!if_2D) {
      inp<<"  **elset AUTOEXT"<<endl;
      inp<<"   *attached_to_nset INTER_SURFACE0"<<endl;
      inp<<"  **unshared_faces INTER_SURFACE"<<endl;
      inp<<"   *elsets AUTOEXT"<<endl;
      inp<<"  **join_bsets INTER_SRF"<<endl;
      inp<<"   *intersection"<<endl;
      inp<<"   *bsets SURFACE INTER_SURFACE"<<endl;
      inp<<"   *remove_duplicates"<<endl;

      inp<<"  **remove_set *bsets INTER_SURFACE *elsets AUTOEXT *nsets INTER_SURFACE0"<<endl;

      inp<<"  **join_bsets INTER_SURFACE"<<endl;
      inp<<"   *bsets INTER_SURFACE0 INTER_SRF"<<endl;
      inp<<"   *remove_duplicates"<<endl;
      inp<<"  **remove_set *bsets INTER_SURFACE0 INTER_SRF"<<endl;
    } else inp<<"  **rename_set *bsets INTER_SURFACE0 INTER_SURFACE"<<endl;
  } else { //if(mode==1) {
    if(elset_name=="AUTO") {
      inp<<"  **remove_set *elsets AUTO"<<endl;
      inp<<"  **elset AUTO *function 1.;"<<endl;
    }
    inp<<"  **save TO_REASSIGN.geo"<< endl;
  }

/*
  if(if_2DE) {
    inp<<"  **union *add TO_REMESH.geo *append_id ";
    if(max_node_id>0) inp<<" *from_node "<<max_node_id;
    if(max_ele_id>0)  inp<<" *from_element "<<max_ele_id;
    inp<<" *elset TO_SUPPR "<<endl;
    if(filter_tol>0.) { inp<<"   *tolerance 2.e-7"<<endl; }
  }
*/

  inp<<"  **remove_set"<<endl;
  inp<<"   *elsets crack_surface"<<endl;
  inp<<"   *bsets FRONTS_INI FRONTS_AUTO"<<endl;
  inp<<"   *nsets FRONTS_INI FRONTS_INI2 FRONTS_AUTO FRONTS_CORNER"<<endl;
  inp<<endl;

  // Keep initial fronts
  inp<<"  **nset_intersection \n   *intersection_name FRONTS_INI\n      *nsets SIDE0 SIDE1"<<endl;

  inp<<"  **bset FRONTS_INI"<<endl;
  inp<<"   *use_nset FRONTS_INI"<<endl;
//  inp<<"   *use_bset "<<endl;
//  for(i=0;i<nb_fronts;i++) inp<<" FRONT"<<i;
  inp<<endl;
  inp<<"   *use_dimension 1 *no_sort"<<endl;

  inp<<"  **nset FRONTS_INI"<<endl;
  inp<<"   *use_bset FRONTS_INI"<<endl;

  inp<<"  **remove_set *nsets NMV_FRONT" <<endl; 

  // New approach
  inp<<"  **shell "<<del_cmd<<" TOCUTMESH.geo"<<endl;
  inp<<"  **elset TOCUTMESH"<<endl;
  inp<<"   *function 1.;"<<endl;
 
  // Set if insertion or advance
  if(mode==1) {
    // Advance
    inp<<"  **front_advance"<<endl;
    if(if_front_check) inp<<"   *front_check"<<endl; // FOR MICHELIN BUG!!
    inp<<"   *file "<<cracked_name<<"_PROPAG.adv"<<endl;
    inp<<"   *nset Nlip"<<endl;
    inp<<"   *dep_min .01"<<endl;
    inp<<"   *h "<<min_size<<endl;
    if(if_2D) {
      // if(if_2DE) inp<<"   *volume TO_SUPPR"<<endl; 
    } else { 
      if(elset_to_cut!="") inp << "   *volume "<<elset_to_cut<<endl;
      else inp<<"   *volume "<<new_elset_name<<endl; 
      inp<<"   *ext_dist "<<ext_dist<<endl;
      if(!if_ext) inp<<"   *project"<<endl;
    }
    if(if_dislo) {
      inp <<"   *dislocation *nset"<<endl;
      inp <<"   *crystal"<<endl;
    }
    if(non_local) inp<<"   *force_mesh"<<endl;
    inp<<"   *coalescing "<<fuse_length<<endl;
    inp<<"  "<<endl;
  } else {
    // Insertion add crack
    //if((mode==0)||((mode==10)&&(refinement_datafile=="")&&(if_refine_only==0))&&(crack_name!="")) 
    //if((refinement_datafile=="")&&(if_refine_only==0)&&(crack_name!="")) {
    if((if_refine_only==0)&&(crack_name!="")&&(mode!=10)&&(mode!=11)) {
      if(mode==2)  {
//        inp<<"  **union *add "<<crack_name<<" *append_id"<<endl;
        inp<<"  **remove_set *nsets CZM_SEED"<<endl;
        inp<<"  **nset CZM_SEED *use_nset FRONT"<<endl;
      }
      else inp<<"  **union *add "<<crack_name<<".geo *append_id *tolerance 0."<<endl;
    }
  }

  inp<<"  **save TOCUTMESH.geo"<<endl;

  // if(if_2DE) inp<<"  **delete_elset TO_SUPPR"<<endl;

  inp<<"  **delete_elset TOCUTMESH"<<endl;  
  
  //if((!if_2D)&&(mode==1)) {
  if(0) {
    inp<<""<<endl;
    inp<<"  **unshared_edges EXT"<<endl;
    inp<<"  **remove_set *nsets FRONTS_INI"<<endl;
    inp<<"  **rename_set *bsets FRONTS_INI FRONTS_INI0"<<endl;
    inp<<"  **save ORIG_MESH_TO_REMESH.geo"<<endl;
    inp<<"  **rename_set *bsets FRONTS_INI0 FRONTS_INI"<<endl;
    inp<<""<<endl;
    inp<<"  **"<<MG<<endl;
    inp<<"   *yams_only"<<endl;
    inp<<"   *binary"<<endl;
    if((arch==1)&&(!if_meshgems)) inp<<"   *m64"<<endl;
    inp<<"   *yams_only"<<endl;
    if(if_meshgems) inp<<"   *options --remove_bad_input_surface_elements yes --use_surface_proximity yes --use_volume_proximity yes --create_nodes_on_flat_edge yes "<<endl;
    else inp<<"   *options -FEM -nr -nm"<<endl;
    inp<<"   *preserve_topo FRONTS_INI"<<endl;
    inp<<"   *preserve_liset FRONTS_INI"<<endl;
    inp<<"   *preserve_nset EXT"<<endl;
    inp<<""<<endl;
    inp<<"  **"<<MG<<endl;
    inp<<"   *yams_only"<<endl;
    inp<<"   *binary"<<endl;
    if((arch==1)&&(!if_meshgems)) inp<<"   *m64"<<endl;
    inp<<"   *preserve_topo FRONTS_INI"<<endl;
    inp<<"   *preserve_liset FRONTS_INI"<<endl;
    inp<<"   *preserve_nset EXT"<<endl;
    inp<<""<<endl;
    inp<<"  **union *add ORIG_MESH_TO_REMESH.geo *tolerance 0.  *elset TODEL *append_id *allow_empty_mesh"<<endl;
    inp<<"  **shell "<<del_cmd<<" ORIG_MESH_TO_REMESH.geo"<<endl;
    inp<<""<<endl;
    inp<<"  **fuse_nset"<<endl;
    inp<<"   *skip_reassign_numbers"<<endl;
    inp<<"   *cleanup_mesh"<<endl;
    inp<<"   *cleanup_nset FRONTS_INI"<<endl;
    inp<<"   *exclude_nset FRONTS_INI0"<<endl;
    inp<<"   *impose_exclude_fuse"<<endl;
    inp<<"   *tolerance 2.e-7"<<endl;
    inp<<"   *relative"<<endl;
    inp<<""<<endl;
    inp<<"  **delete_elset TODEL"<<endl;
  }
 
  // Convert current mesh to mesh surface for external cutting
  if(mode!=2) {
    inp<<""<<endl;
    inp<<"  **shell "<<del_cmd<<" _mesh_out_.mesh"<<endl;
    inp<<"  **shell "<<del_cmd<<" crack.mesh"<<endl;
    inp<<"  **"<<MG<<endl;
    inp<<"   *yams_only"<<endl;
    if((arch==1)&&(!if_meshgems)) inp<<"   *m64"<<endl;
    if(mode>=1) inp<<"   *preserve_nset FRONTS_INI"<<endl;
    inp<<"   *yams_only"<<endl;
    inp<<"   *yams copy"<<endl;
    inp<<""<<endl;
    inp<<"  **shell "<<cop_cmd<<" _mesh_out_.mesh crack.mesh"<<endl;
  }

  if(if_must_define_elset) {
    inp<<" ***mesh "<<cracked_name<<"_REMESHED.geo"<<endl;
    inp<<"  **shell "<<del_cmd<<" "<<cracked_name<<"_REMESHED.geo"<<endl;
  } else {
    inp<<" ***mesh REMESHED.geo"<<endl;
    inp<<"  **shell "<<del_cmd<<" REMESHED.geo"<<endl;
  }
  inp<<"  **open TOCUTMESH.geo"<<endl;
  inp<<"  **elset todel *not_in_elset TOCUTMESH"<<endl;
  inp<<"  **delete_elset todel"<<endl;
  inp<<"  **save TOCUTMESH.geo"<<endl;

  inp<<"  **remove_set"<<endl;
  inp<<"   *nsets lip NSURF_NODES";
  for(i=0;i<nb_fronts;i++) inp<<" FRONT"<<i;
  inp<<endl;
  inp<<"  **remove_set *bsets OLDlip"<<endl;

  inp<<"  **elset to_del *function 1.;" << endl;

  inp<<"  **remove_set *bsets SKINAUTO"<<endl;
  if(if_2D)  inp<<"  **unshared_edges SKINAUTO"<<endl;
  else inp<<"  **unshared_faces SKINAUTO"<<endl;
  inp<<"   *elsets "<<new_elset_name<<endl;

  inp<<"  **remove_set *bsets CUT_SKIN"<<endl;
  if(elset_to_cut!="") {
    inp<<"  "<<endl;
    inp<<"  **remove_set *nsets CUT_NSET *bsets CUT_BSET"<<endl;
    inp<<"  **nset CUT_NSET"<<endl;
    inp<<"   *use_elset "<<elset_to_cut<<endl;
    inp<<"   *function 1.;"<<endl;
    inp<<"  "<<endl;
  }

  if(trace_elset!="") {
    // Generate elset boundary
    inp<<"  **unshared_faces CUT_SKIN *elsets "<<trace_elset<<endl;
  }

  // Extract skin of current mesh
  inp<<"  **remesh_elset_skin"<<endl;
  inp<<"   *elset "<<elset_names<<" "<<new_elset_name;
  for(i=0;i<!material_elsets;i++) {
      inp<<" "<<material_elsets[i];
  }
  inp<<endl;

  inp<<"  **remove_set *bsets SKINAUTO"<<endl;
  inp<<"  **delete_elset to_del"<<endl;

  inp<<"  **degenerated_elset *elset DEGENERATED_ELEMENTS"<<endl;
  inp<<"  **delete_elset DEGENERATED_ELEMENTS"<<endl;
  
  inp<<"  **remove_set *nsets Nlip"<<endl;
  inp<<"  **fuse_nset"<<endl;
  inp<<"   *skip_reassign_numbers"<<endl;
  inp<<"   *cleanup_mesh"<<endl;
  inp<<"   *cleanup_nset Nlip"<<endl;

  // Mandatory not to create holes in very small elements
//  inp<<"   *cleanup_nset SIDE1"<<endl;
//  inp<<"   *impose_exclude_fuse"<<endl;
//  inp<<"   *exclude_nset SIDE0"<<endl;
  inp<<"   *tolerance 2.e-7"<<endl;
  inp<<"   *relative"<<endl;
  inp<<"   *iterate"<<endl;

  inp<<"  **remove_set *nsets Nlip"<<endl;

/* SQ 12/072016 : removed because fusion problem with mesh in meters
  // VC to allow use of abaqus/ansys modified mesh
  inp<<"   *impose_exclude_fuse"<<endl;
  inp<<"   *exclude_nset SIDE0"<<endl;
  inp<<"   *tolerance 2.000000e-7"<<endl;

  inp<<"   *tolerance 2.000000e-7"<<endl;
  inp<<"   *relative"<<endl;
  inp<<"   *iterate"<<endl;
*/
  inp<<"  **degenerated_elset *elset DEGENERATED_ELEMENTS"<<endl;
  inp<<"  **delete_elset DEGENERATED_ELEMENTS"<<endl;

  inp<<"  **cleanup_bsets"<<endl;

  // Now perform cutting operation
  if(mode==10) {
    // For refinement only remove crack.mesh
    inp<<"  **shell "<<del_cmd<<" crack.mesh"<<endl;
  } else if(mode==11) {
    // Build crack.mesh to cut mesh region
    inp<<""<<endl;
    if(smooth_elset_radius>=elset_radius) ERROR("smooth elset radius must be < elset_radius");
    inp<<"  **elset_near_nset"<<endl;
    inp<<"   *elset SMOOTHED_"<<new_elset_name<<endl;
    if(refinement_datafile!="") inp<< "   *refine_file "<<refinement_datafile<<endl;
    else if(crack_name!="") {
      inp<<"   *nset "<<crack_name<<endl;
    } else if((refine_origin!="DATAFILE")&&(refine_origin!="")) {
      inp<<"   *nset "<<refine_origin<<endl;
    }
    inp<<"   *radius "<<smooth_elset_radius<<endl;
    inp<<"  **remove_set *elsets SMOOTHED_"<<new_elset_name<<"_PREV"<<endl;
    inp<<""<<endl;
    inp<<"  **elset_to_front"<<endl;
    inp<<"   *elset SMOOTHED_"<<new_elset_name<<endl;
    inp<<"   *fnodes -6"<<endl;
    inp<<"   *step .2"<<endl;
    inp<<"   *hdist -2."<<endl;
    inp<<""<<endl;
    inp<<"  **remove_set *bsets SMOOTHED_"<<new_elset_name<<endl;
    inp<<"  **bset SMOOTHED_"<<new_elset_name<<endl;
    inp<<"   *use_elset SMOOTHED_"<<new_elset_name<<endl;
    inp<<"   *function 1.;"<<endl;
    inp<<""<<endl;
    str="SMOOTHED_"+new_elset_name;
    if(!faset_names.locate(str)) faset_names=faset_names+" "+str+" ";
  }

  if(elset_to_cut!="") {
    inp<<"  "<<endl;
    inp<<"  **bset CUT_BSET"<<endl;
    inp<<"   *use_nset CUT_NSET"<<endl;
    inp<<"  "<<endl;
  }

  inp<<"  **"<<MG<<endl;
  if(os != "win32") {
     if((gth_radius>0.)&&((rmax>0.)&&(rmax<gth_radius))) 
       inp<<"   *yams "<<distene_path<<"cut_dislo.sh"<<endl;
     else if(nb_iter<0) inp<<"   *yams "<<distene_path<<"cut_hpc.sh"<<endl;
     else inp<<"   *yams "<<distene_path<<"cut.sh"<<endl;
  }
  else inp<<"   *yams "<<distene_path<<"cut.bat"<<endl;

  if((arch==1)&&(!if_meshgems)) inp<<"   *m64"<<endl;
  inp<<"   *yams_only"<<endl;

  inp<<"   *absolu"<<endl;
  inp<<"   *no_deform_mesh"<<endl;
  if(if_2D) {
    if(if_must_define_elset) {
      inp<<"   *preserve_topo INTER_SURFACE "<<topo_names<< endl;
      inp<<"   *preserve_liset "<<liset_names<<" INTER_SURFACE Nlip "<<topo_names<< endl;
    } else {
      inp<<"   *preserve_liset "<<liset_names<<" Nlip "<<topo_names<< endl;
      if((!topo_names)!=0) inp<<"   *preserve_topo "<<topo_names<< endl;
    }
    if(!faset_names+!faset_names_from_template) {
       inp<<"   *preserve_faset "<<faset_names<<" "<<geom_names;
       for(i=0;i<!faset_names_from_template;i++) inp<<" "<<faset_names_from_template[i];
       if(elset_to_cut!="") inp<<" CUT_BSET ";
       inp<<endl;
    }
    else if((!geom_names)+!geom_names_from_template) {
      inp<<"   *preserve_faset "<<geom_names;
      for(i=0;i<!geom_names_from_template;i++) inp<<" "<<geom_names_from_template[i];
      if(elset_to_cut!="") inp<<" CUT_BSET ";
      inp<<endl;
      inp<<"   *preserve_geom "<<geom_names;
      for(i=0;i<!geom_names_from_template;i++) inp<<" "<<geom_names_from_template[i];
      inp<<endl;
    } else  if(elset_to_cut!="") inp<<"   *preserve_faset CUT_BSET "<<endl;
    inp<<"   *preserve_nset FRONTS "<<nset_names<<" CZM_SEED";
    for(i=0;i<!nset_names_from_template;i++) inp<<" "<<nset_names_from_template[i];
    inp<<endl;
  } else {
    if((!topo_names)!=0) inp<<"   *preserve_topo "<<topo_names<< endl;
    if(if_must_define_elset) {
      inp<<"   *preserve_geom INTER_SURFACE "<<geom_names;
      for(i=0;i<!geom_names_from_template;i++) inp<<" "<<geom_names_from_template[i];
      inp<< endl;
      inp<<"   *preserve_faset "<<faset_names<<" INTER_SURFACE Nlip CUT_SKIN "<<geom_names;
      for(i=0;i<!faset_names_from_template;i++) inp<<" "<<faset_names_from_template[i];
      for(i=0;i<!geom_names_from_template;i++)  inp<<" "<<geom_names_from_template[i];
      inp<<" SURFACE ";
      if(elset_to_cut!="") inp<<" CUT_BSET ";
      inp<<endl;
    } else {
      if((!geom_names)+(!geom_names_from_template)) {
         inp<<"   *preserve_geom "<<geom_names;
         for(i=0;i<!geom_names_from_template;i++)  inp<<" "<<geom_names_from_template[i];
         inp<<endl;
      }
      inp<<"   *preserve_faset "<<faset_names<<" Nlip CUT_SKIN ";
      for(i=0;i<!faset_names_from_template;i++) inp<<" "<<faset_names_from_template[i];
      inp<<" SURFACE ";
      if(elset_to_cut!="") inp<<" CUT_BSET ";
      for(i=0;i<!geom_names_from_template;i++)  inp<<" "<<geom_names_from_template[i];
      inp<<endl;
    } 
    inp<<"   *preserve_liset FRONTS "<<liset_names<<" "<<topo_names<< endl;
    inp<<"   *preserve_nset "<<nset_names<<" CZM_SEED";
    for(i=0;i<!nset_names_from_template;i++) inp<<" "<<nset_names_from_template[i];
    inp<< endl;
  }
  if((!ridge_names)!=0)
    inp<<"   *ridges "<<ridge_names<< endl;

  if(elset_to_cut!="") inp<<"  **remove_set *nsets CUT_NSET *bsets CUT_BSET"<<endl;

//  inp<<"  **put_on_grid *nbdigit 6"<<endl;
//  inp<<"  **degenerated_elset *elset DEGENERATED_ELEMENTS"<<endl;
//  inp<<"  **delete_elset DEGENERATED_ELEMENTS"<<endl;

  // Mesh has been cut
  // elset1997 contains splitted elements: must be deleted
  if(!if_2D) inp<<"  **delete_elset elset1997"<<endl;

  if(mode==2) {
    inp<<"  **remove_set *nsets NFRONT"<<endl;  
    inp<<"  **nset NFRONT"<<endl;
    inp<<"   *use_elset elset1999"<<endl;
    inp<<"   *function 1.;"<<endl;
    inp<<"  **remove_set *nsets toclean"<<endl;  
    inp<<"  **nset toclean"<<endl;
    inp<<"   *use_elset elset1999"<<endl;
    inp<<"   *use_bset Nlip"<<endl;
    inp<<"   *function 1.;"<<endl;
    inp<<""<<endl;
    inp<<"  **fuse_nset"<<endl;
    inp<<"   *skip_reassign_numbers"<<endl;
    inp<<"   *cleanup_mesh"<<endl;
    inp<<"   *cleanup_nset ALL_NODE"<<endl;
//    inp<<"   *impose_exclude_fuse"<<endl;
    inp<<"   *exclude_nset NFRONT"<<endl;
    inp<<"   *tolerance 4.000000e-7"<<endl;
    inp<<"   *relative"<<endl;
    inp<<"   *iterate"<<endl;
    inp<<"  **remove_set *nsets toclean"<<endl;  
    inp<<"  **delete_elset elset1999"<<endl;
    inp<<"  **extract_bset_from_bset *new_set CZM_TO_DEL *bset Nlip *forbidden NFRONT *seed CZM_SEED"<<endl;
    inp<<"  **delete_elset CZM_TO_DEL"<<endl;
  } 

  // Build new crack surface and suppress external elements
  if(mode==11) {
    // Elset smoothing
    inp<<""<<endl;
    inp<<"  **remove_set *nsets toclean"<<endl;  
    inp<<"  **nset toclean"<<endl;
    inp<<"   *function 1.;"<<endl;
    inp<<""<<endl;
    inp<<"  **fuse_nset"<<endl;
    inp<<"   *skip_reassign_numbers"<<endl;
    inp<<"   *cleanup_mesh"<<endl;
    inp<<"   *cleanup_nset toclean"<<endl;
    inp<<"   *tolerance 4.000000e-7"<<endl;
    inp<<"   *relative"<<endl;
    inp<<"   *iterate"<<endl;
    inp<<"  **remove_set *nsets toclean"<<endl;  
    inp<<""<<endl;
    inp<<"  **degenerated_elset *elset DEGENERATED_ELEMENTS"<<endl;
    inp<<"  **delete_elset DEGENERATED_ELEMENTS"<<endl;


    inp<<"  **remove_set *bsets NEW_SMOOTHED_ZONE SMOOTHED_ALL_SURFACE *nsets SMOOTHED_BOUNDARY"<<endl;
    inp<<"  **nset SMOOTHED_BOUNDARY *use_elset elset1999 *function 1.;"<<endl;
    inp<<"  **delete_elset elset1999"<<endl;
    inp<<"  **bset SMOOTHED_ALL_SURFACE"<<endl;
    inp<<"   *function 1.;"<<endl;
    inp<<"  **rename_set *bsets SEED_EVP_NEW SEED_EVP"<<endl;
    inp<<"  **join_bsets SEED_EVP_NEW"<<endl;
    inp<<"   *bsets SMOOTHED_"<<new_elset_name<<endl;

    inp<<"  **extract_bset_from_bset"<<endl;
    inp<<"   *new_set NEW_SMOOTHED_ZONE"<<endl;
    inp<<"   *bset SMOOTHED_ALL_SURFACE"<<endl;
    inp<<"   *forbidden SMOOTHED_BOUNDARY"<<endl;
    inp<<"   *seed  SMOOTHED_"<<new_elset_name<<endl;
    inp<<"  **remove_set"<<endl;
    inp<<"   *bsets SMOOTHED_ALL_SURFACE SMOOTHED_"<<new_elset_name<<endl;
    inp<<"   *nsets SMOOTHED_BOUNDARY"<<endl;
    inp<<"   *elsets SMOOTHED_"<<new_elset_name<<endl;
    inp<<"  **rename_set"<<endl;
    inp<<"   *bsets NEW_SMOOTHED_ZONE SMOOTHED_"<<new_elset_name<<endl;
    inp<<""<<endl;
  } else if(if_2D) {
    // Build news fronts
    inp<<"  **nset toclean"<<endl;
    inp<<"   *function 1.;"<<endl;
    inp<<""<<endl;
    inp<<"  **fuse_nset"<<endl;
    inp<<"   *skip_reassign_numbers"<<endl;
    inp<<"   *cleanup_mesh"<<endl;
    inp<<"   *cleanup_nset toclean"<<endl;
    inp<<"   *tolerance 4.000000e-7"<<endl;
    inp<<"   *relative"<<endl;
    inp<<"   *iterate"<<endl;
    inp<<"  **delete_elset elset1997"<<endl;
    inp<<"  **remove_set *nsets toclean"<<endl;  
    inp<<""<<endl;
    inp<<"  **degenerated_elset *elset DEGENERATED_ELEMENTS"<<endl;
    inp<<"  **delete_elset DEGENERATED_ELEMENTS"<<endl;
 
    // Keep current front nodes
    // Create new lip
    inp<<"  **remove_set *nsets AFRONTS BFRONTS CFRONTS *bsets AFRONTS Nlip0 Nlip1"<<endl;
    // Update lip
    inp<<"  **bset Nlip0 *use_elset elset1999 *function 1.; *use_dimension 1 *no_sort"<<endl;
    inp<<"  **unshared_edges AFRONTS *elsets elset1999"<<endl;
    inp<<"  **remove_nodes_from_nset *nset_name AFRONTS *nsets_to_remove FRONTS"<<endl;
    inp<<"  **nset BFRONTS *use_elset elset1999 *function 1.;"<<endl;
    inp<<"  **remove_nodes_from_nset *nset_name FRONTS *nsets_to_remove BFRONTS"<<endl;
    inp<<"  **nset CFRONTS *use_nset AFRONTS FRONTS"<<endl;
    inp<<"  **remove_set *bsets AFRONTS *nsets FRONTS AFRONTS BFRONTS Nlip0 Nlip1 toclean"<<endl;
    inp<<"  **rename_set *nsets CFRONTS FRONTS"<<endl;
    inp<<"  **rename_set *elsets elset1999 ASSO_PB"<<endl;
    inp<<"  **delete_elset ASSO_PB"<<endl;
/*
    if((mode!=2)&&if_czm) {
      inp<<"  "<<endl;
      inp<<"  **extract_bset_from_bset *new_set CZM_TO_DEL *bset ALL_CZM_SURFACE *forbidden CZM_BOUNDARY *seed CZM_SEED"<<endl;
      inp<<"  **remove_set *nsets INTER_S0 INTER_S1 CZM_SEED CZM_BOUNDARY ALL_CZM_SURFACE CZM_EXTENSION CZM_TO_DEL"<<endl;
      inp<<"  "<<endl;
    }
*/
    inp<<"  **join_bsets Nlip1"<<endl;
    inp<<"   *bsets Nlip Nlip0"<<endl;
    inp<<"   *remove_duplicates"<<endl;
    inp<<"  **remove_set *bsets Nlip Nlip0"<<endl;
    inp<<"  **rename_set *bsets Nlip1 Nlip"<<endl;
    inp<<""<<endl;
  } else if(trace_elset!="") {
    inp<<"  **remove_set *nsets DECOHESION_BOUNDARY *bsets DECOHESION_SURFACE DECOHESION_CRACK"<<endl;
    inp<<"  **rename_set *bsets CUT_SKIN DECOHESION_SURFACE"<<endl;
    inp<<"  **nset DECOHESION_BOUNDARY *use_elset elset1999 *function 1.;"<<endl;
    inp<<"  **extract_bset_from_bset *new_set DECOHESION_CRACK *bset DECOHESION_SURFACE *forbidden DECOHESION_BOUNDARY *seed Nlip"<<endl;
    inp<<"  **remove_set *nsets DECOHESION_BOUNDARY DECOHESION *bsets DECOHESION_SURFACE NNLIP"<<endl;
    inp<<"  **join_bsets NNLIP"<<endl;
    inp<<"   *bsets Nlip DECOHESION_CRACK"<<endl;
    inp<<"   *remove_duplicates"<<endl;
    inp<<"  **remove_set *bsets Nlip"<<endl;
    inp<<"  **rename_set *bsets NNLIP Nlip"<<endl;
    inp<<"  "<<endl;
    inp<<"  **delete_elset elset1999"<<endl;
  } else if(mode!=2) {

    inp<<""<<endl;
    inp<<"  **nset toclean"<<endl;
    inp<<"   *function 1.;"<<endl;
    inp<<"  **fuse_nset"<<endl;
    inp<<"   *skip_reassign_numbers"<<endl;
    inp<<"   *cleanup_mesh"<<endl;
    inp<<"   *cleanup_nset toclean"<<endl;
    inp<<"   *tolerance 1.e-7"<<endl;
    inp<<"   *relative"<<endl;
    inp<<"   *iterate"<<endl;
    inp<<"  **remove_set *nsets toclean"<<endl;  
    inp<<""<<endl;
 
    if(elset_to_cut!="") {
      inp<<"  **reassign_elsets"<<endl;
      inp<<"   *mesh ELSET_TO_KEEP"<<endl;
      inp<<"   *elset_inside elset1999"<<endl;
      inp<<"  **delete_elset ASSO_PB"<<endl;
    }

    if(elset_inside!="") {
      inp<<"  **reassign_elsets"<<endl;
      inp<<"   *mesh ELSET_INSIDE"<<endl;
      inp<<"   *elset_inside elset1999"<<endl;
      inp<<"  **delete_elset ASSO_PB"<<endl;
    }

    if(if_keep==0) {
      inp<<"  **reassign_elsets"<<endl;
      inp<<"   *mesh TOCUTMESH"<<endl;
      inp<<"   *elset_inside elset1999"<<endl;
    }
    inp<<""<<endl;
    inp<<"  **nset toclean"<<endl;
    inp<<"   *function 1.;"<<endl;
    inp<<"  **fuse_nset"<<endl;
    inp<<"   *skip_reassign_numbers"<<endl;
    inp<<"   *cleanup_mesh"<<endl;
    inp<<"   *cleanup_nset toclean"<<endl;
    inp<<"   *tolerance 2.000000e-7"<<endl;
    inp<<"   *relative"<<endl;
    inp<<"   *iterate"<<endl;
    inp<<"  **remove_set *nsets toclean"<<endl;  
    inp<<""<<endl;
    inp<<"  **degenerated_elset *elset DEGENERATED_ELEMENTS"<<endl;
    inp<<"  **delete_elset DEGENERATED_ELEMENTS"<<endl;
    inp<<""<<endl;
    inp<<"  **bset_to_elset *bsets Nlip *elsets Nlip"<<endl;
    inp<<""<<endl;
    inp<<"  **unshared_edges AFRONTS"<<endl;
    inp<<"   *elsets elset1999 Nlip"<<endl;
    inp<<""<<endl;
  
    if(sym_bset!="") {
      inp<<"  **join_bsets FRONTS"<<endl;
      inp<<"   *intersection"<<endl;
      inp<<"   *bsets AFRONTS "<<sym_bset<<endl;
      inp<<"   *remove_duplicates"<<endl;
    } else {
      inp<<"  **join_bsets FRONTS"<<endl;
      inp<<"   *remove"<<endl;
      inp<<"   *bsets AFRONTS SURFACE INTER_SURFACE"<<endl;
      inp<<"   *remove_duplicates"<<endl;
    }
    inp<<""<<endl;
    inp<<"  **delete_elset ASSO_PB"<<endl;
    inp<<""<<endl;
/*
    if(if_czm) {
      inp<<"  **extract_bset_from_bset *new_set CZM_TO_DEL *bset ALL_CZM_SURFACE *forbidden CZM_BOUNDARY *seed CZM_SEED"<<endl;
      inp<<"  **bset_to_elset *bsets CZM_TO_DEL *elsets CZM_TO_DEL **delete_elset CZM_TO_DEL"<<endl;
      inp<<"  **delete_elset CZM_TO_DEL"<<endl;
      inp<<"  **remove_set *nsets INTER_S0 INTER_S1 CZM_SEED CZM_BOUNDARY ALL_CZM_SURFACE CZM_EXTENSION CZM_TO_DEL"<<endl;
      inp<<"  "<<endl;
    }
*/
    inp<<"  **remove_set *bsets Nlip"<<endl;
    inp<<""<<endl;

    if(if_keep==0) {
      inp<<"  **bset Nlip"<<endl;
      inp<<"   *use_elset Nlip elset1999"<<endl;
      inp<<"   *function 1.;"<<endl;
      inp<<""<<endl;
    }
  }
  inp<<"  **shell "<<del_cmd<<" TOCUTMESH.geo"<<endl;

  // VC added removing of remaining bad quality linked to ears or crack front
  if(quality_threshold>1.) {
    i=quality_threshold; 
    flip_tol=quality_threshold-i;
    if(flip_tol<1.e-12) flip_tol=2.e-4;
    inp<<endl;
    inp<<"  **remove_set *bsets CHECK_ZONE *nsets CHECK_ZONE *elsets BAD_QUALITY_ELEMENTS"<<endl;
    inp<<"   **unshared_edges CHECK_ZONE"<<endl;
    inp<<"    *no_branching"<<endl;
    inp<<"   **fuse_nset"<<endl;
    inp<<"    *skip_reassign_numbers"<<endl;
    inp<<"    *cleanup_mesh"<<endl;
    inp<<"    *cleanup_nset CHECK_ZONE"<<endl;
    inp<<"    *tolerance "<<flip_tol<<endl; //2.000000e-4"<<endl;
    inp<<"    *relative"<<endl;
    inp<<"    *iterate"<<endl;
    inp<<"   **check_quality"<<endl;
    inp<<"    *quality_threshold "<<quality_threshold<<endl;
//    inp<<"    *nset_hyperlink CHECK_ZONE"<<endl;
//    inp<<"   **delete_elset BAD_QUALITY_ELEMENTS"<<endl;
    inp<<"   **remove_set *nsets CHECK_ZONE"<<endl;
    inp<<"   **nset CHECK_ZONE *use_elset BAD_QUALITY_ELEMENTS *function 1.;"<<endl;
    inp<<"   **fuse_nset"<<endl;
    inp<<"    *skip_reassign_numbers"<<endl;
    inp<<"    *cleanup_mesh"<<endl;
    inp<<"    *cleanup_nset CHECK_ZONE"<<endl;
    inp<<"    *tolerance "<<flip_tol<<endl; 
    inp<<"    *relative"<<endl;
    inp<<"    *iterate"<<endl;
    inp<<"   **degenerated_elset *elset DEGENERATED_ELEMENTS"<<endl;
    inp<<"   **delete_elset DEGENERATED_ELEMENTS"<<endl;
    inp<<"   **remove_set *bsets CHECK_ZONE *nsets CHECK_ZONE *elsets BAD_QUALITY_ELEMENTS"<<endl;
    inp<<endl;
  }

/*
  // VC -> for better filtering
  inp<<"**remove_set *elsets BAD_QUALITY_ELEMENTS DEGENERATED_ELEMENTS *nsets TOFUSE "<<endl;
  inp<<"**check_quality *quality_threshold 10. **nset TOFUSE *use_elset BAD_QUALITY_ELEMENTS *function 1.;"<<endl;
  inp<<"**fuse_nset *skip_reassign_numbers *cleanup_mesh *cleanup_nset TOFUSE *iterate *tolerance .001 *relative "<<endl;
  inp<<"**degenerated_elset **delete_elset DEGENERATED_ELEMENTS "<<endl;
  inp<<"**remove_set *elsets BAD_QUALITY_ELEMENTS DEGENERATED_ELEMENTS *nsets TOFUSE "<<endl;
*/

  if(!(if_2D)&&(mode==1)&&(if_czm)) {

    // For propagation: perform remeshing locally to front
    inp<<"  **elset EXTCLEAN0 *not_in_elset elset1999"<<endl;
    inp<<"  **bset KEPTCLEAN0"<<endl;
    inp<<"   *use_elset EXTCLEAN0"<<endl;
    inp<<"   *function 1.;"<<endl;
    inp<<"   *use_dimension 3"<<endl;
    inp<<"  **nset TOCLEAN *use_elset elset1999 *function 1.;"<<endl;
    inp<<"  **elset TOCLEAN *attached_to_nset TOCLEAN"<<endl;
    inp<<"  **nset TOCLEAN2 *use_elset TOCLEAN *function 1.;"<<endl;
    inp<<"  **elset TOCLEAN2 *attached_to_nset TOCLEAN2"<<endl;
    inp<<"  **elset EXTCLEAN *not_in_elset TOCLEAN2"<<endl;
    inp<<"  **bset KEPTCLEAN"<<endl;
    inp<<"   *use_elset EXTCLEAN"<<endl;
    inp<<"   *function 1.;"<<endl;
    inp<<"   *use_dimension 3"<<endl;
    // 0st surface releshing + cleaning
    inp<<"  **"<<MG<<endl;
    if(yams_prefix!="") { 
      inp<<"  *yams "<<yams_prefix<<"yams"<<endl; 
      inp<<"  *ghs3d "<<yams_prefix<<"ghs3d"<<endl; 
      inp<<"  *meshadapt "<<yams_prefix<<"meshadapt"<<endl; 
    } 
    // VC: should not be necessary by default " --compute_ridges no --create_nodes_on_flat_edge yes "<<endl;
    if(!if_meshcleaner) {
      if(if_meshgems) inp<<"   *optim_1st --optimisation only --remove_bad_input_surface_elements yes --use_surface_proximity yes --use_volume_proximity yes --bad_input_surface_element_aspect_ratio=50. "<<yams_options<<endl;
      else inp<<"   *optim_1st 0 -DQlevel=100. -Dprox2D=3 "<<yams_options<<" -nr -nm "<<endl;
    }
    if((arch==1)&&(!if_meshgems)) inp<<"   *m64"<<endl;
    inp<<"   *yams_only"<<endl;
    inp<<"   *binary"<<endl;
    inp<<"   *absolu"<<endl;
    inp<<"   *no_deform_mesh"<<endl;
    inp<<"   *nb_iter_surf 2"<<endl;
    if(nb_ext>0)
      inp<<"   *refine_ext "<<nb_ext<<endl;
    if((!topo_names)!=0) inp<<"   *preserve_topo "<<topo_names<< endl;
    if(if_must_define_elset) {
      inp<<"   *preserve_geom INTER_SURFACE "<<geom_names<<" KEPTCLEAN0";
      for(i=0;i<!geom_names_from_template;i++)  inp<<" "<<geom_names_from_template[i];
      inp<<endl;
      inp<<"   *preserve_faset "<<faset_names<<" INTER_SURFACE Nlip KEPTCLEAN"<<geom_names;
      for(i=0;i<!faset_names_from_template;i++) inp<<" "<<faset_names_from_template[i];
      for(i=0;i<!geom_names_from_template;i++)  inp<<" "<<geom_names_from_template[i];
      inp<<endl;
    } else {
      inp<<"   *preserve_geom "<<geom_names<<" KEPTCLEAN0";
      for(i=0;i<!geom_names_from_template;i++)  inp<<" "<<geom_names_from_template[i];
      inp<<endl;
      inp<<"   *preserve_faset "<<faset_names<<" Nlip";
      for(i=0;i<!faset_names_from_template;i++) inp<<" "<<faset_names_from_template[i];
      for(i=0;i<!geom_names_from_template;i++)  inp<<" "<<geom_names_from_template[i];
      inp<<endl;
    }
    inp<<"   *preserve_liset FRONTS "<<liset_names<<" "<<topo_names<< endl;
    if((!nset_names)!=0)
      inp<<"   *preserve_nset "<<nset_names<< endl;
    if((!ridge_names)!=0)
      inp<<"   *ridges "<<ridge_names<< endl;
    if(min_size>0.)
      inp<<"   *min_size "<< min_size <<endl;
    if(max_size>=0.) 
      inp<<"   *max_size "<< max_size <<endl;
    if(if_meshgems) inp<<"   *options "<<yams_options<<endl;
    if(gradation>=1.) refinement(inp);
    if(refine_origin!="DATAFILE") {
      if(mode==10) { 
        if(crack_name=="") {
          if(refine_origin!="") inp<<"   *refinement_origin "<<refine_origin<<endl;
        } else inp<<"   *refinement_origin crack_front0"<<endl;
      } else {
        inp<<"   *refinement_origin Nlip"<<endl;
      }
    }
    if(if_lip_factor)
      inp<<"   *lip_factor "<<lip_factor<<endl;
 
    // Cleaning
      inp<<"  **nset toclean"<<endl;
      inp<<"   *function 1.;"<<endl;
      inp<<""<<endl;
      inp<<"  **fuse_nset"<<endl;
      inp<<"   *skip_reassign_numbers"<<endl;
      inp<<"   *cleanup_mesh"<<endl;
      inp<<"   *cleanup_nset toclean"<<endl;
      inp<<"   *tolerance 2.000000e-7"<<endl;
      inp<<"   *relative"<<endl;
      inp<<"   *iterate"<<endl;
      inp<<""<<endl;
      inp<<"  **degenerated_elset *elset DEGENERATED_ELEMENTS"<<endl;
      inp<<"  **delete_elset DEGENERATED_ELEMENTS"<<endl;

}

  // Refinement add crack or set mode to datafile refinement
  if((mode==10)||(mode==11)) {
    inp<<"  **remove_set *elsets REFINED_ZONE"<<endl;
    inp<<"  **elset REFINED_ZONE *function 1.;"<<endl;
    if(if_quadrangles){
       inp<<"  **remove_set *bsets SEED_EVP SEED_EVP_NEW"<<endl;
    }
    // See if datafile
    if(refinement_datafile!="") {
      if(refine_origin=="DATAFILE_ORIGIN") {
        refine_function="";
      } else {
        refine_origin="DATAFILE";
        refine_function="  *refine_file "+refinement_datafile+"\n";
      }
    } else if((if_refine_only==0)&&(crack_name!="")) inp<<"  **union *add "<<crack_name<<".geo *append_id"<<endl;
  } else if(refinement_datafile!="") {
    refine_origin="DATAFILE";
    refine_function="  *refine_file "+refinement_datafile+"\n";
  }

  inp<<"  **remove_set *nsets Nlip"<<endl;

  if(mode==10) inp<<" **nset crack_front0 *use_bset FRONTS crack_front"<<endl;

  if(if_dislo) {
    inp <<"  **join_bsets SIDE0"<<endl;
    inp <<"   *bsets Nlip"<<endl;
    inp <<"   *remove_duplicates"<<endl;
    inp <<"  **join_bsets SIDE1"<<endl;
    inp <<"   *bsets Nlip"<<endl;
    inp <<"   *remove_duplicates"<<endl;
    inp<<"  **remove_set *bsets NNlip RM_DISLO"<<endl;
    inp <<" **extends_dislo";
    inp<<endl;
    inp<<"  **rename_set *bsets Nlip NNlip"<<endl;
    inp<<"  **join_bsets Nlip"<<endl;
    inp<<"   *bsets NNlip RM_DISLO"<<endl;
    inp<<"   *remove"<<endl;
    inp<<"   *remove_duplicates"<<endl;
    inp<<"  **elset todel *attached_to_nset RM_DISLO"<<endl;
    inp<<"  **remove_set *bsets NNlip RM_DISLO"<<endl;
    inp<<"  **delete_elset todel"<<endl;
    inp<<"  "<<endl;
  }

  inp<<"  **"<<MG<<endl;
  if(yams_prefix!="") { 
    inp<<"  *yams "<<yams_prefix<<"yams"<<endl; 
    inp<<"  *ghs3d "<<yams_prefix<<"ghs3d"<<endl; 
    inp<<"  *meshadapt "<<yams_prefix<<"meshadapt"<<endl; 
  } 

  if(optim_style!="") inp << "   *optim_style "<<optim_style<<endl;
  if((arch==1)&&(!if_meshgems)) inp<<"   *m64"<<endl;
  if(if_2D) inp<<"   *yams_only"<<endl;
  if(if_output_surface) inp<<"   *yams_only"<<endl;
  inp<<"   *binary"<<endl;
  inp<<"   *absolu"<<endl;
  inp<<"   *no_deform_mesh"<<endl;
  inp<<"   *volume"<<endl;
  if(nb_iter<0) {
    inp<<"   *nb_iter_vol 0"<<endl;
  } else inp<<"   *nb_iter_vol "<<niter<<endl;
  inp<<"   *nb_iter_surf "<<nb_iters<<endl;
// VC new think its be like optim=0 from old yams...
  if(!if_meshcleaner) {
    if(optim_1st=="") {
      if(if_meshgems) inp<<"   *optim_1st --optimisation only --remove_bad_input_surface_elements yes --use_surface_proximity yes --use_volume_proximity yes --bad_input_surface_element_aspect_ratio=50. "<<yams_options<<endl;
      else inp<<"   *optim_1st 0 -DQlevel=100. -Dprox2D=3 "<<yams_options<<endl;
    } else inp<<"   *optim_1st "<<optim_1st<<" "<<yams_options<<endl;
  }
  if(mode==10) inp<<"  *elset REFINED_ZONE"<<endl;
  if(nb_ext>0)
    inp<<"   *refine_ext "<<nb_ext<<endl;
  if(if_2D) {
    if(if_must_define_elset) {
      if(!if_quadrangles){
         inp<<"   *preserve_topo INTER_SURFACE "<<topo_names<< endl;
      }
      inp<<"   *preserve_liset "<<liset_names<<" INTER_SURFACE Nlip "<<topo_names<< endl;
    } else {
      inp<<"   *preserve_liset "<<liset_names<<" Nlip "<<topo_names<< endl;
      if((!topo_names)!=0) inp<<"   *preserve_topo "<<topo_names<< endl;
    }
    if(!faset_names+!faset_names_from_template) {
       inp<<"   *preserve_faset "<<faset_names<<" "<<geom_names;
       for(i=0;i<!faset_names_from_template;i++) inp<<" "<<faset_names_from_template[i];
       inp<<endl;
    }
    else if((!geom_names)+(!geom_names_from_template)) {
      inp<<"   *preserve_faset "<<geom_names;
      for(i=0;i<!geom_names_from_template;i++)  inp<<" "<<geom_names_from_template[i];
      inp<<endl;
      inp<<"   *preserve_geom "<<geom_names;
      for(i=0;i<!geom_names_from_template;i++)  inp<<" "<<geom_names_from_template[i];
      inp<<endl;
    }
    if(if_quadrangles){
       inp<<"   *preserve_nset FRONTS INTER_SURFACE "<<nset_names<< endl;    
    } else {
      inp<<"   *preserve_nset FRONTS "<<nset_names<< endl;
    }
  } else {
    if((!topo_names)!=0) inp<<"   *preserve_topo "<<topo_names<< endl;
    if(if_must_define_elset) {
      inp<<"   *preserve_geom INTER_SURFACE "<<geom_names;
      for(i=0;i<!geom_names_from_template;i++)  inp<<" "<<geom_names_from_template[i];
      inp<<endl;
      inp<<"   *preserve_faset "<<faset_names<<" INTER_SURFACE Nlip "<<geom_names;
      for(i=0;i<!faset_names_from_template;i++) inp<<" "<<faset_names_from_template[i];
      for(i=0;i<!geom_names_from_template;i++)  inp<<" "<<geom_names_from_template[i];
      inp<<endl;
    } else {
      if((!geom_names)+(!geom_names_from_template)) {
        inp<<"   *preserve_geom "<<geom_names;
        for(i=0;i<!geom_names_from_template;i++)  inp<<" "<<geom_names_from_template[i];
        inp<<endl;
      }
      inp<<"   *preserve_faset "<<faset_names<<" Nlip";
      for(i=0;i<!faset_names_from_template;i++) inp<<" "<<faset_names_from_template[i];
      inp<<" "<<geom_names;
      for(i=0;i<!geom_names_from_template;i++)  inp<<" "<<geom_names_from_template[i];
      inp<<endl;
    }
    inp<<"   *preserve_liset FRONTS "<<liset_names<<" "<<topo_names<< endl;

    if(!nset_names+!nset_names_from_template){
      inp<<"   *preserve_nset "<<nset_names;
      for(i=0;i<!nset_names_from_template;i++) inp<<" "<<nset_names_from_template[i];
      inp<<endl;
    }
  }
  if((!ridge_names)!=0)
    inp<<"   *ridges "<<ridge_names<< endl;
  //else inp<<"   *get_ridges"<<endl;
  if((!yams_options)!=0) 
    inp<<"   *options "<<yams_options<<endl;
  if(if_quadrangles){
    inp<<"   *options --element_generation full_quad --create_nodes_on_flat_edge yes    --geometric_approximation_angle 20."<<endl;
  }
  if(min_size>0.)
    inp<<"   *min_size "<< min_size <<endl;
  if(gradation>=1.) refinement(inp);
  if(refine_origin=="DATAFILE_ORIGIN") {
    inp<<" #origin datafile"<<endl;
  } else if(refine_origin!="DATAFILE") {
    if(mode==10) { 
      if(crack_name=="") {
        if(refine_origin!="") inp<<"   *refinement_origin "<<refine_origin<<endl;
      } else inp<<"   *refinement_origin crack_front0"<<endl;
    } else {
      if(mode==2) inp<<"   *refinement_origin NFRONT"<<endl;
      else if(if_czm) {
        if(mode==0) inp<<"   *refinement_origin Nlip"<<endl;
        else        inp<<"   *refinement_origin Nlip"<<endl;
      } else if(if_surface_refine) {
        inp<<"   *refinement_origin Nlip"<<endl;
      } else {
        if (refine_origin!="") inp<<"   *refinement_origin "<<refine_origin<<endl;
        else inp<<"   *refinement_origin FRONTS"<<endl;
      }
    }
  }
  if(if_var_refine) { 
    inp<<"   *liset_front FRONTS"<<endl;
    inp<<"   *skin_nset SKIN_REF"<<endl;
  }
  if(if_lip_factor)
    inp<<"   *lip_factor "<<lip_factor<<endl;
  inp<<"   "<<endl;
  if(max_size>=0.) 
    inp<<"   *max_size "<< max_size <<endl;
  if(if_meshcleaner)
    inp<<"   *mesh_cleaner"<<endl;

  if(if_hexa&&(mode<=1)) {
    // Apply hexa mesher arround each crack fronts
    hexa_options = "--nb-hexa "+itoa(nb_hexa)+" --dr-hexa "+dtoa(dr_hexa)+" --th-hexa "+itoa(th_hexa)+" --nc-hexa "+itoa(nc_hexa);
    hexa_options = hexa_options +" --gradation "+dtoa(gradation)+" --prog-hexa "+dtoa(prog_hexa);
    inp<<""<<endl;
    inp<<" **save in_cut.geo"<<endl;
    inp<<""<<endl;
    inp<<" ***shell "<<del_cmd<<" hexa_crack_CLEAN.geo"<<endl;
    inp<<" ***shell "<<del_cmd<<" hexa_crack.geof"<<endl;
    inp<<" ***shell "<<distene_path<<cut_exe<<" _mesh_out_to_ghs3d.mesh --hexa "<<hexa_options<<endl;
    inp<<" ***shell "<<cop_cmd<<" out.mesh _mesh_out_to_ghs3d.mesh"<<endl;
    if(if_must_define_elset) {
      inp<<" ***shell "<<del_cmd<<" "<<cracked_name<<"_REMESHED.geo"<<endl;
      inp<<" ***mesh "<<cracked_name<<"_REMESHED.geo"<<endl;
    } else {
      inp<<" ***shell "<<del_cmd<<" REMESHED.geo"<<endl;
      inp<<" ***mesh REMESHED.geo"<<endl;
    }
    inp<<"  **open hexa_crack_CLEAN.geo"<<endl;
    inp<<""<<endl;
  }

// VC for better linear mesh 
  if((!if_2D)&&(!if_quad)&&(!if_hexa)) inp<< "  **set_reduced"<<endl;

//  inp<<"  **put_on_grid *grid_dim 1.e5"<<endl;
 
  inp<<"  **nset lip"<<endl;
  inp<<"   *use_bset Nlip"<<endl;
  inp<<"   "<<endl;

  if(((elset_names!="")+!material_elsets)&&(if_output_surface==0)) {
    inp<<" **reassign_elsets"<<endl;
    inp<<"  *mesh TO_REASSIGN.geo"<<endl;
    inp<<"  *elsets "<<elset_names;
    for(i=0;i<!material_elsets;i++) {
      inp<<" "<<material_elsets[i];
    }
    inp<<endl;
    if(intersection_mesh=="") {
      if(if_remove) {
        inp<<"  *remove"<<endl;
        inp<<" **delete_elset ASSO_PB"<<endl;
      }
    } else {
      inp<<" **reassign_elsets"<<endl;
      inp<<"  *mesh "<<intersection_mesh<<endl;
      inp<<"  *elsets "<<elset_names<<endl;
      if(if_remove) {
        inp<<"  *remove"<<endl;
      }
    }
  }
  if((elset_names!="")&&(if_output_surface==0)&&(slice_name!="")) {
    inp<<" **reassign_elsets"<<endl;
    inp<<"  *mesh TO_REASSIGN.geo"<<endl;
    inp<<"  *elsets SW_"<slice_name<<endl;
    inp<<"  *slice "<<slice_name<<"_SLICE"<<endl;
  }    

  if(if_must_define_elset) {
    inp<<" **reassign_elsets"<<endl;
    inp<<"  *mesh TO_REMESH_COMPO.geo"<<endl;
    inp<<"  *elsets "<<new_elset_name<<"_EXT"<<endl;
    inp<<" **delete_elset "<<new_elset_name<<"_EXT"<<endl;
    inp<<" **remove_set *elsets ASSO_PB"<<endl;
    inp<<"   "<<endl;
  }

  inp<<" **elset "<<new_elset_name<<" *function 1.;"<<endl;
  inp<<"   "<<endl;
 
  if(f2D) {
    inp<<"  **bset_to_elset *bsets "<<elset_names<<endl;
    inp<<"   *elsets "<<elset_names<<endl;
    inp<<endl;
    faset_names="";
  } else if(bset_to_elset!="") {
    inp<<"  **bset_to_elset *bsets "<<bset_to_elset<<endl;
    inp<<"   *elsets "<<bset_to_elset<<endl;
// EDF
    inp<<"  **remove_set *bsets "<<bset_to_elset<<endl;
    inp<<endl;
  } else if(if_2D) {
    inp<<"  **bset_to_elset *bsets "<<elset_names<<endl;
    inp<<"   *elsets "<<elset_names<<endl;
    inp<<endl;
  }

  filt2=filt2*10.;

  if(if_must_define_elset) {
    inp<<" ***mesh REMESHED.geo"<<endl;
    inp<<"  **open TO_REMESH_COMPO.geo"<<endl;
    inp<<"  **delete_elset "<<new_elset_name<<endl;
    inp<<"  **remove_set *nsets SIDE0 SIDE1"<<endl;  
    inp<<"  **fuse_nset"<<endl;
    inp<<"   *skip_reassign_numbers"<<endl;
    inp<<"   *cleanup_mesh"<<endl;
    inp<<"   *cleanup_nset SIDE0 SIDE1"<<endl;
    inp<<"   *tolerance 2.000000e-7"<<endl;
    // VC to allow use of abaqus/ansys modified mesh
//    inp<<"   *impose_exclude_fuse"<<endl;
//    inp<<"   *exclude_nset SIDE0"<<endl;
//    inp<<"   *tolerance 1.e-12"<<endl;
    inp<<"   *relative"<<endl;
    inp<<"   *iterate"<<endl;
/*
    inp<<"   *tolerance 1.e-12"<<endl;
*/
    inp<<"  **union"<<endl;
    inp<<"   *add "<<cracked_name<<"_REMESHED.geo"<<endl;
    inp<<"   *append_id" <<endl;
    if(max_node_id>0) inp<<"   *from_node "<<max_node_id<<endl;
    if(max_ele_id>0)  inp<<"   *from_element "<<max_ele_id<<endl;
    inp<<"   *tolerance 0."<<endl;
    inp<<"  **fuse_nset"<<endl;
    inp<<"   *skip_reassign_numbers"<<endl;
    inp<<"   *cleanup_mesh"<<endl;
    inp<<"   *cleanup_nset INTER_SURFACE"<<endl;
    inp<<"   *exclude_nset INTER_SURFACE0"<<endl;
    inp<<"   *impose_exclude_fuse"<<endl;
    inp<<"   *relative"<<endl;
    inp<<"   *tolerance 1.e-12"<<endl;
//    inp<<"   *tolerance 2.000000e-7"<<endl;
    if(!if_2D) {
      inp<<"  **remove_set *bsets INCOMP_INTER"<<endl;
      inp<<"  **join_bsets INCOMP_INTER"<<endl;
      inp<<"   *bsets INTER_SURFACE INTER_SURFACE0"<<endl;
      inp<<"   *remove_duplicates"<<endl;
      if(if_pyra) inp<<"  **tri_quad_faces *bset INCOMP_INTER "<<endl;
      inp<<"  **remove_set *bsets INCOMP_INTER"<<endl;
    }
    inp<<"  **remove_set *nsets INTER_SURFACE INTER_SURFACE0"<<endl;
    inp<<"  **cleanup_bsets"<<endl;
  }

  // Regenerate crack
  inp<<"  **cleanup_bsets"<<endl;
  inp<<"  **remove_set *bsets SURFACE SIDE0 SIDE1 *nsets SURFACE lip Nlip SIDE0 SIDE1"<<endl;

  inp<<"  **remove_set *nsets FRONT";
  for(i=0;i<nb_fronts;i++) inp<<" FRONT"<<i;
  inp<<"   *bsets";
  for(i=0;i<nb_fronts;i++) inp<<" FRONT"<<i;
  inp<<endl;

  if(if_2DE) {
      inp<<"  **nset FRONT *use_nset FRONTS"<<endl;
      inp<<"  **remove_set"<<endl;
      inp<<"   *bsets INTERSHELL"<<endl;
      inp<<"  **rename_set *bsets INTER_SURFACE INTERSHELL"<<endl;
      inp<<"  **remove_set"<<endl;
      inp<<"   *nsets INTER_EXT INTER_INT INTER_SURFACE0 INTER_SURFACE"<<endl;
      inp<<"   *bsets INTER_EXT INTER_INT INTER_SURFACE0 INTER_SURFACE"<<endl; 
      if(mode==11) inp<<"  **save "<<cracked_name<<"_TO_REMESH_2D.geo"<<endl;
      if((bset_to_elset!="")||(shell_offset!=0.)||(bset_boundary!="")) {
        // inp<<"  **unshared_edges "<<new_elset_name<<"_INT *elsets "<<new_elset_name<<endl;
        if(mode==11) {
          inp<<"  **bset_to_elset *bsets SMOOTHED_"<<new_elset_name<<" *elsets SMOOTHED_AUTO"<<endl;
          inp<<"  **elset to_del" << endl;
          inp<<"   *use_elsets SMOOTHED_"<<new_elset_name<<endl;
          inp<<"   *function 1.;"<<endl;
          inp<<"  **remove_set *bsets INTERSHELL"<<endl;
          inp<<"  **elset INTER_EXT *not_in_elset SMOOTHED_AUTO"<<endl;
          inp<<"  **unshared_edges INTER_EXT *elsets INTER_EXT"<<endl;
          inp<<"  **unshared_edges INTER_INT *elsets SMOOTHED_AUTO"<<endl;
          
          // Try with only AUTO name
          inp<<"  **remove_set *elsets "<<new_elset_name<<endl;
          inp<<"  **rename_set *elsets SMOOTHED_AUTO "<<new_elset_name<<endl;

          inp<<"  **join_bsets INTERSHELL *intersection"<<endl;
          inp<<"   *bsets INTER_INT INTER_EXT *remove_duplicates"<<endl;
          inp<<"  **remove_set"<<endl;
          inp<<"   *bsets INTER_EXT INTER_INT"<<endl; 
          inp<<"  "<<endl;
        } else {  
          inp<<"  **elset to_del" << endl;
          inp<<"   *use_elsets "<<new_elset_name<<endl;
          inp<<"   *function 1.;"<<endl;
        }
        inp<<"  **extrude_WC"<<endl;
        inp<<"   *elset "<<new_elset_name<<endl;
        if(delamin_set!="") inp<<"   *delamin "<<delamin_set<<endl;
        if(extrude_top!="") inp<<"   *bset_top "<<extrude_top<<endl;
        if(extrude_bottom!="") inp<<"   *bset_bottom "<<extrude_bottom<<endl;
        if(bset_boundary!="") {
          inp<<"   *bset_boundary "<<bset_boundary<<endl;
          inp<<"   *boundary2"<<endl;
          inp<<"   *liset_slider "<<liset_slider_name<<endl;
        }
        if(shell_offset!=0.) inp<<"   *offset "<<shell_offset<<endl;
        inp<<"   *thickness (";
        for(i=0;i<thickness.size();i++) 
          inp<<thickness[i]<<" ";
        inp<<")"<<endl;
        inp<<"  **delete_elset to_del"<<endl;
        if(bset_to_elset!="") {
          inp<<"  **bset_to_elset *bsets "<<bset_to_elset<<endl;
          inp<<"   *elsets "<<bset_to_elset<<endl;
          inp<<endl;
        }
      } else {
        inp<<"  **elset to_del *function 1.;"<<endl;
        inp<<"  **extrude_WC"<<endl;
        if(shell_offset!=0.) inp<<"   *offset "<<shell_offset<<endl;
        inp<<"   *thickness (";
        for(i=0;i<thickness.size();i++) 
          inp<<thickness[i]<<" ";
        inp<<")"<<endl;
        inp<<"  **delete_elset to_del"<<endl;
      }
  }

  inp<<"  **degenerated_elset *elset DEGENERATED_ELEMENTS"<<endl;
  inp<<"  **delete_elset DEGENERATED_ELEMENTS"<<endl;

  if(if_no_open==0) {
    if(if_2DE) inp<<"  **unshared_faces SURFACE"<<endl;
    else if(if_2D) inp<<"  **unshared_edges SURFACE"<<endl;
    else  inp<<"  **unshared_faces SURFACE"<<endl;

    inp<<"  **remove_set"<<endl;
    inp<<"   *nsets_start_with SIDE side FRONT ELSET_TO_CUT_BOUND0 ELSET_TO_CUT_BOUND"<<endl;
    inp<<"   *bsets_start_with SIDE side FRONT ELSET_TO_CUT_BOUND0 ELSET_TO_CUT_BOUND"<<endl;
    inp<<"   *elsets_start_with SIDE side"<<endl;
    inp<<endl;

    if(if_dislo) {
      if(!if_2D) inp<<"  **bset_align *bsets Nlip *normal (1. 0. 0.)"<<endl;
      if(elset_to_cut!="") {
        inp << "  **unshared_faces ELSET_TO_CUT_BOUND0 *elsets "<<elset_to_cut<<endl;
        inp << "  **join_bsets ELSET_TO_CUT_BOUND *bsets ELSET_TO_CUT_BOUND0 *remove_duplicates"<<endl;
      }
      inp<<"  **open_bset"<<endl;
      inp<<"   *create_origins"<<endl;
      if(elset_to_cut!="") {
        inp << "  *surface ELSET_TO_CUT_BOUND"<<endl;
        inp << "  *elset "<<elset_to_cut<<endl;
      } else inp<<"   *surface SURFACE"<<endl;
      inp<<"   *bset Nlip"<<endl;
      inp<<"   *branches"<<endl;
      inp<<"   "<<endl;
    } else {
      inp<<"  **open_bset"<<endl;
      inp<<"   *create_origins"<<endl;
      inp<<"   *surface SURFACE"<<endl;
      if(if_2DE) inp<<"  *bset Nlip_3D"<<endl;
      else inp<<"   *bset Nlip"<<endl;
      inp<<"   *branches"<<endl;
      if(if_czm) inp<<"   *create_interface"<<endl;
      inp<<"   "<<endl;
      inp<<"  **reassign_fronts"<<endl;
      inp<<"   *max_advance "<<(2.0*max_h)<<endl;
      inp<<"   *old_mesh TO_REMESH.geo"<<endl;
    }

    inp<<"  **remove_set *bsets CRACK_LIPS"<<endl;
    inp<<"  **join_bsets CRACK_LIPS *bsets SIDE0 SIDE1 *remove_duplicates"<<endl;

    if(sym_bset!="") {
      inp<<"  **remove_set *bsets FRONT_SYM FRONT_SYM0 FRONT_SYM1"<<endl;
      inp<<"  **bset FRONT_SYM0 *use_bset Nlip *no_sort *use_dimension 1"<<endl;
      inp<<"  **join_bsets FRONT_SYM1"<<endl;
      inp<<"   *intersection"<<endl;
      inp<<"   *bsets FRONT_SYM0 "<<sym_bset<<endl;
      inp<<"   *remove_duplicates"<<endl;
      inp<<"  **bset FRONT_SYM *use_bset FRONT_SYM1 *use_dimension 1"<<endl;
      inp<<"  **remove_set *bsets FRONT_SYM0 FRONT_SYM1"<<endl;
    } 

    if(nb_dd>1) {
      inp<<endl;
      inp<<"  **remove_set"<<endl;
      inp<<"   *elsets ELSET_FRONT"<<endl;
      inp<<"  **elset_near_nset "<<endl;
      inp<<"   *elset ELSET_FRONT"<<endl;
      inp<<"   *nset FRONT "<<endl;
      inp<<"   *radius .1"<<endl;
      inp<<"  **save FRONTS_MESH.geo"<<endl;
      inp<<"  **remove_set"<<endl;
      inp<<"   *elsets ELSET_FRONT"<<endl;
      inp<<endl;
    }

    if(if_dislo) {
      inp <<" **extends_dislo *nset";
      inp<<endl;
    }
  }

  inp<<"  **remove_set"<<endl;
  inp<<"   *elsets QUAD QUAD_EXT";
  inp<<"   *nsets SURFACE INTER_EXT INTER_INT INTER_SURFACE0 INTER_SURFACE QUAD_EXT QUAD_INT QUAD_INTER"<<endl;
  inp<<"   *bsets INTER_SURFACE QUAD_INTER"<<endl; 
 
  inp<<"  **nset lip *use_bset Nlip"<<endl;

  if(if_quad) {
    if(quad_opt) {
      inp<<"  **elset QUAD"<<endl;
      inp<<"   *use_elset AUTO"<<endl;
      inp<<"   *func 1.;"<<endl;
      inp<<"  **lin_to_quad"<<endl;
      inp<<"   *elset QUAD"<<endl;
      inp<<"   "<<endl;
 
    } else {
      inp<<"  **lin_to_quad"<<endl;
      inp<<"   "<<endl;
    }
    if(if_barsoum!=0) {
      for(i=0;i<nb_fronts;i++) {
        inp<<"  **crack_3d_quarter_nodes"<<endl;
        inp<<"   *liset FRONT"<<i<<endl;
      }
    }
  }

  if(if_hexa) { 
    inp<<"  **remove_set *elsets FREEMESH"<<endl;
    inp<<"  **elset FREEMESH *use_elset AUTO *not_in_elset REGULAR"<<endl;
  }

  if((!faset_names)!=0||((!liset_names)!=0)||((!ridge_names)!=0))
  inp<<"  **remove_set *nsets "<<faset_names<<" "<<liset_names <<" "<<liset_names <<endl;

  if(if_2D&&(!if_2DE)&&(!if_shell)) {
    inp << "  **NG_s3_to_c2"<<endl;
// EDF a commenter
    inp << "  **function \n   *ztrans 0.;" <<endl;
    inp << "  **to_2d" <<endl;
  }

  inp<<"  **cleanup_bsets"<<endl;

  if(if_must_define_elset && (elset_name != new_elset_name)) {
     inp<<"  **remove_set *elsets "<<elset_name<<"_OLD"<<endl;
     inp<<"  **rename_set"<<endl;
     inp<<"   *elsets "<<elset_name<<" "<<elset_name<<"_OLD"<<endl;
     inp<<"  **elset "<<elset_name<<endl;
     inp<<"   *use_elset "<<elset_name<<"_OLD "<<new_elset_name<<endl;
     inp<<"   *function 1.0;"<<endl;
     inp<<"  **remove_set *elsets "<<elset_name<<"_OLD"<<endl;
  }
  if(from_quad*if_quad*if_must_define_elset) {
     inp<<"  **restore_elset_ids"<<endl;
     inp<<"   *base_mesh TO_REMESH_QUADID.geo"<<endl;
     inp<<"   *elset "<<new_elset_name<<"_EXT"<<endl;
  }
  inp<<"  **remove_set"<<endl;
  inp<<"   *elsets "<<new_elset_name<<"_EXT";
  inp<<"   *nsets INTER_EXT INTER_INT INTER_SURFACE0 INTER_SURFACE"<<endl;
  inp<<"   *bsets INTER_EXT INTER_INT INTER_SURFACE0 INTER_SURFACE"<<endl; 

if(if_2DE){ 
    inp<<"  **to_3d *c2d_to_s3d"<<endl;
    inp<<"  **set_reduced *type normal *elset AUTO"<<endl;
  } else if(set_reduced){
    inp<<"  **set_reduced"<<endl;
    inp<<"  **remove_set"<<endl;
    inp<<"   *elsets_start_with c3d"<<endl;
    inp<<"  **elset_by_element_type"<<endl;
  } inp<<"  "<<endl;
  //inp<<"  **elset_by_element_type"<<endl;
  //inp<<"  **set_reduced"<<endl;
  //inp<<"   *type reduced"<<endl;

  // Dislocation propagations -> compute levelset
  //inp<<"   *elset c3d4 "<<endl;

  if(format=="aster_templated")
  {
        //ABR---06/2021
        inp<<"% ************************ Specific command for ASTER contact bset definitions ******"<<endl;
        //here we create a nset SIDE0_aster first and remove the FRONT nodes, which are common to SIDE1 and SIDE0!
        //These common nodes pose problem for aster contact definitions.
        inp<<"  **nset SIDE0_aster"<<endl;
        inp<<"   *use_bset SIDE0"<<endl;
        inp<<"  **remove_nodes_from_nset"<<endl;
        inp<<"   *nset_name SIDE0_aster"<<endl;
        inp<<"   *nsets_to_remove FRONT"<<endl;
        inp<<"  **bset SIDE0_aster"<<endl;
        inp<<"   *use_nset SIDE0_aster"<<endl;
        inp<<"  **bset SIDE1_aster"<<endl;
        inp<<"   *use_bset SIDE1"<<endl;
        inp<<"  **bset_align"<<endl;
        inp<<"   *bsets ALL"<<endl;
  }

  if(nb_dd>1) {
    inp<<endl;
    inp<<" ***mesh FRONTS_MESH.geo"<<endl;
    inp<<"  **open FRONTS_MESH.geo"<<endl;
    inp<<"  **elset to_del"<<endl;
    inp<<"   *not_in_elset ELSET_FRONT"<<endl;
    inp<<"  **delete_elset to_del"<<endl;
  } 
  if(if_dislo) {
    inp<<endl;
    inp<<" ***mesh REMESHED.geo"<<endl;
    inp<<"  **open REMESHED.geo"<<endl;
    inp<<"  **remove_set *bsets DISLO_FRONT *nsets DISLO_FRONT"<<endl;
    inp<<"  **unshared_edges DISLO_FRONT *bsets SIDE0"<<endl;
    inp<<"  **remove_nodes_from_nset *nset_name SURFACE *nsets_to_remove FRONT"<<endl;
    inp<<"  **remove_nodes_from_nset *nset_name DISLO_FRONT *nsets_to_remove SURFACE"<<endl;
    inp<<"  **elset_near_nset *nset DISLO_FRONT *radius "<< rcoarse <<" *distance_file FRONT_DST"<<endl;
    inp<<"  **remove_set *bsets DISLO_FRONT *nsets DISLO_FRONT SURFACE"<<endl;
    inp<<endl;
  }


  inp<<"****return"<<endl;
  inp.close();

}

double nice_refine(double &mwquality)
{
  int i,ret,lsz;
  double Imin_size,Ilip_tol,wquality;
  STRING str;

  STD_RM("REMESHED.geo");
  STD_RM("TO_REMESH.geo");
  STD_RM("MESHING_OUTPUT");
  apply_mesher(sane_name,"TO_REMESH.geo","");
  write_remesh_new(10);
  if(os != "win32") {
    //str=ZRUN_CMD+" -m "+cracked_name+"_REMESH.inp | tee MESHING_OUTPUT";
    str=ZRUN_CMD+" -m "+cracked_name+"_REMESH.inp >> MESHING_OUTPUT";
  }
  else str=ZRUN_CMD+" -m "+cracked_name+"_REMESH.inp >> MESHING_OUTPUT";
  STD_RM("MESHING_OUTPUT");
  ret = system(str);
  wquality=check_output("MESHING_OUTPUT");
  cout << endl<<"****** Worst element quality: "<< wquality<<endl<<flush; 
  STD_CP("REMESHED.geo",sane_name+"_REFINED.geo");
  return(wquality); 
}

// refine REMESHED mesh to improve quality
double refine_bad_quality(double &mwquality,double &eset_radius)
{
  int i,ret,Pnb_iter,Pif_must_define_elset,Pif_moving_elset,Pif_growing_elset,if_chgmc;
  double wquality,nwquality,Pelset_radius,Pquality_threshold;
  STRING str,Pcrack_name,Prefine_origin,Pnset_names,Prefine_function,Pyams_options;
  ASCII_FILE ascf;

  if(if_2D) STD_CP("_mesh_out_.mesh","KEPT.mesh");
  else STD_CP("_mesh_out_to_ghs3d.mesh","KEPT.mesh");

  if_chgmc=if_meshcleaner;
  // First run check quality mesher
  if(mwquality<0) {
    if_meshcleaner=1;
    mwquality=-mwquality;
  }
  if(if_must_define_elset) {
    str="**remove_set *elsets_start_with BAD_QUALITY *nsets origin **check_quality *elset_to_check "+elset_name+" *quality_threshold "+dtoa(mwquality)+" **nset origin *use_elset BAD_QUALITY_ELEMENTS *function 1.; \n **rename_set *elsets AUTO AUTO_AVANT";
  } else {
    str="**check_quality *quality_threshold "+dtoa(mwquality)+" **nset origin *use_elset BAD_QUALITY_ELEMENTS *function 1.; \n";
  }
  apply_mesher("REMESHED.geo", "REMESHED_TEST.geo",str,1);
  wquality=check_max_quality("ZCRACKS_MESHER.msg");

  if(wquality==-1) wquality=1.e5; 
 
  cout <<endl<< " *** WORST ELEMENT QUALITY: "<<wquality<<endl<<endl;
  if(wquality<mwquality) {
    STD_RM("REMESHED_TEST.geo");
    return(wquality);
  }

  // Quality is not good -> local remeshing
  cout <<endl<< " *** TRY TO IMPROVE RESULTING MESH QUALITY... "<<endl<<flush;

  // Save context
  Pnb_iter=nb_iter;
  Pif_must_define_elset=if_must_define_elset;
  Pif_moving_elset=if_moving_elset;
  Pif_growing_elset=if_growing_elset;
  Pelset_radius=elset_radius;
  Pcrack_name=crack_name;
  Prefine_origin=refine_origin;
  Pnset_names=nset_names;
  Prefine_function=refine_function;
  Pyams_options=yams_options;
  Pquality_threshold=quality_threshold;

  // Set context
  nb_iter=0;
  if_must_define_elset = 1;
  if_moving_elset=1;
  if_growing_elset=0;
  elset_radius=eset_radius;
  crack_name="";
  refine_origin="origin";
  nset_names=nset_names+" origin";
  refine_function=dtoa(min_size)+"+(sqrt(x*x+y*y+z*z)>"+dtoa(min_size)+")*(1.-1./1.3)*(sqrt(x*x+y*y+z*z)-"+dtoa(min_size)+");";
  yams_options=yams_options; //" --compute_ridges no";
  quality_threshold  = mwquality+.001;

  // Remesh attempt
  //ABR---modif made for Axel from Safran, to unblock the crack propag simulation on windows machine! This is a temporary fix
  //where the MV is replaced with CP and RM
  STD_CP("REMESHED.geo","REMESHED_INI.geo");
  ret = STD_RM("REMESHED.geo");
  if(ret==1) cout<<"Cannot clean REMESHED.geo"<<endl;
  STD_MV("REMESHED_TEST.geo","TO_REMESH.geo");
  write_remesh_new(10);
  STD_RM("OUTMSG");
  str=ZRUN_CMD+" -m "+cracked_name+"_REMESH.inp > OUTMSG";
  system(str);

  STD_RM("OUTMSG");
  cout <<"DONE."<<endl<<endl;

  if(!STD_FILE_EXISTS("REMESHED.geo")) {
    STD_MV("REMESHED_INI.geo","REMESHED.geo");
    cout<<"WARNING: Unable to remesh for quality improvement!"<<endl<<flush;

  } else {
    // Check resulting quality
    if(Pif_must_define_elset) {
      str="**remove_set *elsets BAD_QUALITY_ELEMENTS **check_quality *elset_to_check "+elset_name+" *quality_threshold "+dtoa(mwquality)+" **nset origin *use_elset BAD_QUALITY_ELEMENTS *function 1.; \n **rename_set *elsets AUTO AUTO_NEW **elset AUTO *use_elset AUTO_AVANT AUTO_NEW *function 1.; \n **remove_set *elsets AUTO_NEW AUTO_AVANT";
    } else {
      str="**remove_set *elsets BAD_QUALITY_ELEMENTS **check_quality *quality_threshold "+dtoa(mwquality)+" **nset origin *use_elset BAD_QUALITY_ELEMENTS *function 1.; \n **remove_set *elsets AUTO";
    }
    //using the same file locks the file on windows
    //apply_mesher("REMESHED.geo", "REMESHED.geo",str,1);
    apply_mesher("REMESHED.geo", "fake.geo",str,1);
    nwquality=check_max_quality("ZCRACKS_MESHER.msg");
  
    if_meshcleaner=if_chgmc;
    cout<<"After local remeshing worst element quality: "<<nwquality<<endl<<flush;
    if((nwquality<0)||(nwquality>wquality)) STD_MV("REMESHED_INI.geo","REMESHED.geo");
    else {
      wquality=nwquality;
      if(wquality>mwquality) {
        cout<<"Mesh quality is still above the required criterion!"<<endl<<flush;
      }
    }
  }

  // Restore context
  nb_iter=Pnb_iter;
  if_must_define_elset=Pif_must_define_elset;
  if_moving_elset=Pif_moving_elset;
  if_growing_elset=Pif_growing_elset;
  elset_radius=Pelset_radius;
  crack_name=Pcrack_name;
  refine_origin=Prefine_origin;
  nset_names=Pnset_names;
  refine_function=Prefine_function;
  yams_options=Pyams_options;
  quality_threshold=Pquality_threshold;
  
  if(if_2D) STD_MV("KEPT.mesh","_mesh_out_.mesh");
  else STD_MV("KEPT.mesh","_mesh_out_to_ghs3d.mesh");

  return(wquality);
}


double nice_cut(double &mwquality)
{
  int i,ret,lsz;
  double Imin_size,Ilip_tol,wquality;
  STRING str;
  ASCII_FILE ascf;

  if(format=="abaqus_templated"){
    if(if_barsoum && if_contact) ERROR("\nQuarter nodes elements can not be used in the contact zone.\nUncheck one of the options \"Quarter nodes\" or \"Lips contact\"");
  }

  if(if_barsoum && !mat_file && !is_ductile){
    ERROR("\nQuarter nodes elements can not be used in plasticity.\nUncheck \"Quarter nodes\" option or remove plastic model definition (\"Transfer mat file\" field)");
  }

  if(!if_quad && set_reduced){
    ERROR("\nReduced integration is not supported for all types of linear elements.\nUncheck \"Set reduced integration\" option or use quadratic elements");
  }

  if(new_version) {
      if(if_must_refine) {
        STD_RM("TO_REMESH.geo");
        if(nice_refine(mwquality)<0.) ERROR("\nRemeshing before insert failed!\nCheck if the initial mesh contains unconnected parts");
        apply_mesher("REMESHED.geo","TO_REMESH.geo","");
        STD_RM("REMESHED.geo");
        if(if_2DE) apply_mesher("TO_REMESH.geo",cracked_name+"_TO_REMESH_2D.geo","");
        STD_RM("REMESHED.geo");
      }
      else {
         STD_RM("MESHING_OUTPUT");
         apply_mesher(sane_name,"TO_REMESH.geo","");
         if(if_2DE) apply_mesher(sane_name,cracked_name+"_TO_REMESH_2D.geo","");
      }

      for(i=0;i<2;i++) {
        cout << endl <<" *** Try to insert ***" <<endl<<endl<<flush;   
        write_remesh_new(0); 
        if(os != "win32") {
          //str=ZRUN_CMD+" -m "+cracked_name+"_REMESH.inp | tee MESHING_OUTPUT";
          str=ZRUN_CMD+" -m "+cracked_name+"_REMESH.inp >> MESHING_OUTPUT";
        }
        else str=ZRUN_CMD+" -m "+cracked_name+"_REMESH.inp >> MESHING_OUTPUT";
      
        STD_RM("MESHING_OUTPUT");
        ret = system(str);
        ascf.open("REMESHED.geo");
        if(ascf.ok) {
          cout << endl <<" *** Insertion succeded! ***" <<endl<<endl<<flush;   
          ascf.close();
          break;
        } else {
          if(i==1) ERROR("\nCannot insert crack in the mesh, try to activate \"Refine before insert\" option\n");
          cout << endl <<" *** Insertion failed -> try again ! ***" <<endl<<endl<<flush;   
          apply_mesher(crack_name+".geo",crack_name+".geo","**translate *x -1.e-8 *y -1.e-8 *z -1.e-8");
          STD_RM("REMESHED.geo");
        }
      }
 
      // Try to increase mesh quality
      wquality=refine_bad_quality(mwquality,3.*min_size);

//      wquality=check_output("MESHING_OUTPUT");
      cout << endl<<"****** Worst element quality: "<< wquality<<endl<<flush; 
/*
      if(if_2D&&(!if_2DE)&&(!if_shell)) {
        STD_CP("REMESHED.geo",cracked_name+".geo3D");
        apply_mesher("REMESHED.geo",cracked_name+".geo","**to_2d");
      } else STD_CP("REMESHED.geo",cracked_name+".geo");
*/
      STD_CP("REMESHED.geo",cracked_name+".geo");
    
      return(wquality); 
  }

  Imin_size=min_size;
  Ilip_tol=lip_tol;
  for(i=0;i<8;i++) {
    if(i%3) mwquality=mwquality*2.5;
    write_refine_mesh();
    //cout << "Refining mesh... " << flush;
    if(nb_iter==0) lsz=440;
    else if(nb_iter==1) lsz=640;
    else lsz=620+330*(nb_iter-1);
    if(if_must_define_elset) lsz=lsz+200;
    str=gauge(lsz,"Refining mesh...");
    if(os != "win32") {
       str= ZRUN_CMD+" -m "+cracked_name+"_refine.inp | tee MESHING_OUTPUT"+str;
       STD_RM("MESHING_OUTPUT");
    }
    else str = ZRUN_CMD+" -m "+cracked_name+"_refine.inp";
    ret = system(str);
    wquality=check_output("MESHING_OUTPUT");
    cout << "Done." << endl
         << "Resulting refined mesh worst element quality:" << wquality << endl << flush ;
    if((wquality>0.)&&(wquality<2.*mwquality)) {
      min_size=Imin_size;
      write_cut_mesh();
      //cout << "Cutting mesh... " << flush;
      if(nb_iter==0) lsz=1500;
      else if(nb_iter==1) lsz=1700;
      else lsz=1700+330*(nb_iter-1);
      if(if_must_define_elset) lsz=lsz+200;
      str=gauge(lsz,"Cutting mesh...");
      if(os != "win32") {
         str= ZRUN_CMD+" -m "+cracked_name+"_cut.inp | tee MESHING_OUTPUT"+str;
         STD_RM("MESHING_OUTPUT");
      }
      else str = ZRUN_CMD+" -m "+cracked_name+"_cut.inp";
      ret = system(str);
      wquality=check_output("MESHING_OUTPUT");
      cout << "Done." << endl
           << "Resulting cut mesh worst element quality:" << wquality << endl << flush ;
      if((wquality>0.)&&(wquality<mwquality)) {
        cout << "Finished." << endl << flush;
        break; 
        // OK correct mesh 
      }
    } 
    cout << "Operation failed, retrying." << endl << flush;
    if(i%2) {
      nb_iter++;
      elset_radius=elset_radius*1.5;
    }
    min_size=min_size*.9;
    lip_tol=lip_tol*5.;
  }
  if(i>=8) return(-1.); 
  // ERROR("Unable to automatically insert crack, verify given meshes"); 
  lip_tol=Ilip_tol;
  return(wquality);
}



void do_command(STRING cmd)
{ 
  int ok,ret,i,cnt; 
  double wquality,mwquality,Imin_size, coef_value;
  STRING str,str_tmp,gnun,nm; 
  ARRAY<int> opt_fic;
  ASCII_FILE file;
  Zfstream out;

  if( (cmd != "OnInit")*(!cmd.start_with("Quit"))*(!cmd.start_with("import_mesh")) ) {
     if(format.end_with("templated")) {
        if(needs_read_template) {
           // fills faset_names_from_template that need to be preserved
           if(format=="ansys_templated")        read_ansys_template();
           else if(format=="abaqus_templated")  read_abaqus_template();
           else if(format=="aster_templated")   read_aster_template();
           else if(format=="samcef_templated")  read_samcef_template();
           else if(format=="zebulon_templated") read_z7_template();
        }
     }
  }

  if (cmd=="OnInit") {
    if(is_ductile) { 
         build_dialog_ductile();
         read_z7_template();
    }
    else build_dialog();
  } 
  else if(cmd.start_with("Save")) {
    if(embedded!=-1) 
      ret=read_dialog(); 
    else 
      ret=0;
    if(!ret) {
      write_data();
      if(init_values(1)==1) { 
        init_values(0);
        write_data();
        init_values(1); 
      }
    }
  }
  else if(cmd.start_with("Open")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) {
      if(init_values(1)!=0) ERROR("Unable to load: "+datafile);
      else update_dialog();
    }
  }
  else if(cmd.start_with("hide dialog ZCRACKS")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) {
      write_data();
      graphics_app.quit();
    }
  }
  else if(cmd.start_with("write_mesh_crack")) {
     if(embedded!=-1) ret=read_dialog(); else ret=0;
     if(!ret) {
       write_data();
       write_mesh_crack();
     }
  }
  else if(cmd.start_with("convert_surface")) {
     if(embedded!=-1) ret=read_dialog(); else ret=0;
     if(!ret) {
       write_data();
       convert_surface(surf_mesh);
     }
  }
  else if(cmd.start_with("intersect_mesh")) {
     if(embedded!=-1) ret=read_dialog(); else ret=0;
     if(!ret) {
       write_data();
       intersect(surf_mesh);
     }
  }
  else if(cmd.start_with("import_mesh")) {
     if(embedded!=-1) ret=read_dialog(); else ret=0;
     if(!ret) {
       write_data();
       ret = import_mesh(sane_name,format);
       needs_read_template=1;
     }
  }
  else if(cmd.start_with("export_mesh")) {
     if(embedded!=-1) ret=read_dialog(); else ret=0;
     if(!ret) {
       write_data();
       export_mesh(cracked_name,format);
     }
  }
  else if(cmd.start_with("check_import")) {
     if(embedded!=-1) ret=read_dialog(); else ret=0;
     if(!ret) {
       write_data();
       if(format.end_with("templated")) {
          ret = check_import_template();
       }
       else ERROR("\nCan only check import of templated format\n");
     }
  }
  else if(cmd.start_with("write_refine_mesh")) {
     if(embedded!=-1) ret=read_dialog(); else ret=0;
     if(!ret) {
       write_data();
       write_refine_mesh();
     }
  }
  else if(cmd.start_with("write_cut_mesh")) {
     if(embedded!=-1) ret=read_dialog(); else ret=0;
     if(!ret) {
       write_data();
       write_cut_mesh();
     }
  }
  else if(cmd.start_with("write_SIF")) {
     if(embedded!=-1) ret=read_dialog(); else ret=0;
     if(!ret) {
       write_data();
       write_SIF();
     }
  }
  else if(cmd.start_with("update_SIF")) {
     if(embedded!=-1) ret=read_dialog(); else ret=0;
     if(!ret) {
       write_data();
       if(update_SIF()) {
         ERROR("\nUnable to update SIF .inp. Check "+crack_name+"_SIF.inp\n");
       }
     }
  }
  else if(cmd.start_with("write_PROPAG")) {
     if(embedded!=-1) ret=read_dialog(); else ret=0;
     if(!ret) write_data();
     write_PROPAG();
  }
  else if(cmd.start_with("update_PROPAG")) {
     if(embedded!=-1) ret=read_dialog(); else ret=0;
     if(!ret) {
       write_data();
       if(format.end_with("templated")) {
         if(if_transfert * (!mat_file==0)) {
            ERROR("\nA Zmat material file is expected when Transfer state is activated\n");
         }
         else if(is_ductile){
           if(update_PROPAG_templated_ductile()) ERROR("\nUnable to update PROPAG z7p file for ductile computation\n");
         }
         else if(!is_ductile){
           if(update_PROPAG_templated()) ERROR("\nUnable to update PROPAG z7p file\n");
         }
       }
       else {
         if(update_PROPAG()) ERROR("\nUnable to update PROPAG .inp. Check "+crack_name+"_PROPAG.inp\n");
       }
     }
  }
  else if(cmd.start_with("view_surf_mesh")) {
    str= distene_path+"medit _mesh_out_.mesh &";
    cout<<"Running str="<<str<<endl<<flush;
    ret = system(str);
  }
  else if(cmd.start_with("view_vol_mesh")) {
    if(if_2D) str= distene_path+"medit _mesh_out_.mesh &";
    else str= distene_path+"medit _mesh_out_to_ghs3d.mesh &";
    cout<<"Running str="<<str<<endl<<flush;
    display_quality();
    ret = system(str);
  }
  else if(cmd.start_with("PV_vol_mesh")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) {
      write_data();
      str="~/bin/pv "+sane_name+" &";
      ret = system(str);
    }
  }
  else if(cmd.start_with("Zmaster_cut_mesh")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) {
      write_data();
      str="Zmaster "+cracked_name+" &";
      ret = system(str);
    }
  }
  else if(cmd.start_with("Zmaster_vol_mesh")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) {
      write_data();
      str="Zmaster "+sane_name+" &";
      ret = system(str);
    }
  }
  else if(cmd.start_with("Zmaster_crack")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) {
      write_data();
      str="Zmaster "+crack_name+" &";
      ret = system(str);
    }
  }
  else if(cmd.start_with("PV_crack")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) {
      write_data();
      str="~/bin/pv "+crack_name+".geo &";
      ret = system(str);
    }
  }
  else if(cmd.start_with("edit_SIF")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) {
      write_data();
      if(format.end_with("templated")) str= editor+" "+cracked_name+"_SIF.z7p &";
      else str= editor+" "+cracked_name+"_SIF.inp &";
      ret = system(str);
    }
  }
  else if(cmd.start_with("view_SIF")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) {
      write_data();
      if(format=="ansys_templated"){
         str= Zmaster;
         if(!mat_file) str=str+" -s RST.MatFile "+ mat_file;
         str=str+" "+cracked_name+"_SIF.rst &";

      }
      else if(format=="samcef_templated") str = Zmaster+" "+cracked_name+"_SIF_me.u18 &";
      else if(format=="abaqus_templated")  {
         str = "Zodb -G ";
         if(if_transfert) str = str + "-s ODB.AutoConvert 1 ";
         str = str+cracked_name+"_SIF.odb &";
      }
      else if(format=="aster_templated") str= Zmaster+" "+cracked_name+"_GPP_aster &";
      else str= Zmaster+" "+cracked_name+"_SIF &";
      ret = system(str);
    }
  }
  else if(cmd.start_with("paraview_SIF")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) {
      write_data();
      str= "~/bin/pv "+cracked_name+"_SIF.ut &";
      ret = system(str);
    }
  }
  else if(cmd.start_with("pp_SIF")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    zcpost_file=cracked_name+"_SIF_PP.ZCPOST"; 
    if(!ret) {
      write_data();
      if(update_SIF()) {
        ERROR("\nUnable to update SIF .inp. Check "+crack_name+"_SIF.inp\n");
      }
      if(is_ductile*if_CTOA) run_post_processing_cto();
      else                   run_post_processing();
    }
  }
  else if(cmd.start_with("compute_SIF")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    zcpost_file=cracked_name+"_GPP.ZCPOST";
    if(!ret) {
      write_data();
      if(update_SIF()) {
        ERROR("\nUnable to update SIF .inp. Check "+crack_name+"_SIF.inp\n");
      } 
      if(format.end_with("templated")) {
         if(!qsub_file_name){
            if(format=="abaqus_templated"){
               str = "qsub " + cracked_name+"_SIF.job";
               cout<<"Run : "<<str<<endl; cflush();
             }
             else
               ERROR("qsub submission is not implemented yet for "+format+ " format");
         }
         else str= ZRUN_CMD+" -zp "+cracked_name+"_SIF.z7p &";
      }
      else {
         if(debug=="GDB") str= ZRUN_CMD+" -db -smp "+itoa(smp)+" "+cracked_name+"_SIF.inp &";
         else str= ZRUN_CMD+" -smp "+itoa(smp)+" "+cracked_name+"_SIF.inp &";
      }
      ret = system(str);
      if(ret) {
        ERROR("\nUnable to run SIF computation. Check "+crack_name+"_SIF.inp\n");
      }
    }
  }


  if(cmd.start_with("edit_PROPAG")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) {
      write_data();
      if(format.end_with("templated")) {
         str= editor+" "+cracked_name+"_PROPAG.z7p &";
      }
      else {
         update_PROPAG();
         str= editor+" "+cracked_name+"_PROPAG.inp &";
      }
      ret = system(str);
    }
  }
  else if(cmd.start_with("plot_quality")) {
   if(embedded!=-1) ret=read_dialog(); else ret=0;
   if(!ret) {
     write_data();
     str="gnuplot -persist -e \"set title '"+cracked_name+"_PROPAG - FEM mesh worst element quality';set xlabel 'Number of remeshing'; set logscale y ; set grid ytics mytics xtics ; plot '"+cracked_name+"_PROPAG.mqlty' w lp t '';\" &";
      cout << str <<endl<<flush;
      ret = system(str);
    }
  }
  else if(cmd.start_with("edit_PLW")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) {
      write_data();
      update_PROPAG();
      str= editor+" "+sane_name+".plw &";
      ret = system(str);
    }
  }
  else if(cmd.start_with("kill_PROPAG")) {
    str= "kill `ps ux --cols 512 | grep "+cracked_name+"_PROPAG | grep Zebulon | awk '{print $2}' `"; 
    ret = system(str);
  }
  else if(cmd.start_with("kill_SIF")) {
    str= "kill `ps ux --cols 512 | grep "+cracked_name+"_SIF | grep Zebulon | awk '{print $2}' `"; 
    ret = system(str);
  }
  else if(cmd.start_with("kill_meshes")) {
    str= "kill `ps ux --cols 512 | grep "+cracked_name+"_refine | grep Zebulon | awk '{print $2}' `";
    ret = system(str);
    str= "kill `ps ux --cols 512 | grep "+cracked_name+"_cut | grep Zebulon | awk '{print $2}' `";
    ret = system(str);
    str= "pkill yams;pkill ghs3d;pkill meshadapt"; 
    ret = system(str);
  }
  else if(cmd.start_with("view_PROPAG")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) {
      write_data();
      if(format.end_with("templated")) {
         ret = 0;
         if(format.start_with("abaqus")) {
            str = "Zodb -G ";
            if(if_transfert) str = str + "-s ODB.AutoConvert 1 ";
            str = str+cracked_name+"_PROPAG"+itoa(nb_cycles)+".odb &";
         }
         else if(format.start_with("ansys"))  {
            str= Zmaster;
            if(!mat_file) str=str+" -s RST.MatFile "+ mat_file;
            str=str+" "+cracked_name+"_PROPAG"+itoa(nb_cycles)+".rst &";
         }
         else if(format.start_with("samcef")) {
            str = Zmaster+" "+cracked_name+"_PROPAG"+itoa(nb_cycles)+"_me.u18 &";
         }
         else if(format.start_with("aster")) {
            str = Zmaster+" "+cracked_name+"_GPP_PROPAG_aster"+itoa(nb_cycles);
         }
         else if(format.start_with("zebulon")) {
            str = Zmaster+" "+cracked_name+"_PROPAG"+itoa(nb_cycles);
         }
         else ret = 1;
         if(!ret) ret = system(str);
      }
      else {
         str="touch "+cracked_name+"_PROPAG.ut";
         ret = system(str);
         str= Zmaster+" "+cracked_name+"_PROPAG.ut &";
         ret = system(str);
      }
    }
  }
  else if(cmd.start_with("paraview_PROPAG")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) {
      write_data();
      str="touch "+cracked_name+"_PROPAG.ut";
      ret = system(str);
      str= "~/bin/pv "+cracked_name+"_PROPAG.ut &";
      ret = system(str);
    }
  }
  else if(cmd.start_with("compute_PROPAG")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) {
      write_data();
      if(format.end_with("templated")) {
        if(if_transfert * (!mat_file==0)) {
           ERROR("\nA Zmat material file is expected when Transfer state is activated\n");
        }
        else if(is_ductile){
          if(update_PROPAG_templated_ductile()) ERROR("\nUnable to update PROPAG z7p file for ductile computation\n");
        }
        else if(!is_ductile){
          if(update_PROPAG_templated()) ERROR("\nUnable to update PROPAG z7p file\n");
        }
      } else if(update_PROPAG()) {
        ERROR("\nUnable to update PROPAG .inp. Check "+crack_name+"_PROPAG.inp\n");
      }
      if(format.end_with("templated")) {
        if(!qsub_file_name){
           if(format=="abaqus_templated"){
             str = "qsub " + cracked_name+"_PROPAG.job";
             cout<<"Run : "<<str<<endl; cflush();
           }
           else
             ERROR("qsub submission is not implemented yet for "+format+ " format");
        }
        else str= ZRUN_CMD+" -zp "+cracked_name+"_PROPAG.z7p &";
      }
      else {
        if(debug=="GDB") str= ZRUN_CMD+" -db -smp "+itoa(smp)+" "+cracked_name+"_PROPAG.inp &";
        else str= ZRUN_CMD+" -smp "+itoa(smp)+" "+cracked_name+"_PROPAG.inp &";
      }
      ret = system(str);
      if(ret) {
        ERROR("\nUnable to run PROPAG computation. Check "+crack_name+"_PROPAG.inp\n");
      }
    }
  }

  if(cmd.start_with("mesh_all_crack")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) {
      write_data(); 
      ok=crack_id; 
      str_tmp=sane_name;
      for(i=0;i<=ok;i++) {
        crack_id=i;
        if(i==ok) sane_name=str_tmp; 
        else sane_name="";
        if(open_crack_info()) {
          sane_name=str_tmp;
          ERROR("\nUnable to open crack surface information for id:"+itoa(crack_id));
          crack_id=ok;
        } else {
          update_dialog();
          write_data();
        }
        write_mesh_crack();
        ret=do_mesh_crack(0);
        crack_id=ok;
        sane_name="";
        if(ret) {
          ERROR("\nUnable to create initial crack surface. Check "+crack_name+".inp\n");
        }
      }
      sane_name=str_tmp;
      crack_id=ok;
    }
  }
  else if(cmd.start_with("do_mesh_crack")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) {
      write_data();
      write_mesh_crack();
      ret=do_mesh_crack(1);
      if(ret) {
        ERROR("\nUnable to create initial crack surface. Check "+crack_name+".inp\n");
//        return(1);
      }
    }
  }
  else if(cmd.start_with("do_refine_mesh")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) {
      write_data();
      write_refine_mesh();
      ret=do_refine_mesh(1);
      if(ret) {
        ERROR("\nUnable to create refine sane mesh. Check "+cracked_name+"_refine.inp\n");
      }
    }
  }
  else if(cmd.start_with("lin_quad")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) {
      convert_quad(cracked_name+".geo");
    }
  } else if(cmd.start_with("nice_cut")) {
    STD_RM("open_bset.dat");
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(ret) ERROR("Unable to read dialog");
    write_data();
    if(nice_cut(max_quality)<0.) ERROR("Unable to automatically insert crack, verify given meshes"); 
    update_dialog();
  } else if(cmd.start_with("nice_refine")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(ret) ERROR("Unable to read dialog");
    write_data();
    if(nice_refine(20.)<0.) ERROR("Unable to automatically refine crack, verify given meshes"); 
    update_dialog();
  }





  // New part
  if(cmd.start_with("print_SIF")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) {
      str= editor+" FRONT"+itoa(front_view)+"_SIF &";
      ret = system(str);
    }
  }
  else if(cmd.start_with("print_PROPAG")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) {
      str= editor+" "+cracked_name+"_PROPAG.zck &";
      ret = system(str);
    }
  }
  else if(cmd.start_with("plot_AN")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) {
      write_data();
      gnun = "AN.gplt";
      ok = write_gnuplot_from_zck(0,gnun);
      if(ok) {
         str="gnuplot -e \"set title '"+cracked_name+"_PROPAG - A(N) for FRONT"+itoa(front_view)
           +"'; set grid ; set key outside; set key right top ; set yrange[0 to];set xlabel 'Mission number N';plot ";
         for(i=1;i<nb_pt;i++) str=str+"'"+gnun+"' u 1:"+itoa(i+1)+" w lp t 'a("+itoa(i)+",N)' ,"; 
         str=str+"'"+gnun+"' u 1:"+itoa(nb_pt+1)+" w lp t 'a("+itoa(nb_pt)+",N)'"; 
         str=str+";pause mouse close\" &";
         cout << str <<endl<<flush;
         ret = system(str);
      }
    }
  }
  else if(cmd.start_with("plot_VN")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) {
      write_data();
      gnun = "VN.gplt";
      ok = write_gnuplot_from_zck(1,gnun);
      if(ok) {
         str="gnuplot -e \"set title '"+cracked_name+"_PROPAG - dA/dN(N) for FRONT"+itoa(front_view)
             +"'; set grid ; set key outside; set key right top ; set logscale y; set grid ytics mytics xtics ;set xlabel 'Mission number N';plot ";
         for(i=1;i<nb_pt;i++) str=str+"'"+gnun+"' u 1:"+itoa(i+1)+" w lp t 'V("+itoa(i)+",N)' ,"; 
         str=str+"'"+gnun+"' u 1:"+itoa(nb_pt+1)+" w lp t 'V("+itoa(nb_pt)+",N)'"; 
         str=str+";pause mouse close\" &";
         cout << str <<endl<<flush;
         ret = system(str);
      }
    }
  }
  else if(cmd.start_with("plot_KN")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) {
      write_data();
      gnun = "KN.gplt";
      ok = write_gnuplot_from_zck(2,gnun);
      if(if_K) nm = "K";
      else     nm = "G";
      if(ok) {
         str="gnuplot -e \"set title '"+cracked_name+"_PROPAG - Kminmax(N) for FRONT"+itoa(front_view)
             +"';set grid ; set key outside; set key right top ; set xlabel 'Mission number N';plot ";
         count = 2;
         for(i=1;i<nb_pt;i++) {
            str=str+"'"+gnun+"' u 1:"+itoa(count)+" w lp t '"+nm+"min("+itoa(i)+",N)' ,"; 
            str=str+"'"+gnun+"' u 1:"+itoa(count+1)+" w lp t '"+nm+"max("+itoa(i)+",N)' ,"; 
            count=count+2;
         }
         str=str+"'"+gnun+"' u 1:"+itoa(count)+" w lp t '"+nm+"min("+itoa(nb_pt)+",N)' ,"; 
         str=str+"'"+gnun+"' u 1:"+itoa(count+1)+" w lp t '"+nm+"max("+itoa(nb_pt)+",N)'"; 
         str=str+";pause mouse close\" &";
         cout << str <<endl<<flush;
         ret = system(str);
      }
    }
  }
  else if(cmd.start_with("plot__TN")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) {
      write_data();
      gnun = "TN.gplt";
      ok = write_gnuplot_from_zck(3,gnun);
      if(ok) {
         str="gnuplot -e \"set title '"+cracked_name+"_PROPAG - Tminmax(N) for FRONT"+itoa(front_view)
             +"';set grid ; set key outside; set key right top ; set yrange[0 to];set xlabel 'Mission number N';plot ";
         count = 2;
         for(i=1;i<nb_pt;i++) {
            str=str+"'"+gnun+"' u 1:"+itoa(count)+" w lp t 'Tmin("+itoa(i)+",N)' ,"; 
            str=str+"'"+gnun+"' u 1:"+itoa(count+1)+" w lp t 'Tmax("+itoa(i)+",N)' ,"; 
            count=count+2;
         }
         str=str+"'"+gnun+"' u 1:"+itoa(count)+" w lp t 'Tmin("+itoa(nb_pt)+",N)' ,"; 
         str=str+"'"+gnun+"' u 1:"+itoa(count+1)+" w lp t 'Tmax("+itoa(nb_pt)+",N)'"; 
         str=str+";pause mouse close\" &";
         cout << str <<endl<<flush;
         ret = system(str);
      }
    }
  }
  else if(cmd.start_with("plot_PN")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) {
      write_data();
      ret=plot_fronts_zck(front_plane);
    }
  }
  else if(cmd.start_with("plot_VDK")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) {
      write_data();
      gnun = "VDK.gplt";
      ok = write_gnuplot_from_zck(4,gnun);
      if(if_K) nm = "K";
      else     nm = "G";
      if(ok) {
         str="gnuplot -e \"set title '"+cracked_name+"_PROPAG - dA/dN(N) for FRONT"+itoa(front_view)
             +"';set grid ; set key outside; set key right top ; set logscale y; set logscale x; set grid ytics mytics xtics mxtics ; set xlabel 'log Delta K';plot ";
         count = 1;
         for(i=1;i<nb_pt;i++) {
            str=str+"'"+gnun+"' u "+itoa(count)+":"+itoa(count+1)+" w lp t 'V("+itoa(i)+",D"+nm+")' ,"; 
            count=count+2;
         }
         str=str+"'"+gnun+"' u "+itoa(count)+":"+itoa(count+1)+" w lp t 'V("+itoa(i)+",D"+nm+")'"; 
         str=str+";pause mouse close\" &";
         cout << str <<endl<<flush;
         ret = system(str);
      }
    }
  }
  else if(cmd.start_with("plot_Ka")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) {
      write_data();
      gnun = "Ka.gplt";
      ok = write_gnuplot_from_zck(5,gnun);
      if(if_K) nm = "K";
      else     nm = "G";
      if(ok) {
         str="gnuplot -e \"set title '"+cracked_name+"_PROPAG - Kminmax(a) for FRONT"+itoa(front_view)
             +"';set grid ; set key outside; set key right top ;  set xlabel 'Front advanced length';plot ";
         count = 1;
         for(i=1;i<nb_pt;i++) {
            str=str+"'"+gnun+"' u "+itoa(count)+":"+itoa(count+1)+" w lp t '"+nm+"min("+itoa(i)+",a)' ,"; 
            str=str+"'"+gnun+"' u "+itoa(count)+":"+itoa(count+2)+" w lp t '"+nm+"max("+itoa(i)+",a)' ,"; 
            count=count+3;
         }
         str=str+"'"+gnun+"' u "+itoa(count)+":"+itoa(count+1)+" w lp t '"+nm+"min("+itoa(nb_pt)+",a)' ,"; 
         str=str+"'"+gnun+"' u "+itoa(count)+":"+itoa(count+2)+" w lp t '"+nm+"max("+itoa(nb_pt)+",a)'"; 
         str=str+";pause mouse close\" &";
         cout << str <<endl<<flush;
         ret = system(str);
      }
    }
  }
  else if(cmd.start_with("plot__Ta")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) {
      write_data();
      gnun = "Ta.gplt";
      ok = write_gnuplot_from_zck(6,gnun);
      if(ok) {
         str="gnuplot -e \"set title '"+cracked_name+"_PROPAG - Tminmax(a) for FRONT"+itoa(front_view)
             +"';set grid ; set key outside; set key right top ; set yrange[0 to]; set xlabel 'Front advanced length';plot ";
         count = 1;
         for(i=1;i<nb_pt;i++) {
            str=str+"'"+gnun+"' u "+itoa(count)+":"+itoa(count+1)+" w lp t 'Tmin("+itoa(i)+",a)' ,"; 
            str=str+"'"+gnun+"' u "+itoa(count)+":"+itoa(count+2)+" w lp t 'Tmax("+itoa(i)+",a)' ,"; 
            count=count+3;
         }
         str=str+"'"+gnun+"' u "+itoa(count)+":"+itoa(count+1)+" w lp t 'Tmin("+itoa(nb_pt)+",a)' ,"; 
         str=str+"'"+gnun+"' u "+itoa(count)+":"+itoa(count+2)+" w lp t 'Tmax("+itoa(nb_pt)+",a)'"; 
         str=str+";pause mouse close\" &";
         cout << str <<endl<<flush;
         ret = system(str);
      }
    }
  }
 
  if(cmd.start_with("plot_G")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) {
      write_data();
      reshape_front("FRONT"+itoa(front_view)+"_SIF","FRONT"+itoa(front_view)+"_SIF_rs",128);
      str="gnuplot -e \"set title '"+cracked_name+" - G for FRONT"+itoa(front_view)
            +"'; set grid ; set key outside; set key right top ; plot '"+
            "FRONT"+itoa(front_view)+"_SIF_rs' u 1:5 w l t 'G','"+
            "FRONT"+itoa(front_view)+"_SIF' u 1:5 lt 1 pt 7 notitle; "+
            "pause mouse close\" &";
      cout << str <<endl<<flush;
      ret = system(str);
    }
  }
  else if(cmd.start_with("plot_T")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) {
      write_data();
      reshape_front("FRONT"+itoa(front_view)+"_SIF","FRONT"+itoa(front_view)+"_SIF_rs",128);
      str="gnuplot -e \"set title '"+cracked_name+" - T for FRONT"+itoa(front_view)
          +"'; set grid ; set key outside; set key right top ; set yrange [0 to ]; plot '"+
          "FRONT"+itoa(front_view)+"_SIF_rs' u 1:6 w l t 'T','"+
          "FRONT"+itoa(front_view)+"_SIF' u 1:6 lt 1 pt 7 notitle; "+
          "pause mouse close\" &";
      cout << str <<endl<<flush;
      ret = system(str);
    }
  }
  else if(cmd.start_with("plot_CTOA")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) {
      write_data();
    //  reshape_front("FRONT"+itoa(front_view)+"_SIF","FRONT"+itoa(front_view)+"_SIF_rs",128);
    //  str="gnuplot -e \"set title '"+cracked_name+" - T for FRONT"+itoa(front_view)
    //      +"'; set grid; set yrange [0 to ]; plot '"+
    //      "FRONT"+itoa(front_view)+"_SIF_rs' u 1:6 w l t 'T','"+
    //      "FRONT"+itoa(front_view)+"_SIF' u 1:6 lt 1 pt 7 notitle; "+
    //      "pause mouse close\" &";
    //  cout << str <<endl<<flush;
    //  ret = system(str);
      ERROR("\nCTOA Plot is not yet available\n");
    }
  }
  else if(cmd.start_with("plot_a")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) {
      write_data();
      reshape_front("FRONT"+itoa(front_view)+"_SIF","FRONT"+itoa(front_view)+"_SIF_rs",128);
      str="gnuplot -e \"set title '"+cracked_name+" - angular dev for FRONT"+itoa(front_view)
          +"'; set grid ; set key outside; set key right top ; plot '"+
          "FRONT"+itoa(front_view)+"_SIF_rs' u 1:7 w l t 'alpha (degree)','"+
          "FRONT"+itoa(front_view)+"_SIF' u 1:7 lt 1 pt 7 notitle; "+
          "pause mouse close\" &";
      cout << str <<endl<<flush;
      ret = system(str);
    }
  }
  else if(cmd.start_with("plot_SIF")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) {
      write_data();
      reshape_front("FRONT"+itoa(front_view)+"_SIF","FRONT"+itoa(front_view)+"_SIF_rs",128);
      str="gnuplot -persist -e \"set title '"+cracked_name+" - SIF for FRONT"+itoa(front_view)
          +"'; set grid ; set key outside; set key right top ; plot '"+
          "FRONT"+itoa(front_view)+"_SIF_rs' u 1:8 w l t 'KI_opt','"+
          "FRONT"+itoa(front_view)+"_SIF' u 1:8 lt 1 pt 7 notitle,'"+
          "FRONT"+itoa(front_view)+"_SIF_rs' u 1:9 lt 3 w l t 'KI_ii','"+
          "FRONT"+itoa(front_view)+"_SIF' u 1:9 lt 3 pt 7 notitle,'"+
          "FRONT"+itoa(front_view)+"_SIF_rs' u 1:10 lt 4 w l t 'KII_ii','"+
          "FRONT"+itoa(front_view)+"_SIF' u 1:10 lt 4 pt 7 notitle,'"+
          "FRONT"+itoa(front_view)+"_SIF_rs' u 1:11 lt 8 w l t 'KIII_ii','"+
          "FRONT"+itoa(front_view)+"_SIF' u 1:11 lt 8 pt 7 notitle; "+
          "pause mouse close\" &";
      cout << str <<endl<<flush;
      ret = system(str);
    }
  }
  else if(cmd.start_with("plot_front")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) {
      write_data();
      if(format.end_with("templated")) write_front_file_from_zcpost();
      str="gnuplot -e \"set title '"+cracked_name+" - FRONT"+itoa(front_view)
          +"'; set grid ; set key outside; set key right top ; set size ratio -1; splot '"+
          "FRONT"+itoa(front_view)+"_FRONT' w lp notitle; pause mouse close \" &";
      cout << str <<endl<<flush;
      ret = system(str);
    }
  }
  else if(cmd.start_with("advanced_plot")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) {
      write_data();
      if(!built_advanced_plot_dialog) build_advanced_plot_dialog();
      graphics_app.realize("Advanced Plot");
      graphics_app.piece_command("Advanced Plot","Fronts","set_independant");
      graphics_app.piece_command("Advanced Plot","Fields","set_independant");
      graphics_app.piece_command("Advanced Plot","Times","set_independant");
      graphics_app.set_file_selection("Advanced Plot",".ZCPOST file",zcpost_file);
      ret = system(str);
    }
  }
  else if(cmd.start_with("do_cut_mesh")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) {
      write_data();
      write_cut_mesh();
      ret=do_cut_mesh(1);
      if(ret) {
        ERROR("\nUnable to create cut mesh. Check "+cracked_name+"_cut.inp\n");
      }
    }
  }
  if (cmd.start_with("Quit")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) write_data();
    graphics_app.quit();
  } else if (cmd.start_with("load_surface")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) {
      if(open_crack_info()) {
       ERROR("\nUnable to open crack surface information for id:"+itoa(crack_id));
      } else {
        update_dialog();
        write_data();
      }
    }
  } 

  if(cmd.start_with("update_HS")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) {
      write_data();
      if(update_HS()) {
        ERROR("\nUnable to update hotspot .inp. Check "+sane_name+"_HOTSPOT.inp\n");
      }
    }
  }
  else if(cmd.start_with("edit_HS")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) {
      write_data();
      str= editor+" "+sane_name+"_HOTSPOT.inp &";
      ret = system(str);
    }
  }
  else if(cmd.start_with("compute_HS")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) {
      write_data();
      update_HS();
      str= ZRUN_CMD+" -smp "+itoa(smp)+" "+sane_name+"_HOTSPOT.inp";
      ret = system(str);
      if(ret) {
        ERROR("\nUnable to compute hotspot analysis. Check "+sane_name+"_HOTSPOT.inp\n");
      }
      str= ZRUN_CMD+" -smp "+itoa(smp)+" -pp "+sane_name+"_HOTSPOT.inp";
      ret = system(str);
      if(ret) {
        ERROR("\nUnable to compute hotspot post processing. Check "+sane_name+"_HOTSPOT.inp\n");
      }
    }
  }
  else if(cmd.start_with("compute_PPHS")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) {
      write_data();
      update_HS();
      str= ZRUN_CMD+" -smp "+itoa(smp)+" -pp "+sane_name+"_HOTSPOT.inp";
      ret = system(str);
      if(ret) {
        ERROR("\nUnable to compute hotspot post processing. Check "+sane_name+"_HOTSPOT.inp\n");
      }
    }
  }
  else if(cmd.start_with("view_HS")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) {
      write_data();
      update_HS();
      str="touch "+sane_name+"_HOTSPOT.ut";
      ret = system(str);
      str= Zmaster+" "+sane_name+"_HOTSPOT.ut &";
      ret = system(str);
    }
  }
  else if(cmd.start_with("pv_HS")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) {
      write_data();
      update_HS();
      str="touch "+sane_name+"_HOTSPOT.ut";
      ret = system(str);
      str= "~/bin/pv "+sane_name+"_HOTSPOT.ut &";
      ret = system(str);
    }
  }
  else if(cmd.start_with("update_Z8")) {
    ret = update_Z8();
  }
  else if(cmd.start_with("edit_Z8")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) {
      str= editor+" "+cracked_name+"_z8.inp &";
      ret = system(str);
    }
  }
  else if(cmd.start_with("export_Z8")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) {
      if(format=="abaqus_templated") str = "Zodb -s ODB.AutoConvert 1";
      else                           str = "Zrun";
      str=str+" -concatenate_z8 "+cracked_name+"_z8";
      ret = system(str);
      if(ret) {
        ERROR("\nCannot create a Z8 database from templated cyclic results\n");
      }
    }
  }
  else if(cmd.start_with("zmaster_Z8")) {
    if(embedded!=-1) ret=read_dialog(); else ret=0;
    if(!ret) {
      str= Zmaster+" "+cracked_name+"_z8 &";
      ret = system(str);
    }
  }

  if(cmd.start_with("init_QS")) {
    init_qsubserver();
  } else if(cmd.start_with("close_QS")) {
    close_qsubserver();
  }

  if(cmd=="set_propag_coefs") {
    read_dialog();
    set_propag_coefs();
  }
  else if(cmd=="load_filter") {
    read_dialog();
    if(filter_type != "no_filter") {
       cout<<"Trying to load filter <"<<filter_type<<">";
       if(!filter_inp) cout<<" from file: "<<filter_inp;
       cout<<endl; cflush();
       propag_filter.set(Create_object("ZCRACKS_FILTER",filter_type));
       if(propag_filter.Null()) ERROR("Unknown propag filter: "+propag_filter);
       else {
          propag_filter.inp = filter_inp;
          ret = propag_filter.load();
          if(ret) cout<<"... problem loading filter"<<endl;
          else    cout<<"... ok"<<endl;
          cflush();
       }
    }
  }
  else if(cmd=="advanced_propag") {
      if(!built_advance_propag_dialog) build_advance_propag_dialog();
    graphics_app.realize("Advanced propag options");
    graphics_app.set_file_selection("Advanced propag options","Propag coefs file",propag_mat_file);
    graphics_app.set_file_selection("Advanced propag options","Propag script file",propag_script);
  }
  else if(cmd.start_with("hide dialog Advanced propag")) {
    read_advance_propag_dialog();
    graphics_app.deactivate("Advanced propag options");
  }
  else if(cmd=="edit_propag_coefs") {
    read_advance_propag_dialog();
    if(!propag_mat_file == 0) ERROR("\nThe propag coef file name field is empty\n");
    else {
        if(!built_edit_propag_coeff_dialog) build_edit_propag_coeff_dialog();
       graphics_app.realize("Edit propag coefs");
       graphics_app.set_label("Edit propag coefs","Edit coefs label","file: "+propag_mat_file);
       file.open(propag_mat_file);
       if(file.ok) {
          file.close();
          graphics_app.set_text_from_file("Edit propag coefs","ADVANCED_PROPAG_EDIT",propag_mat_file);
          graphics_app.set_editable("Edit propag coefs","ADVANCED_PROPAG_EDIT",1);
       }
    }
  }
  else if(cmd=="save_propag_coefs") {
    str = graphics_app.get_text("Edit propag coefs","ADVANCED_PROPAG_EDIT");
    out.open(propag_mat_file,ios::out);
    out<<str;
    out.close();
  }
  else if(cmd.start_with("hide dialog Edit propag coefs")) {
    read_advance_propag_dialog();
    graphics_app.deactivate("Edit propag coefs");
  }
  else if(cmd=="edit_propag_script") {
    read_advance_propag_dialog();
    if(!propag_script == 0) ERROR("\nThe propag script file name field is empty\n");
    else {
       if(!built_edit_propag_script_dialog) build_edit_propag_script_dialog();
       graphics_app.realize("Edit propag script");
       graphics_app.set_label("Edit propag script","Edit script label","file: "+propag_script);
       file.open(propag_script);
       if(file.ok) {
          file.close();
          graphics_app.set_text_from_file("Edit propag script","ADVANCED_PROPAG_SCRIPT",propag_script);
          graphics_app.set_editable("Edit propag script","ADVANCED_PROPAG_SCRIPT",1);
       }
    }
  }
  else if(cmd=="get_sample_script") {
    str = "sample_paris_law.z7p";
    cmd = getenv("Z7PATH")+"/lib/Scripts/"+str;
    STD_CP(cmd,str);
    graphics_app.set_file_selection("Advanced propag options","Propag script file",str);
  }
  else if(cmd=="test_propag_script") test_propag_script();
  else if(cmd=="save_propag_script") {
    str = graphics_app.get_text("Edit propag script","ADVANCED_PROPAG_SCRIPT");
    out.open(propag_script,ios::out);
    out<<str;
    out.close();
  }
  else if(cmd.start_with("hide dialog Edit propag script")) {
    read_advance_propag_dialog();
    graphics_app.deactivate("Edit propag script");
  }
  else if(cmd=="write_propag_mat_file") {
    ret = 1;
    for(i=0;i<!propag_coefficients;i++) {
       if(!propag_coefficients[i].constant) { ret=0; break; }
    }
    if(ret) {
       cout<<endl<<"Writing file: "<<propag_mat_file<<endl<<endl; cflush();
       out.open(propag_mat_file,ios::out);
       out.setf(ios::scientific);
       for(i=0;i<!propag_coef_names;i++) {
          str = graphics_app.get_text_field("Set coefficients",propag_coef_names[i]);
          coef_value = str.to_double();
          out<<propag_coef_names[i]<<" "<<coef_value<<endl;
       }
    }
    else ERROR("\nSome coefficients are not constant in file: "+propag_mat_file+"\nPlease use rather the Edit script command to change the definition\n");
  }
  else if(cmd=="plot_propag_law") {
    do_command("write_propag_mat_file");
    gnun = "daDK.gplt";
    ok = write_gnuplot_from_propag_law(gnun);

    if(if_K) nm = "K";
    else     nm = "G";
    if(ok) {
       str="gnuplot -e \"set title '"+cracked_name+"_PROPAG - dA/dN(N)';set grid ; set key outside; set key right top ; set logscale y; set logscale x; set grid ytics mytics xtics mxtics ; set xlabel 'log Delta "+nm+"';plot ";
       if(propag_model == "paris_std"){
         str=str+"'"+gnun+"' u 1:2 w lp t 'V(D"+nm+")'";
       } else {
         cnt=0;
         for(i=0;i<load_factor.size()*2;i+=2){
           //str=str+"'"+gnun+"' u "+itoa(i+1)+":"+itoa(i+2)+" w lp t 'V(D"+nm+" "+itoa(i)+")' ,";
           str=str+"'"+gnun+"' u "+itoa(i+1)+":"+itoa(i+2)+" w lp t 'R="+dtoa(load_factor[cnt])+"' ,";
           cnt++;
         }
       }
       str=str+";pause mouse close\" &";
       cout << str <<endl<<flush;
       ret = system(str);

    }
  }
  else if(cmd.start_with("hide dialog Set coefficients")) {
    graphics_app.destroy_dialog("Set coefficients");
  }
  else if(cmd == "get_default_contact") {
    contact_cmds = graphics_app.get_file_selection(dname,"Contact special");
    ret = get_default_contact();
  }
  else if(cmd=="edit_contact") {
    contact_cmds = graphics_app.get_file_selection(dname,"Contact special");
    if(!contact_cmds==0) {
       ERROR("\nNo name defined for the contact cmd file\n");
    }
    else {
       str= editor+" "+contact_cmds+" &";
       ret = system(str);
    }
  }else if(cmd == "set_hexa_params") {
    if(!built_hexa_dialog) build_hexa_dialog();
    graphics_app.realize("Set hexa params");
    graphics_app.set_text_field("Set hexa params","--nb-hexa",itoa(nb_hexa));
    graphics_app.set_text_field("Set hexa params","--th-hexa",itoa(th_hexa));
    graphics_app.set_text_field("Set hexa params","--nc-hexa",itoa(nc_hexa));
    graphics_app.set_text_field("Set hexa params","--dr-hexa",dtoa(dr_hexa));
    graphics_app.set_text_field("Set hexa params","--prog-hexa",dtoa(prog_hexa));
  }else if(cmd.start_with("hide dialog Set hexa params")) {
    read_hexa_dialog();
    graphics_app.deactivate("Set hexa params");
    if(built_hexa_help_dialog) graphics_app.deactivate("Help hexa params");
  }else if(cmd == "show_hexa_help") {
    if(!built_hexa_help_dialog) build_hexa_help_dialog();
    graphics_app.realize("Help hexa params");
  }else if(cmd.start_with("hide dialog Help hexa params")) {
    graphics_app.deactivate("Help hexa params");

  }else if(cmd == "set_quad_params") {
    if(!built_quad_dialog) build_quad_dialog();
    graphics_app.realize("Set quad params");
    graphics_app.set_radio_group("Set quad params","Quadratic choice",quad_opt);
    opt_fic.resize(1); opt_fic[0]=if_barsoum;
    graphics_app.set_check_group("Set quad params","Quadratic options 2",opt_fic);

  }else if(cmd.start_with("hide dialog Set quad params")) {
    read_quad_dialog();
    graphics_app.deactivate("Set quad params");
    if(built_quad_help_dialog) graphics_app.deactivate("Help quad params");
  }else if(cmd == "show_quad_help") {
    if(!built_quad_help_dialog) build_quad_help_dialog();
    graphics_app.realize("Help quad params");
  }else if(cmd.start_with("hide dialog Help quad params")) {
    graphics_app.deactivate("Help quad params");
  }


  if(cmd.start_with("hide dialog Advanced Plot")) {
    graphics_app.deactivate("Advanced Plot");
  } else if(cmd=="read_zcpost_file") {
    read_advance_plot_dialog(); 
  } else if(cmd=="plot_selec") {
    plot_selec_dialog(); 
  }

//  return(0);
}

int read_ansys_template()
{ STRING fname, name;
  ASCII_FILE tempf, ut_therm;
  LIST<STRING > tmp_names; // because resize was not implemented
  LIST<STRING > ns_names; // for preserve_nsets
  LIST<STRING > gm_names; // for preserve_geom
  int i, num, real_num;

  get_sane_name();
  fname = sane_name + ".dtpl";
  tempf.open(fname);
  //cout<<"Try to open template file: "<<fname<<endl; cflush();
  if(!tempf.ok) {
     ERROR("\nCannot find template file: "+fname+"\n");
     return(1);
  }
  faset_names_from_template.resize(0);
  geom_names_from_template.resize(0);
  tempf.locate("**max_ids");
  if(tempf.ok) {
    i = tempf.getint();
    if(i>=0) max_node_id = i;
    if(tempf.ok) {
       i = tempf.getint();
       if(i>=0) max_ele_id = i;
    }
  }
  tempf.locate("**contact");
  if(tempf.ok) {
     //cout<<"Found **contact"<<endl; cflush();
     for(i=0;i>=0;i++) {
        tempf.getint();     // ansys type not used
        if(!tempf.ok) break;
        num = tempf.getint(); // et num used in the bset name
        if(!tempf.ok) break;
        real_num=tempf.getint();
        if(!tempf.ok) break;
        name = "BSET"+itoa(num)+"_"+itoa(real_num);
        tmp_names.add(name); 
     }
  }
/*
  tempf.locate("***materials");
  if(tempf.ok) {
     for(i=0;i>=0;i++) {
        name = tempf.getSTRING();
        if(name.start_with("*")) { tempf.back(); break; }
        material_elsets.add_if_not_in(name);
        num = tempf.getint(); // mat num
        if(!tempf.ok) break;
     }
  }
*/
  tempf.locate("***pressure");
  if(tempf.ok) {
     //cout<<"Found **pressure"<<endl; cflush();
     for(i=0;i>=0;i++) {
        str = tempf.getSTRING();
        if(str.start_with("*")) break;
        if(str.is_int()) {
           //str.to_int()();     // ansys type not used
           num = tempf.getint(); // et num used in the bset name
           if(!tempf.ok) break;
           name = "BSET"+itoa(num);
           if(!tmp_names.is_in(name)) tmp_names.add(name);
           str = tempf.getSTRING();
           if(str=="local") {
              tempf.getSTRING(); // local num not used
           }
           else tempf.back();
        }
        else if(str=="SFE_VOLUMIC") tmp_names.add("SFE_VOLUMIC");
     }
  }
  tempf.locate("***nset_to_bsets");
  if(tempf.ok) {
     for(i=0;i>=0;i++) {
        name = tempf.getSTRING();
        if(!tempf.ok) break;
        if(name.start_with("*")) { tempf.back(); break; }
        tmp_names.add(name);
     }
  }
  tempf.locate("***preserve_nsets");
  if(tempf.ok) {
     for(i=0;i>=0;i++) {
        name = tempf.getSTRING();
        if(!tempf.ok) break;
        if(name.start_with("*")) { tempf.back(); break; }
        ns_names.add(name);
     }
  }
  tempf.locate("***preserve_geom");
  if(tempf.ok) {
     for(i=0;i>=0;i++) {
        name = tempf.getSTRING();
        if(!tempf.ok) break;
        if(name.start_with("*")) { tempf.back(); break; }
        gm_names.add(name);
     }
  }
  tempf.locate("***thermal_fields");
  if(tempf.ok) {
     thermal_field = tempf.getSTRING();
     ut_therm.open((thermal_field+".ut"));
     if(!ut_therm.ok) {
         ERROR("\nNo thermal files:"+thermal_field+".ut as specified in template: "+fname+"\n");
         thermal_field = "";
     }
  }
  tempf.locate("***finite_strain");
  if(tempf.ok) {
     finite_strain = 1;
  }
  faset_names_from_template.resize(!tmp_names);
  for(i=0;i<!tmp_names;i++) faset_names_from_template[i] = tmp_names[i];

  nset_names_from_template.resize(!ns_names);
  for(i=0;i<!ns_names;i++) nset_names_from_template[i] = ns_names[i];

  geom_names_from_template.resize(!gm_names);
  for(i=0;i<!gm_names;i++) geom_names_from_template[i] = gm_names[i];

  needs_read_template = 0;
  return(0);
}

int read_abaqus_template()
{ STRING fname, name,type, loc_frame_fname;
  ASCII_FILE tempf, ut_therm;
  LIST<STRING > tmp_names; // because resize was not implemented
  LIST<STRING > ns_names; // for preserve_nsets
  LIST<STRING > tmp_lf_types; //_lf_ means local frame
  LIST<STRING > tmp_lf_nset_names;
  LIST<VECTOR > tmp_lf_defs;
  VECTOR def;
  int i, num;

  Zfstream loc_frame;

  if(!batch_mode) get_sane_name();
  if(!sane_name ==0) return(0);

  fname = sane_name + ".dtpl";
  tempf.open(fname);
  cout<<"Try to open template file: "<<fname<<endl; cflush();
  if(!tempf.ok) {
     ERROR("\nCannot find template file: "+fname+"\n");
     return(1);
  }
  faset_names_from_template.resize(0);
  tempf.locate("**max_ids");
  if(tempf.ok) {
    i = tempf.getint();
    if(i>=0) max_node_id = i;
    if(tempf.ok) {
       i = tempf.getint();
       if(i>=0) max_ele_id = i;
    }
  }
  tempf.locate("***preserve_bsets");
  if(tempf.ok) {
     for(i=0;i>=0;i++) {
        name = tempf.getSTRING();
        if(!tempf.ok) break;
        if(name.start_with("*")) { tempf.back(); break; }
        tmp_names.add(name);
     }
  }
  tempf.locate("***nset_to_bsets");
  if(tempf.ok) {
     for(i=0;i>=0;i++) {
        name = tempf.getSTRING();
        if(!tempf.ok) break;
        if(name.start_with("*")) { tempf.back(); break; }
        tmp_names.add(name);
     }
  }
  tempf.locate("***preserve_nsets");
  if(tempf.ok) {
     for(i=0;i>=0;i++) {
        name = tempf.getSTRING();
        if(!tempf.ok) break;
        if(name.start_with("*")) { tempf.back(); break; }
        ns_names.add(name);
     }
  }
  tempf.locate("***thermal_fields");
  if(tempf.ok) {
     thermal_field = tempf.getSTRING();
     ut_therm.open((thermal_field+".ut"));
     if(!ut_therm.ok) {
         ERROR("\nNo thermal files:"+thermal_field+".ut as specified in template: "+fname+"\n");
         thermal_field = "";
     }
  }
  tempf.locate("***local_frame");
  if(tempf.ok) {
     loc_frame_fname = sane_name+"_local_frame.dat";
     loc_frame.open(loc_frame_fname,ios::out);
     loc_frame.setf(ios::scientific);
     loc_frame.precision(64);

     for(i=0;i>=0;i++) {
        type = tempf.getSTRING();
        if(type.start_with("*")) { tempf.back(); break; }
        name = tempf.getSTRING();
        loc_frame<<"**local_frame "<<name<<endl;
        loc_frame<<" *"<<type<<endl;

        def.resize(6);
        for(j=0;j<6;j++) {
          def[j] = tempf.getdouble();
          if(!tempf.ok) break;
        }

        if(type.start_with("cartesian")){
          loc_frame<<"   x1 "<<def[0]<<" "<<def[1]<<" "<<def[2]<<endl;
          loc_frame<<"   x2 "<<def[3]<<" "<<def[4]<<" "<<def[5]<<endl;
        }
        else if(type.start_with("cyl")){
          loc_frame<<"   ("<<def[0]<<" "<<def[1]<<" "<<def[2]<<")"<<endl;
          loc_frame<<"   ("<<def[3]<<" "<<def[4]<<" "<<def[5]<<")"<<endl;
        }
        
        tmp_lf_types.add(type);
        tmp_lf_nset_names.add(name);
        tmp_lf_defs.add(def);
     }
     local_frame_fname_from_template = loc_frame_fname;
  }
  tempf.locate("***finite_strain");
  if(tempf.ok) {
     finite_strain = 1;
  }
  tempf.locate("***plasticity");
  if(tempf.ok) {
     is_plastic = 1;
  }
  faset_names_from_template.resize(!tmp_names);
  for(i=0;i<!tmp_names;i++) faset_names_from_template[i] = tmp_names[i];

  nset_names_from_template.resize(!ns_names);
  for(i=0;i<!ns_names;i++) nset_names_from_template[i] = ns_names[i];

  needs_read_template = 0;
  return(0);
}

int read_samcef_template()
{ STRING fname, name,type, loc_frame_fname, fname2;
  ASCII_FILE tempf, ut_therm;
  LIST<STRING > tmp_names; // because resize was not implemented
  LIST<STRING > ns_names; // for preserve_nsets
  LIST<STRING > tmp_lf_types; //_lf_ means local frame
  LIST<STRING > tmp_lf_nset_names;
  LIST<VECTOR > tmp_lf_defs;
  VECTOR def;
  int i, num;

  Zfstream loc_frame;

  get_sane_name();
  if(!sane_name ==0) return(0);

  fname = sane_name + ".dtpl";
  tempf.open(fname);
  cout<<"Try to open template file: "<<fname<<endl; cflush();
  if(!tempf.ok) {
     ERROR("\nCannot find template file: "+fname+"\n");
     return(1);
  }
  faset_names_from_template.resize(0);
  tempf.locate("**max_ids");
  if(tempf.ok) {
    i = tempf.getint();
    if(i>=0) max_node_id = i;
    if(tempf.ok) {
       i = tempf.getint();
       if(i>=0) max_ele_id = i;
    }
  }
  tempf.locate("***materials");
  if(tempf.ok) {
     for(i=0;i>=0;i++) {
        name = tempf.getSTRING();
        if(!tempf.ok) break;
        if(name.start_with("*")) { tempf.back(); break; }
        fname2 = tempf.getSTRING();
        if(!tempf.ok) break;
        if(fname2.start_with("*")) { tempf.back(); break; }
        material_elsets.add(name);
        material_files.add(fname2);
     }
  }
  tempf.locate("***preserve_bsets");
  if(tempf.ok) {
     for(i=0;i>=0;i++) {
        name = tempf.getSTRING();
        if(!tempf.ok) break;
        if(name.start_with("*")) { tempf.back(); break; }
        tmp_names.add(name);
     }
  }
  tempf.locate("***nset_to_bsets");
  if(tempf.ok) {
     for(i=0;i>=0;i++) {
        name = tempf.getSTRING();
        if(!tempf.ok) break;
        if(name.start_with("*")) { tempf.back(); break; }
        name = name + "_bset";
        tmp_names.add(name);
     }
  }
  tempf.locate("***preserve_nsets");
  if(tempf.ok) {
     for(i=0;i>=0;i++) {
        name = tempf.getSTRING();
        if(!tempf.ok) break;
        if(name.start_with("*")) { tempf.back(); break; }
        ns_names.add(name);
     }
  }
  tempf.locate("***thermal_fields");
  if(tempf.ok) {
     thermal_field = tempf.getSTRING();
     if(!thermal_field.end_with(".ut")) thermal_field = thermal_field + ".ut";
     ut_therm.open((thermal_field));
     if(!ut_therm.ok) {
         ERROR("\nNo thermal files:"+thermal_field+".ut as specified in template: "+fname+"\n");
         thermal_field = "";
     }
  }
  tempf.locate("***finite_strain");
  if(tempf.ok) {
    finite_strain = 1;
  }

  faset_names_from_template.resize(!tmp_names);
  for(i=0;i<!tmp_names;i++) faset_names_from_template[i] = tmp_names[i];

  nset_names_from_template.resize(!ns_names);
  for(i=0;i<!ns_names;i++) nset_names_from_template[i] = ns_names[i];

  needs_read_template = 0;
  return(0);
}

int read_aster_template()
{ STRING fname, name;
  LIST<STRING > tmp_names; // because resize was not implemented
  ASCII_FILE tempf, ut_therm;
  int i;

  get_sane_name();
  fname = sane_name + ".dtpl";
  tempf.open(fname);
  cout<<"Try to open template file: "<<fname<<endl; cflush();
  if(!tempf.ok) {
     ERROR("\nCannot find template file: "+fname+"\n");
     return(1);
  }

  tempf.locate("***thermal_fields");
  if(tempf.ok) {
     thermal_field = tempf.getSTRING();
     ut_therm.open((thermal_field+".ut"));
     if(!ut_therm.ok) {
         ERROR("\nNo thermal files:"+thermal_field+".ut as specified in template: "+fname+"\n");
         thermal_field = "";
     }
  }

  faset_names_from_template.resize(0);
  tempf.locate("***preserve_bsets");
  if(tempf.ok) {
     for(i=0;i>=0;i++) {
        name = tempf.getSTRING();
        if(!tempf.ok) break;
        if(name.start_with("*")) { tempf.back(); break; }
        tmp_names.add(name);
     }
  }
  tempf.locate("***nset_to_bsets");
  if(tempf.ok) {
     for(i=0;i>=0;i++) {
        name = tempf.getSTRING();
        if(!tempf.ok) break;
        if(name.start_with("*")) { tempf.back(); break; }
        tmp_names.add(name);
     }
  }

  if(!tmp_names) {
     faset_names_from_template.resize(!tmp_names);
     for(i=0;i<!tmp_names;i++) faset_names_from_template[i] = tmp_names[i];
  }

  needs_read_template = 0;
  return(0);
}



int read_z7_template()
{ STRING fname, name;
  LIST<STRING > tmp_names; // because resize was not implemented
  ASCII_FILE tempf, ut_therm;
  int i;
  double d;

  get_sane_name();
  fname = sane_name + ".dtpl";
  tempf.open(fname);
  cout<<"Try to open template file: "<<fname<<endl; cflush();
  if(!tempf.ok) {
     fname = sane_name + ".geo";
     tempf.open(fname);
     if(!tempf.ok) {
       fname = sane_name + ".geof";
       tempf.open(fname);
       if(!tempf.ok) {
         ERROR("\nCannot find template or .geo(f) file: "+fname+"\n");
         return(1);
       } 
     }
     return(0);
  }

  tempf.locate("***max_ids");
  if(tempf.ok) {
    i = tempf.getint();
    if(i>=0) max_node_id = i;
    if(tempf.ok) {
       i = tempf.getint();
       if(i>=0) max_ele_id = i;
    }
  }

  tempf.locate("**total_time");
  if(tempf.ok) {
    d = tempf.getdouble();
    if(d>=0.) ductile_Tt = d;
  }

  tempf.locate("***thermal_fields");
  if(tempf.ok) {
     thermal_field = tempf.getSTRING();
     ut_therm.open((thermal_field+".ut"));
     if(!ut_therm.ok) {
         ERROR("\nNo thermal files:"+thermal_field+".ut as specified in template: "+fname+"\n");
         thermal_field = "";
     }
  }

  faset_names_from_template.resize(0);
  tempf.locate("***preserve_bsets");
  if(tempf.ok) {
     for(i=0;i>=0;i++) {
        name = tempf.getSTRING();
        if(!tempf.ok) break;
        if(name.start_with("*")) { tempf.back(); break; }
        tmp_names.add(name);
     }
  }
  tempf.locate("***nset_to_bsets");
  if(tempf.ok) {
     for(i=0;i>=0;i++) {
        name = tempf.getSTRING();
        if(!tempf.ok) break;
        if(name.start_with("*")) { tempf.back(); break; }
        tmp_names.add(name);
     }
  }

  tempf.locate("***material");
  if(tempf.ok) {
     material_from_template="";
     for(i=0;i>=0;i++) {
        name = tempf.getSTRING();
        if(!tempf.ok) break;
        if(name.start_with("***")) { tempf.back(); break; }
        material_from_template=material_from_template+" "+name; 
     }
  }
  tempf.locate("***finite_strain");
  if(tempf.ok) {
     finite_strain = 1;
  }

  if(!tmp_names) {
     faset_names_from_template.resize(!tmp_names);
     for(i=0;i<!tmp_names;i++) faset_names_from_template[i] = tmp_names[i];
  }

  needs_read_template = 0;
  return(0);
}

int update_SIF_templated()
{ int got_job;
  ASCII_FILE z7p0;
  Zfstream z7p, transfer, export;
  STRING str, z7p_name, fe_cmd, zrun_cmd, geof_name,cmd,tmp, gpp_aster_name;

  got_job = 0;

  geof_name=cracked_name;

  if(format=="abaqus_templated"){
    if(if_barsoum && if_contact) ERROR("\nQuarter nodes elements can not be used in the contact zone.\nUncheck \"Quarter nodes\" option and rebuild the cracked mesh.");
  }

  if(if_barsoum && !mat_file && !is_ductile){
    ERROR("\nQuarter nodes elements can not be used in plasticity.\nUncheck \"Quarter nodes\" option and rebuild the cracked mesh.");
  }

  z7p_name = cracked_name + "_SIF" + ".z7p";
  z7p0.open(z7p_name);
  if(z7p0.ok) {
     cout<<"File: "<<z7p_name<<" is already there"<<endl; cflush();
  }

  zrun_cmd = "Zrun";
  if(format.start_with("abaqus")) {
     zrun_cmd = "Zodb";
     if(!mat_file) zrun_cmd = zrun_cmd + " -s ODB.AutoConvert 1";
  }

  if(nb_dd>1) {
    geof_name=cracked_name+"_SIF";
    //STD_CP(cracked_name+".geo",geof_name+"_ini.geo");
    //STD_CP(geof_name+".inp","SAVED_INP");
    tmp="**classical_numbering **metis_split *domains "+itoa(nb_dd)+" *force_contiguous *check_connexity";
//    tmp="  **classical_numbering **metis_split64 *domains "+itoa(nb_dd)+" *parallel_cut_files\n";
    write_mesher(cracked_name+".geo",geof_name+".geo",tmp,geof_name+"_split.inp");
    cmd=ZRUN_CMD+" -m "+geof_name+"_split.inp";
    system(cmd);
    //STD_CP(geof_name+".inp",geof_name+"_split.inp");
    //STD_CP(geof_name+"_ini.geo",geof_name+".geo");
    //STD_CP("SAVED_INP",geof_name+".inp");
    cmd="sync";
    system(cmd);
  }

  export.open("EXPORT.inp",ios::out);
  export <<"****mesher"<<endl;
  export <<" ***mesh do_not_save"<<endl;
  export <<"  **export "<<format<<" "<<sane_name<<endl;
  if((format=="med")&&(MedVersion!="")) export <<"   *version "<<MedVersion<<endl;
  if(if_contact) export <<"   *contact_on_lip"<<endl;
  if(if_contact*if_quad*(!if_add_mpc_for_contact)*(format.start_with("abaqus"))) export <<"   *no_mpc_on_lip"<<endl;
  if(!contact_cmds) export << "   *contact_file " << contact_cmds << endl;
  if(if_quad * format.start_with("zebulon") ) export <<"   *contact_mpc"<<endl;
  if((format.start_with("zebulon")||format.start_with("abaqus"))*if_quad*quad_opt) export <<"   *middle_nodes_mpc"<<endl;
  export <<"  **inp_file "<<cracked_name<<"_SIF"<<endl;
  export <<"  **open "<<geof_name<<".geo"<<endl;
  //ABR---2/2021
  if(format.start_with("aster")) {
    export <<" ***mesh do_not_save"<<endl;
    export <<"  **open "<<geof_name<<".geo"<<endl;
    export <<"  **export med "<<cracked_name<<"_SIF.med"<<endl;
    if(MedVersion!="") export <<"   *version "<<MedVersion<<endl;
  }
  export <<"****return"<<endl;
  export.close();

  if(is_ductile) write_gpp_templated_cto(0);
  else{
      write_gpp_templated(0);
      if(format.start_with("aster")){
            write_gpp_aster(0);
      }
  }

  z7p.open(z7p_name,ios::out);
  z7p.setf(ios::scientific);
  z7p.precision(64);

  z7p << "#include <Zcracks_base.z7p>"<<endl;
  if(user_extention) z7p << "#include <Zcracks_extentions.z7p>"<<endl;
  
  z7p << endl;
  z7p << "int main()"<<endl;
  z7p << "{ STRING cmd, fe_cmd;"<<endl;
  z7p << endl;
  z7p << "  init_var();"<<endl;
  z7p << "  sane_name = \""<<sane_name<<"\";"<<endl;
  z7p << "  cracked_name = \""<<cracked_name<<"\";"<<endl;
  z7p << "  thermal_field = \""<<thermal_field<<"\";"<<endl;
  z7p << "  finite_strain = "<<finite_strain<<";"<<endl;
  if(is_plastic) z7p << "  is_plastic = "<<is_plastic<<";"<<endl;
  z7p << "  format        = \""<<format<<"\";"<<endl;
  z7p << "  smp           = "<<smp<<";"<<endl;
  z7p << "  nb_dd         = "<<nb_dd<<";"<<endl;
  if(MedVersion!="") z7p << "  MedVersion =  \""<<MedVersion<<"\";"<<endl;
  if(fatigue_Ti>0.0) z7p << "  fatigue_Ti    = "<<fatigue_Ti<<";"<<endl;
  if(!temperature_name) z7p << "  temperature_name = \""<<temperature_name<<"\";"<<endl;
  if(sigy>0) z7p << "  sigy = "<<sigy<<";"<<endl;
  if(!elset_names) z7p << "  elset_names = \""<<elset_names<<"\";"<<endl;

  if(!fe_command) {
     if(format.start_with("abaqus")) {
        if((fe_command.locate("job=")) || (fe_command.locate("--input="))) got_job = 1;
        fe_cmd = fe_command;
     }
     else                            fe_cmd = fe_command + " ";
  }
  else {
     if(format.start_with("zebulon")) {
        if(nb_dd>1) fe_cmd = "Zrun -mpimpi "+itoa(nb_dd)+" ";
        else fe_cmd = "Zrun ";
        if(smp>1) fe_cmd = fe_cmd + "-smp "+ itoa(smp) + " ";
     } else if(format.start_with("aster")) {//ABR---2/2021
        fe_cmd = "codeaster-run ";
     } else if(format.start_with("samcef")) {
        fe_cmd = "Zsamcef ";
     } else {
        if(format.start_with("abaqus")){
          if(os != "win32")   fe_cmd = "Zmat -fg ";
          else                fe_cmd = "Zmat -fg -skip_link ";
        }
        else if(format.start_with("ansys"))   fe_cmd = "Zansys ";
        if(smp>1) fe_cmd = fe_cmd + "-mpi "+ itoa(smp) + " ";
     }
  }
  z7p << "  fe_cmd        = \""<<fe_cmd<<"\";"<<endl;
  if(if_contact) z7p << "  if_contact    = 1;"<<endl;
  if(!contact_cmds) z7p << "  contact_cmds = \""<<contact_cmds<<"\";"<<endl;
  z7p << endl;

  if(!format.start_with("zebulon")) {
     z7p << "  if(!thermal_field) {"<<endl;
     z7p << "     write_thermal_tranfer_inp(0);"<<endl;
     z7p << "     cmd = \"Zrun -fe_transfer transfer_therm\";"<<endl;
     z7p << "     system(cmd);"<<endl;
     z7p << "  }"<<endl;
  }
  z7p << "  cmd = \"Zrun -m EXPORT\";"<<endl;
  z7p << "  system(cmd);"<<endl;
  //ABR---2/2021
  if (format.start_with("aster")) z7p<<"  cmd = fe_cmd+\" \"+cracked_name+\"_SIF.export\";"<<endl;
  else if(!got_job) z7p << "  cmd = fe_cmd+\" \"+cracked_name+\"_SIF\";"<<endl;
  else         z7p << "  cmd = fe_cmd+cracked_name+\"_SIF.inp\";"<<endl;
  z7p << "  system(cmd);"<<endl;

/*
  // Perform glue if necessary
  if(nb_dd>1) {
    z7p << endl;
    z7p << "  STD_MV(cracked_name+\"_SIF.inp\",\"SAVED_INP\");" <<endl;
    z7p << "  system(\"echo '****glue ****return' > \"+cracked_name+\"_SIF.inp\");" <<endl;
    z7p << "  cmd= \"Zmpiglue -np "<<itoa(nb_dd+1)<< " \"+cracked_name+\"_SIF.inp\"; "<<endl;
    z7p << "  system(cmd);"<<endl;
    z7p << "  STD_CP(\"SAVED_INP\",cracked_name+\"_SIF.inp\");" <<endl;
    z7p << endl;
  }
*/
  if(nb_dd>1) {
    // Perform parallel post adding GPP at the end of cracked_SIF
    // Regenerate cracked_SIF + add GPP a the end
    z7p << "   STD_CP(cracked_name+\"_SIF.inp\",cracked_name+\"_SIF_saved.inp\");"<<endl;
    z7p << "   cmd = \"cat \"+cracked_name+\"_GPP.inp >> \"+cracked_name+\"_SIF.inp\";";
    z7p << "   ret=system(cmd);"<<endl;
    z7p << "   cmd = \""<<zrun_cmd<<" -mpimpi \"+itoa(nb_dd)+\" -smp \"+itoa(2*smp)+\" -pp \"+cracked_name+\"_SIF\";"<<endl;
  } else if(smp>1) {
      if (format.start_with("aster")){
            z7p << "  cmd = \""<<zrun_cmd<<" -pp -smp \"+itoa(smp)+\" \"+cracked_name+\"_GPP_aster\";"<<endl;
            z7p << "  system(cmd);"<<endl;
      }
     z7p << "  cmd = \""<<zrun_cmd<<" -pp -smp \"+itoa(smp)+\" \"+cracked_name+\"_GPP\";"<<endl;
  }
/*
  else if(nb_dd>1) {
      if (format.start_with("aster")){
            z7p << "  cmd = \""<<zrun_cmd<<" -pp -smp \"+itoa(nb_dd)+\" \"+cracked_name+\"_GPP_aster\";"<<endl;
            z7p << "  system(cmd);"<<endl;
      }
     z7p << "  cmd = \""<<zrun_cmd<<" -pp -smp \"+itoa(nb_dd)+\" \"+cracked_name+\"_GPP\";"<<endl;
  }
*/
  else {
      if (format.start_with("aster")){
            z7p << "  cmd = \""<<zrun_cmd<<" -pp \"+cracked_name+\"_GPP_aster\";"<<endl;
            z7p << "  system(cmd);"<<endl;
      }
      z7p << "  cmd = \""<<zrun_cmd<<" -pp \"+cracked_name+\"_GPP\";"<<endl;
  }

  z7p << "  system(cmd);"<<endl;
  if(nb_dd>1) {
    z7p << "   STD_CP(cracked_name+\"_SIF_saved.inp\",cracked_name+\"_SIF.inp\");"<<endl;
  }

  z7p << "}"<<endl;

  if(!qsub_file_name){
    if(format=="abaqus_templated"){
      str = "perl " + qsub_file_name + " -sif";
      system(str);
    }
    else
      ERROR("qsub submission is not implemented yet for "+format+ " format");
  }  
 
  return(0);
}

int write_thermal_tranfer_inp(int cyc)
{ Zfstream transfer;
  STRING name;

  if(!thermal_field == 0) return(0);

  if(cyc==0) name = cracked_name;
  else       name = cracked_name+"_PROPAG"+itoa(cyc);

  transfer.open("transfer_therm.inp",ios::out);
  transfer<<"****fe_transfer"<<endl;
  transfer<<"  ***new_mesh "<<name<<endl;
  transfer<<"  ***old_mesh "<<thermal_field<<endl;
  transfer<<"  ***nodal_parameter_transfer default"<<endl;
  transfer<<"    *fields temperature"<<endl;
  if(!elset_names)  transfer<<"  ***preserve_elset "<<elset_names<<endl;
//  else if(elset_name != "AUTO") transfer<<"  ***preserve_elset "<<elset_name<<endl;
  
  transfer<<"****return"<<endl;
  transfer.close();

  return(0);
}

int write_sdv_tranfer_inp(int cyc)
{ Zfstream transfer;
  STRING mesh_name, name, suffix;
  VECTOR def;

  if(cyc==1) mesh_name = cracked_name;
  else       mesh_name = cracked_name+"_PROPAG"+itoa(cyc-1);
  name                 = cracked_name+"_PROPAG"+itoa(cyc);

  if(format == "abaqus_templated")      suffix = "odb";
  else if(format == "ansys_templated")  suffix = "rst";
  else if(format == "samcef_templated") suffix = "u18";
  else                                  suffix = "ut";

  transfer.open("transfer_sdv.inp",ios::out);
  transfer<<"****fe_transfer"<<endl;
  transfer<<"  ***new_mesh "<<"REMESHED.geo"<<endl;
  transfer<<"  ***old_mesh "<<name<<"."<<suffix<<endl;
  if(!format.start_with("zebulon")) {
     // basically to get bsets SIDES* allowing correct_crack during node transfer
     transfer<<"   **retrieve_rst_sets"<<endl;
     transfer<<"    *z7_mesh "<<mesh_name<<".geo"<<endl;
  }
  if(!thermal_field) {
    transfer<<"  ***nodal_parameter_transfer default"<<endl;
    transfer<<"   *fields temperature"<<endl;
  }
  transfer<<"  ***nodal_var_transfer default"<<endl;
  if(if_quad) transfer<<"   *linear_lip"<<endl;
  transfer<<"  ***integ_var_transfer default"<<endl;
  if(if_2D&&(if_2DE)) {
    transfer<<"   *integ_transfer nearest_gp_corrected"<<endl;
    transfer<<"  ***element_type_by_elset"<<endl;
    transfer<<"     AUTO default"<<endl;
    transfer<<"     COMPLEMENTARY_ELSET std_shell"<<endl;
    transfer<<"    *section uniform 1 c1d3 3."<<endl;
    transfer<<"  ***preserve_elset AUTO"<<endl;
  } else if(if_czm){
    transfer<<"   *integ_transfer nearest_gp"<<endl;
    transfer<<" ***element_type_by_elset"<<endl;
    transfer<<"    INTERFACE cohesive_zone"<<endl;
    transfer<<"     COMPLEMENTARY_ELSET default"<<endl;
    if(!elset_names)              transfer<<"  ***preserve_elset "<<elset_names<<endl;
    else if(elset_name != "AUTO") transfer<<"  ***preserve_elset "<<elset_name<<endl;
  } else {
    transfer<<"   *integ_transfer nearest_gp_corrected"<<endl;
//    transfer<<"   *integ_transfer best_gp_corrected"<<endl;
    if(!elset_names)              transfer<<"  ***preserve_elset "<<elset_names<<endl;
    else if(elset_name != "AUTO") transfer<<"  ***preserve_elset "<<elset_name<<endl;
  }

  if(!format.start_with("zebulon")) transfer<<"  ***format "<<suffix<<endl;
  transfer<<"  ***material"<<endl;
/*
  if(if_2D==1) {
    transfer<<"   **elset AUTO"<<endl; 
    transfer<<"    *file "<<mat_file<<endl;
  } else
*/
 if(material_from_template=="") {
    transfer<<"   *file "<<mat_file<<endl;
  } else { 
    transfer<<"  "<<material_from_template<<endl;
    // Get materials from dtpl
     
  }
  transfer<<"  ***cards last"<<endl;
//  else if(elset_name != "AUTO") transfer<<"  ***preserve_elset "<<elset_name<<endl;

  if(if_contact || is_ductile) transfer<<"  ***correct_contact "<< min_size <<endl;
  if(local_frame_fname_from_template!="") 
    transfer<<"  ***local_frame_def "<< local_frame_fname_from_template <<endl;
  transfer<<"****return"<<endl;
  transfer.close();

  return(0);
}

int export_mesh_templated(int cyc, int reequilibrium)
{ Zfstream inp;
  STRING geof_name, cmd, out_name,tmp,geon;
  int ret;

  inp.open("EXPORT_PROPAG.inp",ios::out);
  inp.setf(ios::scientific);

  if(nb_dd>1) geof_name = cracked_name+"_PROPAG"+itoa(cyc);
  else if(cyc==1) geof_name = cracked_name;
  //ABR---05/2021, I do not see yet why this is required, so commented this line!
  //else if(format=="aster_templated") geof_name = cracked_name+"_PROPAG"+itoa(cyc);
  else       geof_name = cracked_name+"_PROPAG"+itoa(cyc-1);
  if(reequilibrium*(!format.start_with("zebulon"))) out_name = "REEQUILIBRIUM";
  else              out_name = cracked_name+"_PROPAG"+itoa(cyc);

  if(nb_dd>1) {
    cmd="touch "+geof_name+".inp";
    system(cmd);
    STD_CP(geof_name+".inp","SAVED_INP");
    if(cyc==1)  { 
       geon=cracked_name;
    } else {
       geon=geof_name;
    }

    STD_CP(geon+".geo",geof_name+"_ini.geo");
    //tmp=" **classical_numbering **metis_split64 *domains "+itoa(nb_dd)+" *parallel_cut_files\n";
    tmp="**classical_numbering **metis_split *domains "+itoa(nb_dd)+" *force_contiguous *check_connexity";
    write_mesher(geon,geof_name+".geo",tmp,geof_name+".inp");
    cmd=ZRUN_CMD+" -m "+geof_name+".inp";
    system(cmd);
    STD_CP(geof_name+".inp",geof_name+"_split.inp");
    STD_CP(geof_name+"_ini.geo",geof_name+".geo");
    STD_CP("SAVED_INP",geof_name+".inp");
    cmd="sync";
    system(cmd);
  } 

  inp<<"****mesher"<<endl;
  inp<<" ***mesh do_not_save"<<endl;
  inp<<"  **open "<<geof_name<<".geo"<<endl;
  if(if_2D&&format.start_with("abaqus")) {
    inp<<"  **abaqus_slider"<<endl;
    inp<<"   *dtpl_file " <<sane_name<<".dtpl"<<endl;
    inp<<"   *liset_slider l_SLIDER"<<endl;
  }
  inp<<"  **export "<<format<<" "<<sane_name<<".dtpl"<<endl;
  if((format=="med")&&(MedVersion!="")) inp <<"   *version "<<MedVersion<<endl;
  if(if_contact) inp<<"   *contact_on_lip"<<endl;
  if(if_contact*if_quad*(!if_add_mpc_for_contact)*(format.start_with("abaqus"))) inp <<"   *no_mpc_on_lip"<<endl;
  if(!contact_cmds) inp << "   *contact_file " << contact_cmds << endl;
  if((format.start_with("zebulon")||format.start_with("abaqus"))*if_quad*quad_opt) inp <<"   *middle_nodes_mpc"<<endl;
  if(reequilibrium){
     inp<< "   *re_equilibrium_step"<<endl;
     if(is_ductile){
        inp<< "   *initialize_from REMESHED"<<endl;
        inp<< "   *initialize_elsets "<<elset_names<<endl;
     }
  }
  else {
     if(if_transfert * (cyc>1) ) {
        if(format.start_with("abaqus"))                 inp<< "   *restart"<<endl;
        else                                            inp<< "   *initialize_from REMESHED"<<endl;
        if(format.start_with("zebulon")*(!elset_names)) inp<< "   *initialize_elsets "<<elset_names<<endl;
     }
  }
  if(is_ductile){
    inp<< "   *ductile_crack"<<endl;
    inp<< "   *nb_propag_steps "<<nb_cycles<<endl;
    inp<< "   *nb_step_increments 2"<<endl;
  }
  if(if_quad * format.start_with("zebulon") ) inp <<"   *contact_mpc"<<endl;
  if( (cyc>1) * (fatigue_Ti>0.0) * (!format.start_with("ansys")) ) inp<< "   *preload "<<fatigue_Ti<<endl;
  inp<<"  **inp_file "<<out_name<<endl;
  //ABR---05/2021
  if(format.start_with("aster")) {
    inp<<" ***mesh do_not_save"<<endl;
    inp<<"  **open "<<geof_name<<".geo"<<endl;
    inp<<"  **export med "<<out_name<<".med"<<endl;
    if(MedVersion!="") inp <<"   *version "<<MedVersion<<endl;
  }
  inp<<"****return"<<endl;
  inp.close();

  cmd = ZRUN_CMD+" -m EXPORT_PROPAG";
  ret = system(cmd); 

  return(ret);

}

int check_import_template()
{ ASCII_FILE tmpl;
  STRING name, cmd;
  Zfstream inp;
  int ret;

//  if(format=="aster_templated") return(0);

  name = sane_name + ".dtpl";
  tmpl.open(name);
  if(!tmpl.ok) {
     ERROR("\nImport should be done before\n");
     return(1);
  }

  inp.open("IMPORT_CHECK.inp",ios::out);

  inp<<"****mesher"<<endl;
  inp<<" ***mesh do_not_save"<<endl;

  if(format=="aster_templated") inp<<"  **open "<<sane_name<<".geo"<<endl;
  else                          inp<<"  **open IMPORT-new"<<endl;

  inp<<"  **export "<<format<<" "<<sane_name<<".dtpl"<<endl;
  if((format=="zebulon_templated")*(is_ductile)){
    inp<<"   *ductile_crack"<<endl;
  }
  inp<<"  **inp_file CHECK_"<<sane_name<<endl;
  if(format.start_with("aster")) {
    inp<<" ***mesh do_not_save"<<endl;
    inp<<"  **open "<<sane_name<<".geo"<<endl;
    inp<<"  **export med CHECK_"<<sane_name<<".med"<<endl;
    if(MedVersion!="") export <<"   *version "<<MedVersion<<endl;
  }
  inp<<"****return"<<endl;
  inp.close();

  cmd = ZRUN_CMD+" -m IMPORT_CHECK";
  ret = system(cmd); 

  return(ret);

}


//NRNR CZM stuff : post-proccessing to compute the new front using the process zone location
// then generate a new front file for gtheta post
int write_gpp_czm_front_searching(int cyc)
{ Zfstream gpp;

  STRING inp_name, rst_name, geo_name,tempn;
  STRING new_elset_name, results_ext,cmd;
  double hhmin;

  hhmin=hmin;
  // VC: if not templated allow Gradius to be lower than min_size
  if(only_templated) {
    if(hhmin<=0.0) hhmin = min_size;
  }

  new_elset_name = elset_name;
  if( (new_elset_name != "AUTO") && (elset_radius>0.0) ) new_elset_name = "AUTO";

  if(format.start_with("abaqus"))     results_ext ="odb";
  else if(format.start_with("ansys")) results_ext = "rst";
  else                                results_ext ="ut";

  if(cyc==0) {
//    inp_name = cracked_name+"_GPP.inp";
      inp_name = cracked_name+"_czm_front.inp";
      rst_name = cracked_name+"_SIF."+results_ext;
  }
  else {
    inp_name = cracked_name+"_czm_front"+itoa(cyc)+".inp";
    rst_name = cracked_name+"_PROPAG"+itoa(cyc)+"."+results_ext;
  }

  if(cyc<=1) geo_name = cracked_name+".geo";
  else       geo_name = cracked_name+"_PROPAG"+itoa(cyc-1)+".geo";

    // Usual case 
    gpp.open(inp_name,ios::out);
    gpp.setf(ios::scientific);

    gpp <<"****post_processing"<<endl;
    if((results_ext == "rst")*(!mat_file)) {
       gpp <<" ***global_parameter " << endl;
       gpp <<"  RST.MatFile " << mat_file << endl;
    }
    gpp <<" ***data_source ";
    if(format.start_with("zebulon")) gpp << "Z7"<<endl;
    else                             gpp <<results_ext<<endl;
    gpp <<"  **open "<<rst_name<<endl;
    gpp <<"  **write_geo"<<endl;
    if(!format.start_with("zebulon")) {
       gpp <<"  **retrieve_rst_sets"<<endl;
       gpp <<"   *z7_mesh "<<geo_name<<endl;
    }
    gpp <<" ***global_post_processing"<<endl;
    // gpp <<"  **deformed"<<endl;
    gpp <<"  **file integ"<<endl;
  
    //gpp <<"  **elset ALL_ELEMENT"<<endl; // NRNR
    gpp <<"  **elset "<<interface_elements_name<<endl; //
    gpp << "  **at "<<cz_process_time<<endl;
    gpp <<"  **process pp_czm_front_reconstructing"<<endl;
    gpp <<"   *damage_min "<<damage_min<<endl;
    gpp <<"   *damage_max "<<damage_max<<endl;
    gpp <<"   *list_var "<<czm_var_name<<endl;
    gpp <<"   *crack_front FRONT"<<endl; 
    gpp <<"****return"<<endl;
  


  return(0);
}

//NRNR small modif for CZM stuff
int write_gpp_templated_czm(int cyc)
{ Zfstream gpp;
  STRING inp_name, rst_name, geo_name,tempn;
  STRING new_elset_name, results_ext,cmd;
  double hhmin;

  hhmin=hmin;
  // VC: if not templated allow Gradius to be lower than min_size
  if(only_templated) {
    if(hhmin<=0.0) hhmin = min_size;
  }

  new_elset_name = elset_name;
  if( (new_elset_name != "AUTO") && (elset_radius>0.0) ) new_elset_name = "AUTO";

  if(format.start_with("abaqus"))     results_ext ="odb";
  else if(format.start_with("ansys")) results_ext = "rst";
  else                                results_ext ="ut";

  if(cyc==0) {
    inp_name = cracked_name+"_GPP.inp";
    rst_name = cracked_name+"_SIF."+results_ext;
  }
  else {
    inp_name = cracked_name+"_GPP_PROPAG"+itoa(cyc)+".inp";
    rst_name = cracked_name+"_PROPAG"+itoa(cyc)+"."+results_ext;
  }

  if(cyc<=1) geo_name = cracked_name+".geo";
  else       geo_name = cracked_name+"_PROPAG"+itoa(cyc-1)+".geo";

  if(if_Dwpe) {
    // DWPE integ
    hhmin=2.*hmin;

    STD_RM(inp_name);
    if(cyc==0) {
      write_Dwpe(cracked_name+"_SIF",geo_name,gth_radius,rmax);
//      write_Dwpe(cracked_name+"_SIF",geo_name,hmin,hhmin);
      cmd="ln -s "+cracked_name+"_SIF_PPD.inp "+inp_name;
      system(cmd);
      cmd="Zrun -m "+cracked_name+"_SIF_PPD.inp";
      system(cmd);
    } else {
      write_Dwpe(cracked_name+"_PROPAG"+itoa(cyc),geo_name,gth_radius,rmax);
//      write_Dwpe(cracked_name+"_PROPAG"+itoa(cyc),geo_name,hmin,hhmin);
      cmd="ln -s "+cracked_name+"_PROPAG"+itoa(cyc)+"_PPD.inp "+inp_name;
      system(cmd);
      cmd="Zrun -m "+cracked_name+"_PROPAG"+itoa(cyc)+"_PPD.inp";
      system(cmd);
    }
  } else {
    // Usual case 
    gpp.open(inp_name,ios::out);
    gpp.setf(ios::scientific);

    gpp <<"****post_processing"<<endl;
    if((results_ext == "rst")*(!mat_file)) {
       gpp <<" ***global_parameter " << endl;
       gpp <<"  RST.MatFile " << mat_file << endl;
    }
    gpp <<" ***data_source ";
    if(format.start_with("zebulon")) gpp << "Z7"<<endl;
    else                             gpp <<results_ext<<endl;
    gpp <<"  **open "<<rst_name<<endl;
    gpp <<"  **write_geo"<<endl;
    if(!format.start_with("zebulon")) {
       gpp <<"  **retrieve_rst_sets"<<endl;
       gpp <<"   *z7_mesh "<<geo_name<<endl;
    }
    gpp <<" ***global_post_processing"<<endl;
    gpp <<"  **deformed"<<endl;
    if(format.start_with("ansys")) {
/*     Not needed anymore ... interpolation done in ANSYS_RST
       gpp <<"  **file ctele"<<endl;
       gpp <<"  **elset ALL_ELEMENT"<<endl;
       gpp <<"  **process node_interpolation"<<endl;
       gpp <<"   *list_var sig11 sig22 sig33 sig12 sig23 sig31"<<endl;
       gpp <<"             eel11 eel22 eel33 eel12 eel23 eel31"<<endl;
*/
       if(!thermal_field + if_transfert) {
         gpp <<"  **file node"<<endl;
         gpp <<"  **nset ALL_NODE"<<endl;
         if(finite_strain){
            gpp <<"  **process strain_measure"<<endl;
            gpp <<"   *strain_prefix eto"<<endl;
            gpp <<"   *rotate"<<endl;
            gpp <<"   *measure log"<<endl;
         }
         else gpp <<"  **process symmetric_gradient"<<endl;
       }
    }
    if((!temperature_name)&&(!(temperature_name.start_with("GP_")))) {
       gpp <<"  **file node"<<endl;
       gpp <<"  **nset ALL_NODE"<<endl;
       gpp <<"  **process node_interpolation"<<endl;
       gpp <<"   *list_var "<<temperature_name<<endl;
    }
    gpp <<"  **file integ"<<endl;

    /* Removed because elsets are not preserved when reading the rst
    if(if_must_define_elset) gpp <<"  **elset "<<new_elset_name<<endl;
    else                     gpp <<"  **elset ALL_ELEMENT"<<endl;
    */

    gpp <<"  **elset ALL_ELEMENT"<<endl;
  //  if(fatigue_Ti>0.0) gpp << "  **at "<<fatigue_Ti<<":last"<<endl;
    gpp << "  **at "<<cz_gtheta_process_time<<endl;
    gpp <<"  **process gtheta"<<endl;
    if(gth_radius>0.) { 
      gpp <<"   *ra "<<gth_radius<<endl;
      if(rmax>0.) {
        if(rmax<gth_radius) gpp <<"   *rb "<<rmax<<endl;
        else gpp <<"   *rmax "<<rmax<<endl;
      }
    } else {
      gpp <<"   *elem_radius "<<nb_velem<<endl;
      if(rmax>0.) gpp <<"   *rmax "<<rmax<<endl;
    }
    if(rmax<0.) gpp<<"   *hmin "<<(-1.*rmax)<<endl;

    //else gpp <<"   *elem_radius "<<nb_velem<<endl;
    //NRNR
       //gpp <<"   *fronts_file the_front_file"<<endl;
       gpp <<"   *fronts_file ELSET_FRONT.adv"<<endl;
       gpp <<"   *sig sig"<<endl;
       gpp <<"   *eto eto"<<endl;
       /*if((format == "zebulon_templated") + !thermal_field + if_transfert) {
         gpp <<"   *eel eel"<<endl;
       }*/
    gpp <<"   *nbnodes "<<nb_fnodes<<endl;
    gpp <<"   *lip_name SIDE0"<<endl;
    // gpp <<"   *hmin "<<hhmin<<endl;
    gpp <<"   *crack_front FRONT"<<endl;
    if(if_K)    gpp <<"   *compute_K"<<endl;
    if(if_Ki)   gpp <<"   *Ki"<<endl;
    if(if_mpa_m)   gpp<<"   *mpa_m"<<endl;
    if(if_Gmax) gpp <<"   *compute_angle"<<endl;
    if(if_ebe)  gpp <<"   *excludeBE"<<endl;
    if(!temperature_name) {
      tempn=temperature_name;
      if(tempn.start_with("GP_")) tempn=tempn.locate_and_cut_before("GP_");
      else tempn="gp"+tempn;
      gpp<<"   *temperature "<<tempn<<endl;
    }
    if(sigy>0.) gpp <<"   *sigy "<<sigy<<endl;
    //if(n_length>0)  gpp< <"   *print_front "<<n_length<<endl;

    if(if_contact*if_contact_correction){ 
      gpp<<"   *surface CRACK_LIPS"<<endl;
      if(finite_strain*(!format.start_with("zebulon"))) gpp<<"   *finite_strain"<<endl;
    }
    if(max_kink_angle!=90.) gpp << "   *max_angle "<<max_kink_angle<<endl;

    gpp <<"****return"<<endl;
  }

  return(0);
}


// cyc = 0 : for SIF, not PROPAG
int write_gpp_templated(int cyc)
{ Zfstream gpp;
  STRING inp_name, rst_name, geo_name,tempn;
  STRING new_elset_name, results_ext,cmd;
  double hhmin;
  int i;

  hhmin=hmin;
  // VC: if not templated allow Gradius to be lower than min_size
  if(only_templated) {
    if(hhmin<=0.0) hhmin = min_size;
  }

  new_elset_name = elset_name;
  if( (new_elset_name != "AUTO") && (elset_radius>0.0) ) new_elset_name = "AUTO"; 

  if(format.start_with("abaqus"))      results_ext ="odb";
  else if(format.start_with("ansys"))  results_ext = "rst";
  else if(format.start_with("samcef")) results_ext = "u18";
  else                                 results_ext = "ut";

  if(cyc==0) {
    inp_name = cracked_name+"_GPP.inp";
    if(format.start_with("aster")){
        rst_name = cracked_name+"_GPP_aster";
    }
    else rst_name = cracked_name+"_SIF";
  }
  else {
      //ABR---aster templated for propag shld be taken care of!
    inp_name = cracked_name+"_GPP_PROPAG"+itoa(cyc)+".inp";
    if(format.start_with("aster")){
        rst_name = cracked_name+"_GPP_PROPAG_aster"+itoa(cyc);
        //rst_name = cracked_name+"_PROPAG"+itoa(cyc);
    }
    else
    {
        rst_name = cracked_name+"_PROPAG"+itoa(cyc);
    }
  }
  if(format.start_with("samcef")) rst_name = rst_name + "_me";
  rst_name = rst_name + "." + results_ext;

//  if(nb_dd>1) {
  if(0) {
    if(cyc==0) geo_name = cracked_name+"_SIF";
    else {
      geo_name = cracked_name+"_PROPAG"+itoa(cyc);
      STD_CP(geo_name+".inp","SAVED_INP");
      gpp.open(geo_name+".inp",ios::out);
      gpp.setf(ios::scientific);
      gpp<<"****glue \n ****return\n";
      gpp.close();
      cmd="Zmpiglue -np "+itoa(nb_dd+1)+" "+geo_name+".inp";
      system(cmd);
      STD_CP("SAVED_INP",geo_name+".inp");
    }
    geo_name=geo_name+".geo";
  } else if(cyc<=1) geo_name = cracked_name+".geo";
  else       geo_name = cracked_name+"_PROPAG"+itoa(cyc-1)+".geo";

  if(if_Dwpe) {
    // DWPE integ
    hhmin=2.*hmin;

    STD_RM(inp_name);
    if(cyc==0) {
      //write_Dwpe(cracked_name+"_SIF",geo_name,hmin,hhmin);
      write_Dwpe(cracked_name+"_SIF",geo_name,gth_radius,rmax);
      cmd="ln -s "+cracked_name+"_SIF_PPD.inp "+inp_name;
      system(cmd);
      cmd="Zrun -m "+cracked_name+"_SIF_PPD.inp";
      system(cmd);
    } else {
      write_Dwpe(cracked_name+"_PROPAG"+itoa(cyc),geo_name,gth_radius,rmax);
      //write_Dwpe(cracked_name+"_PROPAG"+itoa(cyc),geo_name,hmin,hhmin);
      cmd="ln -s "+cracked_name+"_PROPAG"+itoa(cyc)+"_PPD.inp "+inp_name;
      system(cmd);
      cmd="Zrun -m "+cracked_name+"_PROPAG"+itoa(cyc)+"_PPD.inp";
      system(cmd);
    }
  } else {
    // Usual case 
    gpp.open(inp_name,ios::out);
    gpp.setf(ios::scientific);

    gpp <<"****post_processing"<<endl;
  if(nb_dd<=1) {
    if((results_ext == "rst")*(!mat_file)) {
       gpp <<" ***global_parameter " << endl;
       gpp <<"  RST.MatFile " << mat_file << endl;
    }
    gpp <<" ***data_source ";
    if(format.start_with("zebulon")) gpp << "Z7"<<endl;
    else if (format.start_with("aster")) gpp << "Z7"<<endl;//ABR---2/2021
    else                             gpp <<results_ext<<endl;
    gpp <<"  **open "<<rst_name<<endl;
    gpp <<"  **write_geo"<<endl;
    if(!(format.start_with("zebulon")||format.start_with("aster"))) {//ABR---2/2021
       gpp <<"  **retrieve_rst_sets"<<endl;
       gpp <<"   *z7_mesh "<<geo_name<<endl;
    }
    if(format.start_with("samcef") * (!thermal_field + if_transfert) ) {
        gpp <<" ***local_post_processing"<<endl;
        for(i=0;i<!material_elsets;i++) { 
           gpp <<"  **elset "<<material_elsets[i]<<endl;
           gpp <<"  **file integ"<<endl;
           if(i>0) gpp <<"  **duplicate_no"<<endl;
           gpp <<"  **process recover_elastic_strain"<<endl;
           gpp <<"   *stress sig"<<endl;
           gpp <<"   *elasticity "<<material_files[i]<<endl;
        }
    }
  }
    gpp <<" ***global_post_processing"<<endl;
    gpp <<"  **deformed"<<endl;
    if(format.start_with("ansys")) {
/*     Not needed anymore ... interpolation done in ANSYS_RST
       gpp <<"  **file ctele"<<endl;
       gpp <<"  **elset ALL_ELEMENT"<<endl;
       gpp <<"  **process node_interpolation"<<endl;
       gpp <<"   *list_var sig11 sig22 sig33 sig12 sig23 sig31"<<endl;
       gpp <<"             eel11 eel22 eel33 eel12 eel23 eel31"<<endl;
*/
       if(!thermal_field + if_transfert) {
         gpp <<"  **file node"<<endl;
         gpp <<"  **nset ALL_NODE"<<endl;
         if(finite_strain){
            gpp <<"  **process strain_measure"<<endl;
            gpp <<"   *strain_prefix eto"<<endl;
            gpp <<"   *rotate"<<endl;
            gpp <<"   *measure log"<<endl;
         }
         else gpp <<"  **process symmetric_gradient"<<endl;
       }
    }
    else if(format.start_with("samcef")) {
       gpp <<"  **file node"<<endl;
       gpp <<"  **nset ALL_NODE"<<endl;
       gpp <<"  **process strain_measure"<<endl;
       gpp <<"   *strain_prefix eto"<<endl;
       if(finite_strain){
          gpp <<"   *rotate"<<endl;
          gpp <<"   *measure log"<<endl;
       }else{
          gpp <<"   *measure sd"<<endl;
       }
    }
    if(if_CTOA){
       gpp <<"  **file node"<<endl;
       gpp <<"  **nset ALL"<<endl;
       gpp <<"  **process cto"<<endl;
       gpp <<"   *compute_ctoa"<<endl;
       gpp <<"   *compute_ctod"<<endl;
       gpp <<"   *dist 1.0"<<endl;
       gpp <<"   *nbnodes "<<nb_fnodes<<endl;
       gpp <<"   *lip_name SIDE0"<<endl;
       gpp <<"   *crack_front FRONT"<<endl;
    }
    if((!temperature_name)&&(!(temperature_name.start_with("GP_")))) {
       gpp <<"  **file node"<<endl;
       gpp <<"  **nset ALL_NODE"<<endl;
       gpp <<"  **process node_interpolation"<<endl;
       gpp <<"   *list_var "<<temperature_name<<endl;
       if(results_ext=="ut") {
         if(cyc==0) {
           gpp <<" ***shell ln -s "<<cracked_name<<"_GPP.utp "<<cracked_name<<"_SIF.utp"<<endl;
           gpp <<" ***shell ln -s "<<cracked_name<<"_GPP.integp "<<cracked_name<<"_SIF.integp"<<endl;
         } else {
           gpp <<" ***shell ln -s "<<cracked_name<<"_GPP_PROPAG"<<itoa(cyc)<<".utp ";
                               gpp <<cracked_name<<"_PROPAG"<<itoa(cyc)<<".utp "<<endl;
           gpp <<" ***shell ln -s "<<cracked_name<<"_GPP_PROPAG"<<itoa(cyc)<<".integp ";
                               gpp <<cracked_name<<"_PROPAG"<<itoa(cyc)<<".integp "<<endl;
         }
         gpp <<" ***global_post_processing"<<endl;
        gpp <<"   **deformed"<<endl;
       }
    }
    gpp <<"  **file integ"<<endl;

    /* Removed because elsets are not preserved when reading the rst
    if(if_must_define_elset) gpp <<"  **elset "<<new_elset_name<<endl;
    else                     gpp <<"  **elset ALL_ELEMENT"<<endl;
    */

    gpp <<"  **elset ALL_ELEMENT"<<endl;
    if(fatigue_Ti>0.0) gpp << "  **at "<<fatigue_Ti<<":last"<<endl;
    gpp <<"  **process gtheta"<<endl;
    if(gth_radius>0.) {
      gpp <<"   *ra "<<gth_radius<<endl;
      if(rmax>0.) {
        if(rmax<gth_radius) gpp <<"   *rb "<<rmax<<endl;
        else gpp <<"   *rmax "<<rmax<<endl;
      }
    } else {
      gpp <<"   *elem_radius "<<nb_velem<<endl;
      if(rmax>0.) gpp <<"   *rmax "<<rmax<<endl;
    }
//    gpp<<"   *error"<<endl;
    if(format.start_with("ansys")) {
       // gpp <<"   *sig gpsig"<<endl;
       gpp <<"   *sig sig"<<endl;
       if(!thermal_field + if_transfert) {
         gpp <<"   *eto eto"<<endl;
         gpp <<"   *eel eel"<<endl;
         if(!mat_file==0) gpp <<"   *eel_stored_as GAMMA"<<endl;
       }
       else {
         gpp <<"   *eto eel"<<endl;
       }
       gpp <<"   *stored_as GAMMA"<<endl;
    }
    else if(format.start_with("abaqus")) {
       gpp <<"   *sig sig"<<endl;
       gpp <<"   *eto eto"<<endl;
       if(!thermal_field + if_transfert + is_plastic) {
          if(!mat_file) { // Zmat file
             gpp <<"   *eel eel"<<endl;
          }
          else {
             gpp <<"   *eel EE"<<endl;
             gpp <<"   *eel_stored_as GAMMA"<<endl;
          }
       }
       gpp <<"   *stored_as GAMMA"<<endl;
    }
    else {
       gpp <<"   *sig sig"<<endl;
       gpp <<"   *eto ";
       if(finite_strain*(format == "zebulon_templated")) gpp <<"ETO"<<endl;
       else                                              gpp <<"eto"<<endl;
       if((format == "zebulon_templated") + !thermal_field + if_transfert) {
         gpp <<"   *eel eel"<<endl;
       }
    }
    gpp <<"   *nbnodes "<<nb_fnodes<<endl;
    gpp <<"   *lip_name SIDE0"<<endl;
    // gpp <<"   *hmin "<<hhmin<<endl;
    if(rmax<0.) gpp<<"   *hmin "<<(-1.*rmax)<<endl;
    gpp <<"   *crack_front FRONT"<<endl;
    gpp <<"   *error"<<endl;
    if(if_K)    gpp <<"   *compute_K"<<endl;
    if(if_Ki)   gpp <<"   *Ki"<<endl;
    if(if_mpa_m)   gpp<<"   *mpa_m"<<endl;
    if(if_Gmax) gpp <<"   *compute_angle"<<endl;
    if(if_ebe)  gpp <<"   *excludeBE"<<endl;
    if(!temperature_name) {
      tempn=temperature_name;
      if(tempn.start_with("GP_")) tempn=tempn.locate_and_cut_before("GP_");
      else tempn="gp"+tempn;
      gpp<<"   *temperature "<<tempn<<endl;
    }
    if(sigy>0.) gpp <<"   *sigy "<<sigy<<endl;
    //if(n_length>0)  gpp< <"   *print_front "<<n_length<<endl;

    if((constant_density>0.)&&format.start_with("abaqus")) {
      gpp <<"   *density "<<constant_density<<endl;
      gpp <<"   *eigen_abaqus "<<rst_name<<endl;
      gpp <<"   *eto EE"<<endl;
    }

    if(if_contact*if_contact_correction){ 
      gpp<<"   *surface CRACK_LIPS"<<endl;
      if(finite_strain*(!format.start_with("zebulon"))) gpp<<"   *finite_strain"<<endl;
    }
    if(max_kink_angle!=90.) gpp << "   *max_angle "<<max_kink_angle<<endl;
    if(remove_ext_hexa>0)   gpp << "   *remove_ext_hexa "<<remove_ext_hexa<<endl;

    if(nb_dd>1) gpp <<"   *fronts_mesh FRONTS_MESH.geo"<<endl;

    gpp <<"****return"<<endl;
  }

  return(0);
}

int update_PROPAG_templated()
{ ASCII_FILE z7p0,ppropag_law;

  Zfstream z7p;
  STRING str, z7p_name, fe_cmd, zrun_cmd, vtk_series_file_name, vtk_prefix;
  int i, abaqus_reequilibrium, ansys_reequilibrium, got_job;
          


  abaqus_reequilibrium = 0;
  ansys_reequilibrium = 0;
  got_job = 0;

  if(format=="abaqus_templated"){
    if(if_barsoum && if_contact) ERROR("\nQuarter nodes elements can not be used in the contact zone.\nUncheck \"Quarter nodes\" option and rebuild the cracked mesh.");
  } 

  if(if_barsoum && !mat_file){
    ERROR("\nQuarter nodes elements can not be used in plasticity.\nUncheck \"Quarter nodes\" option and rebuild the cracked mesh.");
  }

  if(if_transfert) { 
     if(format.start_with("abaqus"))     abaqus_reequilibrium = 1;
     else if(format.start_with("ansys")) ansys_reequilibrium = 1;
  }

  z7p_name = cracked_name + "_PROPAG" + ".z7p";
  z7p0.open(z7p_name);
  if(z7p0.ok) {
     cout<<"File: "<<z7p_name<<" is already there"<<endl; cflush();
  }

  zrun_cmd = "Zrun";
  if(format.start_with("abaqus")) {
     zrun_cmd = "Zodb";
     if(!mat_file) zrun_cmd = zrun_cmd + " -s ODB.AutoConvert 1";
  }

  z7p.open(z7p_name,ios::out);
  z7p.setf(ios::scientific);
  z7p.precision(64);

  z7p << "#include <Zcracks_base.z7p>"<<endl;
  if(user_extention) z7p << "#include <Zcracks_extentions.z7p>"<<endl;
  if(propag_model == "z7p") z7p << "#include <"<<propag_script<<">"<<endl;
  z7p << endl;
  z7p << "int main()"<<endl;
  z7p << "{"<<endl;
  z7p << "  STRING cmd, fe_cmd, name, geof_name, gpp_name;"<<endl;
  z7p << "  int cyc,nb_cyc,err,max_remesh;"<<endl;
  z7p << endl;
  z7p << "  init_var();"<<endl;

  z7p << endl;
  z7p << "  smp           = "<<smp<<";"<<endl;
  z7p << "  nb_dd         = "<<nb_dd<<";"<<endl;
  z7p << "  cracked_name  = \""<<cracked_name<<"\";"<<endl;
  z7p << "  sane_name     = \""<<sane_name<<"\";"<<endl;
  z7p << "  format        = \""<<format<<"\";"<<endl;
  z7p << "  thermal_field = \""<<thermal_field<<"\";"<<endl;
  z7p << "  finite_strain = "<<finite_strain<<";"<<endl;
  if(MedVersion!="") z7p << "  MedVersion =  \""<<MedVersion<<"\";"<<endl;
  if(is_plastic) z7p << "  is_plastic = "<<is_plastic<<";"<<endl;
  if(if_contact) z7p << "  if_contact    = 1;"<<endl;
  if(!contact_cmds) z7p << "  contact_cmds = \""<<contact_cmds<<"\";"<<endl;

  z7p << endl;
  z7p << "  // gth options"<<endl;
  z7p << "  nb_fnodes   = "<<nb_fnodes<<";"<<endl;
  z7p << "  nb_velem    = "<<nb_velem<<";"<<endl;
  if(constant_density>0.) z7p << "  constant_density = "<<constant_density<<";"<<endl;
  z7p << "  if_K        = "<<if_K<<";"<<endl;
  z7p << "  if_Ki       = "<<if_Ki<<";"<<endl;
  z7p << "  if_mpa_m    = "<<if_mpa_m<<";"<<endl;
  z7p << "  if_Gmax     = "<<if_Gmax<<";"<<endl;
  z7p << "  if_ebe      = "<<if_ebe<<";"<<endl;
  z7p << "  if_Dwpe = "<<if_Dwpe<<";"<<endl;
  if(if_dislo) z7p << "  if_dislo = "<<if_dislo<<";"<<endl;
  z7p << "  hmin = "<<hmin<<";"<<endl;
  z7p << "  gth_radius = "<<gth_radius<<";"<<endl;
  z7p << "  rmax = "<<rmax<<";"<<endl;
  if(sigy>0) z7p << "  sigy = "<<sigy<<";"<<endl;
  if(!if_contact_correction) z7p << "  if_contact_correction = 0;"<<endl;
  if(!if_add_mpc_for_contact) z7p << "  if_add_mpc_for_contact = 0;"<<endl;
  if(max_kink_angle!=90.) z7p << "  max_kink_angle = "<<max_kink_angle<<";"<<endl;
  if(remove_ext_hexa>0) z7p << "  remove_ext_hexa = "<<remove_ext_hexa<<";"<<endl;

  z7p << endl;
  z7p << "  // insertion options"<<endl;
  z7p << "  elset_names = \""<<elset_names<<"\";"<<endl;
  z7p << "  faset_names = \""<<faset_names<<"\";"<<endl;
  z7p << "  liset_names = \""<<liset_names<<"\";"<<endl;
  z7p << "  ridge_names = \""<<ridge_names<<"\";"<<endl;
  z7p << "  nset_names  = \""<<nset_names<<"\";"<<endl;
  z7p << "  faset_names_from_template.resize("<<!faset_names_from_template<<");"<<endl;
  for(i=0;i<!faset_names_from_template;i++) {
    z7p << "  faset_names_from_template["<<i<<"] = \""<<faset_names_from_template[i]<<"\";"<<endl;
  }
  z7p << "  geom_names_from_template.resize("<<!geom_names_from_template<<");"<<endl;
  for(i=0;i<!geom_names_from_template;i++) {
    z7p << "  geom_names_from_template["<<i<<"] = \""<<geom_names_from_template[i]<<"\";"<<endl;
  }
  if(local_frame_fname_from_template!=""){
    z7p<<"  local_frame_fname_from_template=\""<< local_frame_fname_from_template<<"\";" <<endl;
  }
  if(!material_elsets) {
    for(i=0;i<!material_elsets;i++) {
      z7p << "  material_elsets.add(\""<<material_elsets[i]<<"\");"<<endl;
    }
    for(i=0;i<!material_files;i++) {
      z7p << "  material_files.add(\""<<material_files[i]<<"\");"<<endl;
    }
  }

  z7p << endl;
  z7p << "  if_must_define_elset = "<<if_must_define_elset<<";"<<endl;
  z7p << "  if_moving_elset = "<<if_moving_elset<<";"<<endl;
  z7p << "  if_growing_elset = "<<if_growing_elset<<";"<<endl;
  z7p << "  if_var_refine = "<<if_var_refine<<";"<<endl;
  z7p << "  from_quad = "<<from_quad<<";"<<endl;
  z7p << "  if_quad = "<<if_quad<<";"<<endl;
  if(if_quad) z7p << "  quad_opt = "<<quad_opt<<";"<<endl;
  z7p << "  if_barsoum = "<<if_barsoum<<";"<<endl;
  z7p << "  set_reduced = "<<set_reduced<<";"<<endl;
  z7p << "  if_czm = "<<if_czm<<";"<<endl;
  z7p << "  elset_radius = "<<elset_radius<<";"<<endl;
  z7p << "  elset_name = \""<<elset_name<<"\";"<<endl;

  z7p << endl;
  z7p << "  // remeshing options"<<endl;
  z7p << "  max_remesh = 4;"<<endl;
  z7p << "  yams_options = \""<<yams_options<<"\";"<<endl;

  if(if_hexa){
    z7p << "  if_hexa = 1;"<<endl;
    z7p << "  nb_hexa = "<<nb_hexa<<";"<<endl;
    z7p << "  dr_hexa = "<<dr_hexa<<";"<<endl;
    z7p << "  th_hexa = "<<th_hexa<<";"<<endl;
    z7p << "  nc_hexa = "<<nc_hexa<<";"<<endl;
    z7p << "  prog_hexa = "<<prog_hexa<<";"<<endl;
  }
  z7p << "  min_size     = "<<min_size<<";"<<endl;
  z7p << "  max_size     = "<<max_size<<";"<<endl;
  z7p << "  gradation    = "<<gradation<<";"<<endl;
  z7p << "  nb_iter      = "<<nb_iter<<";"<<endl;
  z7p << "  filter_tol   = "<<filter_tol<<";"<<endl;
  // z7p << "  grid_max     = "<<grid_max<<";"<<endl;
  z7p << "  max_quality  = "<<max_quality<<";"<<endl;
  z7p << "  quality_threshold  = "<<quality_threshold<<";"<<endl;
  z7p << "  power_func_coef = "<<power_func_coef<<";"<<endl;
  z7p << "  fuse_length = "<<fuse_length<<";"<<endl;
  z7p << "  if_meshcleaner = "<<if_meshcleaner<<";"<<endl;
  z7p << "  if_ext="<<if_ext<<";"<<endl;
  if(!elset_to_cut) z7p << "  elset_to_cut=\""<<elset_to_cut<<"\";"<<endl;

  if(if_2D) {
    z7p << "  if_2D = "<<if_2D<<";"<<endl;
    z7p << "  thickness.resize(1);"<<endl;
    z7p << "  thickness[0]=-1.;"<<endl;
    z7p << "  if_ext=0;"<<endl;
  }

  z7p << endl;
  z7p << "  // propagation  options"<<endl;
  z7p << "  max_h        = "<<max_h<<";"<<endl;
  z7p << "  nb_pt        = "<<nb_pt<<";"<<endl;
  z7p << "  lip_factor   = "<<lip_factor<<";"<<endl;
  z7p << "  if_lip_factor   = "<<if_lip_factor<<";"<<endl;
  if(if_transfert)   z7p << "  if_transfert = "<<if_transfert<<";"<<endl;
  if(!mat_file)      z7p << "  mat_file     = \""<<mat_file<<"\";"<<endl;
  if(!material_from_template) z7p << "  material_from_template  = \""<<material_from_template<<"\";"<<endl;
  if(fatigue_Ti>0.0) z7p << "  fatigue_Ti   = "<<fatigue_Ti<<";"<<endl;
  if(!temperature_name) z7p << "  temperature_name = \""<<temperature_name<<"\";"<<endl;
  if(smooth_propag>0) z7p << "  smooth_propag = "<<smooth_propag<<";"<<endl;
  if(if_remove_ext_propag) z7p << "  if_remove_ext_propag = 1;"<<endl;
  if(if_dGda) z7p << "  if_dGda = 1;"<<endl;
  //z7p << "  paris_DN   = "<<paris_DN<<";"<<endl;

  z7p << endl;
  z7p << "  // propag model definitions"<<endl;
  z7p << "  propag_mat_file  = \""<<propag_mat_file<<"\";"<<endl;
  z7p << "  propag_model     = \""<<propag_model<<"\";"<<endl;
  if(propag_model != "paris_std") {
     if(propag_model == "z7p") z7p << "  propag_script    = \""<<propag_script<<"\";"<<endl;
     z7p << "  propag_law.set(Create_object(\"ZCRACKS_PROPAG_LAW\",propag_model));"<<endl;
     z7p << "  if(propag_law.Null()) ERROR(\"Unknown propag model: \"+propag_model);"<<endl;
     if(propag_model == "z7p") z7p << "  err = propag_law.initialize(propag_script,propag_mat_file);"<<endl;
     else                      z7p << "  err = propag_law.initialize(\"\",propag_mat_file);"<<endl;
     z7p << "  if(err) ERROR(\"Cannot initialize the propag law\");"<<endl;
  }
  else {
     z7p << "  err = get_paris_std_coefs(propag_mat_file);"<<endl;
     z7p << "  if(err) ERROR(\"Cannot read the paris_std coefs from file: \"+propag_mat_file);"<<endl;
  }

  if(filter_type != "no_filter") {
     z7p << endl;
     z7p << "  // propag filter"<<endl;
     z7p << "  filter_type = \""<<filter_type<<"\";"<<endl;
     z7p << "  propag_filter.set(Create_object(\"ZCRACKS_FILTER\",filter_type));"<<endl;
     z7p << "  if(propag_filter.Null()) ERROR(\"Unknown propag filter: \"+propag_filter);"<<endl;
     if(!filter_inp) {
        z7p << "  propag_filter.inp = \""<<filter_inp<<"\";"<<endl;
     }
     z7p << "  err = propag_filter.load();"<<endl;
     z7p << "  if(err) ERROR(\"Cannot load propag filter\");"<<endl;
  }

  z7p << endl;
  z7p << "  // Set max ids"<<endl;
  z7p << "  max_node_id = "<<max_node_id<<";"<<endl;
  z7p << "  max_ele_id = "<<max_ele_id<<";"<<endl;

  z7p << endl;
  if(!fe_command) {
     if(format.start_with("abaqus")) {
        if((fe_command.locate("job=")) || (fe_command.locate("--input="))) got_job = 1;
        fe_cmd = fe_command;
     }
     else                            fe_cmd = fe_command + " ";
  }
  else {
     if(format.start_with("zebulon")) {
         if(nb_dd>1) fe_cmd = "Zrun -mpimpi "+itoa(nb_dd)+" ";
         else fe_cmd = "Zrun ";
         if(smp>1) fe_cmd = fe_cmd + "-smp "+ itoa(smp) +" ";
     } else if(format.start_with("aster")) {
       fe_cmd = "codeaster-run ";
     } else if(format.start_with("samcef")) {
       fe_cmd = "Zsamcef ";
     } else {
        if(format.start_with("abaqus"))       {
           if(os != "win32")   fe_cmd = "Zmat -fg ";
           else                fe_cmd = "Zmat -fg -skip_link ";
        }
        else                            fe_cmd = "Zansys ";
        if(smp>1) fe_cmd = fe_cmd + "-mpi "+ itoa(smp) +" ";
     }
  }
  z7p << "  fe_cmd        = \""<<fe_cmd<<"\";"<<endl;
  z7p << endl;
  z7p << "  start = 1;    // num of the first cycle computed"<<endl;
  z7p << "  nb_cyc = "<<nb_cycles<<";  // total number of cycles to compute"<<endl;

  z7p << endl;
  z7p << "  // Write advance remeshing file, do not change during propag"<<endl;
  if(new_version) {
     if(if_czm) {
       if(!if_meshcleaner) z7p << "   if_meshcleaner=1;"<<endl;
       z7p << "  write_remesh_new(2);"<<endl;
       z7p << "  STD_MV(cracked_name+\"_REMESH.inp\",cracked_name+\"_REMESH_CZM.inp\");"<<endl;
       if(!if_meshcleaner) z7p << "   if_meshcleaner=0;"<<endl;
     }
     z7p << "  write_remesh_new(1);"<<endl;
  }
  else {
     z7p << "  do_write_advance_remesh();"<<endl;
  }

  z7p << endl;
  z7p << "  err = 0;"<<endl;
  z7p << "  for(cyc=start;cyc<(start+nb_cyc);cyc++) {"<<endl;

  z7p << endl;
  z7p << "     cur_cyc = cyc;"<<endl;
  z7p << "     cout<<endl<<endl<<\"----> Start of cycle: \"<<cyc<<\" -------------------------\"<<endl<<endl; cflush();"<<endl;

  z7p << endl;
  //ABR---05/2021
  //if((nb_dd>1)||(format=="aster_templated")) {
  if((nb_dd>1)) {
    z7p << "     if(cyc==1) geof_name = cracked_name+\".geo\";"<<endl;
    z7p << "     else       geof_name = cracked_name+\"_PROPAG\"+itoa(cyc)+\".geo\";"<<endl;
    z7p << "     if(start>=1 && cyc==start) STD_CP(geof_name,\"REMESHED.geo\");"<<endl;
    z7p << "     geof_name = cracked_name+\"_PROPAG\"+itoa(cyc)+\".geo\";"<<endl;
  } else {
    z7p << "     if(cyc==1) geof_name = cracked_name+\".geo\";"<<endl;
    z7p << "     else       geof_name = cracked_name+\"_PROPAG\"+itoa(cyc-1)+\".geo\";"<<endl;
    z7p << endl;
    z7p << "     // rewrite REMESHED.geo when starting restart computation"<<endl;
    z7p << "     if(start>=1 && cyc==start) STD_CP(geof_name,\"REMESHED.geo\");"<<endl;
  }

  z7p << endl;
  if(!format.start_with("zebulon")) {
     z7p << "     if(!thermal_field) {"<<endl;
     z7p << "        write_thermal_tranfer_inp(cyc-1);"<<endl;
     z7p << "        cmd = \"Zrun -fe_transfer transfer_therm\";"<<endl;
     z7p << "        err = system(cmd);"<<endl;
     z7p << "        if(err) {"<<endl;
     z7p << "           cout<<endl<<\"Error when transferring thermal field to mesh: \"<<geof_name<<\" ... end\"<<endl<<endl;"<<endl;
     z7p << "           break;"<<endl;
     z7p << "        }"<<endl;
     z7p << "     }"<<endl;
  }
  z7p << endl;
  if(if_transfert) {
     z7p << "     if(if_transfert * (cyc>1) ) {"<<endl;
     z7p << "        write_sdv_tranfer_inp(cyc-1);"<<endl;
     if(format.start_with("abaqus")) {
         z7p << "        cmd = \"Zodb -fe_transfer -s ODB.AutoConvert 1 transfer_sdv\";"<<endl;
     }
     else if(format.start_with("ansys")) {
         if(!mat_file) z7p << "        cmd = \"Zrun -fe_transfer -s RST.MatFile \" + mat_file + \" transfer_sdv\";"<<endl;
         else          z7p << "        cmd = \"Zrun -fe_transfer transfer_sdv\";"<<endl;
     }
     else {
         z7p << "        cmd = \"Zrun -fe_transfer transfer_sdv\";"<<endl;
     }
     z7p << "        err = system(cmd);"<<endl;
     z7p << "        if(err) {"<<endl;
     z7p << "           cout<<endl<<\"Error when transferring sdv to mesh: \"<<geof_name<<\" ... end\"<<endl<<endl;"<<endl;
     z7p << "           break;"<<endl;
     z7p << "        }"<<endl;
     if(abaqus_reequilibrium) {
         str = del_cmd + " REEQUILIBRIUM*";
         z7p << "        system(\"" << str << "\");"<<endl;
         z7p << "        err = export_mesh_templated(cyc,1);"<<endl;
         z7p << "        if(err) {"<<endl;
         z7p << "           cout<<endl<<\"Failed to generate the REEQUILIBRIUM \"<<format<<\" input file\";"<<endl;
         z7p << "           break;"<<endl;
         z7p << "        }"<<endl;
         z7p << "        cmd = fe_cmd + \" -sdv0 REMESHED REEQUILIBRIUM\";"<<endl;
         z7p << "        cout<<\" . reequilibrium at cycle \"<<cyc<<\" using command: \"<<cmd<<endl<<endl; cflush();"<<endl;
         z7p << "        err = system(cmd);"<<endl;
         z7p << "        if(err) {"<<endl;
         z7p << "           cout<<endl<<\"An error occured during reequilibrium at cycle: \"<<cyc<<\" ... end\"<<endl<<endl;"<<endl;
         z7p << "           break;"<<endl;
         z7p << "        }"<<endl;
     }
     z7p << "     }"<<endl;
     z7p << endl;
  }
  z7p << "     cout<<endl<<\" . generation of \"<<format<<\" input file for cycle: \"<<cyc<<endl<<endl; cflush();"<<endl;
  z7p << "     err = export_mesh_templated(cyc,0);"<<endl;
  z7p << "     if(err) {"<<endl;
  z7p << "        cout<<endl<<\"Failed to generate the \"<<format<<\" input file at cycle: \"<<cyc<<endl<<endl;"<<endl;
  z7p << "        break;"<<endl;
  z7p << "     }"<<endl;

  z7p << endl;
  if(format.start_with("abaqus")) {
    z7p << "     remove_abaqus_files(cyc-1);"<< endl;
  }else if(format.start_with("zebulon")) {
    z7p << "     remove_zebulon_files(cyc-1);"<< endl;
  }
  z7p << endl;

  if(abaqus_reequilibrium) {
      z7p << "     cmd = fe_cmd;"<<endl;
      z7p << "     if(if_transfert * (cyc>1) ) cmd = cmd + \" -oj REEQUILIBRIUM \";"<<endl;
      z7p << "     cmd = cmd + \" \" + cracked_name+\"_PROPAG\"+itoa(cyc);"<<endl;
  }
  else if(ansys_reequilibrium) {
      z7p << "     cmd = fe_cmd;"<<endl;
      z7p << "     if(if_transfert * (cyc>1) ) cmd = cmd + \" -sdv0 REMESHED \";"<<endl;
      z7p << "     cmd = cmd + \" \" + cracked_name+\"_PROPAG\"+itoa(cyc);"<<endl;
  }
  else if(format.start_with("aster")) {
    z7p << "     cmd = fe_cmd + \" \" + cracked_name+\"_PROPAG\"+itoa(cyc)+\".export\";"<<endl;
  }
  else {
      if(!got_job){
            z7p << "     cmd = fe_cmd + \" \" + cracked_name+\"_PROPAG\"+itoa(cyc);"<<endl;
      }
      else         z7p << "     cmd = fe_cmd + cracked_name+\"_PROPAG\"+itoa(cyc)+\".inp\";"<<endl;
  }
  z7p << "     cout<<endl<<\" . computation of cycle \"<<cyc<<\" using command: \"<<cmd<<endl<<endl; cflush();"<<endl;
  z7p << "     err = system(cmd);"<<endl;
  if(format=="aster_templated") z7p << "     err = 0;"<<endl;
  z7p << "     if(err) {"<<endl;
  z7p << "        cout<<endl<<\"An error occured during FE computation of cycle: \"<<cyc<<\" ... end\"<<endl<<endl;"<<endl;
  z7p << "        break;"<<endl;
  z7p << "     }"<<endl;

  if(if_czm) { 
    // Extract front with post_processing
    z7p << "    cout<<endl<<\" . Computation of cohesive front at cycle: \"<<cyc<<endl<<endl; cflush();"<<endl;
    z7p << "    front_pp_name= cracked_name+\"_czm_front\"+itoa(cyc);"<<endl;
    z7p << "    write_gpp_czm_front_searching(cyc);"<<endl;
    z7p << "    cmd = \""<<zrun_cmd<<" -pp \"+front_pp_name;"<<endl;
    z7p << "    err = system(cmd);"<<endl;
    z7p << "    if(err) {"<<endl;
    z7p << "        cout<<endl<<\"An error occured when searching Cohesive Zone front at cycle: \"<<cyc<<\" ... end\"<<endl<<endl;"<<endl;
    z7p << "        break;"<<endl;
    z7p << "    }"<<endl;
    z7p << "   STD_CP(front_pp_name+\".post\",\"the_front_file\");"<<endl;
  }

  z7p << endl;
  if(format.start_with("aster"))
  {
        z7p << "     write_gpp_aster(cyc);"<<endl;
        z7p << "  cmd = \""<<zrun_cmd<<" -pp -smp \"+itoa(smp)+\" \"+cracked_name+\"_GPP_PROPAG_aster\"+itoa(cyc);"<<endl;
        //z7p << "     cmd = \""<<zrun_cmd<<" -pp -smp \"+itoa(smp)+\" \"+cracked_name+\"_PROPAG\"+itoa(cyc);"<<endl;
        z7p << "     err = system(cmd);"<<endl;
  }
  z7p << "     gpp_name = cracked_name+\"_GPP_PROPAG\"+itoa(cyc);"<<endl;
  if(if_czm) { 
    z7p << "     write_gpp_templated_czm(cyc);"<<endl;
  } else {
    z7p << "     write_gpp_templated(cyc);"<<endl;
  }
  z7p << "     cout<<endl<<\" . computation of SIF at cycle: \"<<cyc<<endl<<endl; cflush();"<<endl;

  if(nb_dd>1) {
    // Faire des trucs ici
    // Perform parallel post adding GPP at the end of cracked_SIF
    // Regenerate cracked_SIF + add GPP a the end
    z7p << "   cmd = \"cat \"+gpp_name+\".inp >> \"+cracked_name+\"_PROPAG\"+itoa(cyc)+\".inp\";";
    z7p << "   ret=system(cmd);"<<endl;
    z7p << "   cmd = \""<<zrun_cmd<<" -mpimpi \"+itoa(nb_dd)+\" -smp \"+itoa(2*smp)+\" -pp \"+cracked_name+\"_PROPAG\"+itoa(cyc)+\".inp\";";
  }
  else if(smp>1) {
     z7p << "     cmd = \""<<zrun_cmd<<" -pp -smp \"+itoa(smp)+\" \"+gpp_name;"<<endl;
  }
  else z7p << "     cmd = \""<<zrun_cmd<<" -pp \"+gpp_name;"<<endl;
  z7p << "     err = system(cmd);"<<endl;
  z7p << "     if(err) {"<<endl;
  z7p << "        cout<<endl<<\"An error occured when computing SIF at cycle: \"<<cyc<<\" ... end\"<<endl<<endl;"<<endl;
  z7p << "        break;"<<endl;
  z7p << "     }"<<endl;

  z7p << endl;
  // Symplified new version: we do not want drive crack anymore!
  // too difficult to insure correct propagation of complex splitting fronts
  // all operation are done in a new function
  z7p << "     if(propag_and_remesh(cyc,max_remesh,-1.)==1) break;"<<endl;
  z7p << endl;
    
  //ABR---05/2021
  //if((nb_dd>1)||(format=="aster_templated")) {
  if((nb_dd>1)) {
    z7p << "     STD_CP(\"REMESHED.geo\",(cracked_name+\"_PROPAG\"+itoa(cyc+1)+\".geo\"));"<<endl;
  } else if(if_2D&&(!if_2DE)&&(!if_shell)) {
    z7p << "     apply_mesher(\"REMESHED.geo\",cracked_name+\"_PROPAG\"+itoa(cyc)+\".geo\",\"**to_2d\");"<<endl;
    z7p << "     STD_CP(\"REMESHED.geo\",cracked_name+\"_PROPAG\"+itoa(cyc)+\".geo3D\");"<<endl;
  } else        z7p << "     STD_CP(\"REMESHED.geo\",(cracked_name+\"_PROPAG\"+itoa(cyc)+\".geo\"));"<<endl;

  z7p << endl;
  z7p << "  }"<<endl;
  //ABR---11/2022...vtk data for Airbus porject
  //vtk_series_file_name = "VTK_2D_CRACK_LIP_DATA.vtk.series";
  //vtk_prefix           = "2D_CRACK_LIPS_CYC_";
  //z7p << "  write_vtk_data(nb_cyc,\""<<vtk_series_file_name<<"\",\""<<vtk_prefix<<"\");"<<endl;
  //vtk_series_file_name = "VTK_1D_CRACK_FRONT_DATA.vtk.series";
  //vtk_prefix           = "1D_CRACK_FRONT_CYC_";
  //z7p << "  write_vtk_data(nb_cyc,\""<<vtk_series_file_name<<"\",\""<<vtk_prefix<<"\");"<<endl;

  z7p << endl;
  z7p << "}"<<endl;
 
  if(!qsub_file_name){
    if(format == "abaqus_templated"){
      str = "perl " + qsub_file_name + " -propag";
      system(str);
    }
    else
      ERROR("qsub submission is not implemented yet for "+format+ " format");
  }

  return(0);
}

double get_NDN_from_remesh(int cyc, double &DN)
{
  ASCII_FILE asc;
  Zfstream  f;
  STRING name, line, str, cur_line;
  LIST<STRING> previous_vals;
  int i, pos;
  double time, prev_time, nb_cyc, a,Ncyc;
  VECTOR v, dv;

  Ncyc=0.; DN=0.;
  time = fatigue_Ti + cyc*fatigue_DT;

  name = cracked_name + "_PROPAG.remesh";
  asc.open(name);

  nb_cyc = 0.0; a = 0.0; // cumulative_values
  prev_time = -1.0;
  if(asc.ok) {
     prev_time = -1.0;
     for(i=0;i>=0;i++) {
        line = asc.getline();
        if(!asc.ok) break;
        if(!line<2) continue;
        cur_line = line;
        str = line.getSTRING();
        if(str.is_double()) prev_time = str.to_double();
        else break;
        if(prev_time>(time-1.e-6)) { 
          str=line.getSTRING(); 
          if(str.is_double()) DN= str.to_double();
          str=line.getSTRING(); 
          if(str.is_double()) Ncyc= str.to_double();
          break; 
        }
        previous_vals.add(cur_line);
     } 
  }
  asc.close();
  
  return(Ncyc);
}

int update_remesh_file(int cyc, double da, double dN, int fid, int pt, ARRAY<VECTOR> &fronts, MATRIX &Gvalues)
{ ASCII_FILE asc;
  Zfstream  f;
  STRING name, line, str, cur_line;
  LIST<STRING> previous_vals;
  int i, pos;
  double time, prev_time, nb_cyc, a;
  VECTOR v, dv;

  time = fatigue_Ti + cyc*fatigue_DT;

  name = cracked_name + "_PROPAG.remesh";
  asc.open(name);

  nb_cyc = 0.0; a = 0.0; // cumulative_values
  prev_time = -1.0;
  if(asc.ok) {
     prev_time = -1.0;
     for(i=0;i>=0;i++) {
        line = asc.getline();
        if(!asc.ok) break;
        if(!line<2) continue;
        cur_line = line;
        str = line.getSTRING();
        if(str.is_double()) prev_time = str.to_double();
        else break;
        if(prev_time>(time-1.e-6)) break;
        previous_vals.add(cur_line);
     } 
  }
  asc.close();

  if(!previous_vals) {
     line = previous_vals[!previous_vals-1];
     for(i=0;i<2;i++) line.getSTRING();
     str = line.getSTRING();
     if(str.is_double()) nb_cyc = str.to_double();
     for(i=0;i<8;i++) line.getSTRING();
     str = line.getSTRING();
     if(str.is_double()) a = str.to_double();
  }

  nb_cyc = nb_cyc + dN;
  a = a + da;
  v.resize(3); dv.resize(3);
  pos = 3 + 9*pt;
  for(i=0;i<!v;i++) { 
     v[i] = fronts[fid][pos]; 
     dv[i] = fronts[fid][3+pos]; 
     pos = pos+1; 
  }

  // .remesh file
  f.open(name,ios::out);
  f.setf(ios::scientific);
  f.precision(64);
  f<<"# time dN N fid_max x_max y_max z_max ux_max uy_max uz_max da_max a_max"<<endl;
  for(i=0;i<!previous_vals;i++) f << previous_vals[i] << endl;
  f << time << " " << dN << " " << nb_cyc << " " << fid << " ";
  for(i=0;i<3;i++)  f << v[i] << " ";
  for(i=0;i<3;i++)  f << dv[i] << " ";
  f << da << " " << a << endl;
  f.close();

  return(0);
}

int update_zck_file(int cyc, double dN, ARRAY<VECTOR> &fronts, MATRIX &Gvalues,
  ARRAY<VECTOR>& aDX, ARRAY<VECTOR>& aDY)
{ ASCII_FILE asc;
  Zfstream  f;
  STRING name, line, str, cur_line, cyc_str;
  LIST<STRING> previous_vals;
  LIST<int> val_to_output;
  int i, j, k, l, nb_written, nb_calc, pos, nb_prev_front,nb_front, id, max_id;
  double time, prev_time, nb_cyc, a, da, K, Kmin, Kmax,Tmin,Tmax,inc,posv;
  VECTOR output_vals;
  ARRAY<VECTOR> a0;
  LIST<int> cur_ids;

  if(nb_pt<2) nb_pt=2; //
  time = fatigue_Ti + cyc*fatigue_DT;
  name = cracked_name + "_PROPAG.zck";
  asc.open(name);

  max_id = -1;
  for(i=0;i<!fronts;i++) {
     id = fronts[i][0];
     if(id>max_id) max_id = id;
     cur_ids.add(id);
  }
  nb_front = max_id+1;

  nb_cyc = 0.0; a = 0.0; // cumulative_values
  prev_time = -1.0;
  a0.resize(nb_front);
  for(i=0;i<!a0;i++) { a0[i].resize(nb_pt); a0[i] = 0.0; }
  if(asc.ok) {
     prev_time = -1.0;
     for(i=0;i>=0;i++) {
        line = asc.getline();
        if(!asc.ok) break;
        if(!line<2) continue;
        cur_line = line;
        cyc_str = line.getSTRING();
        for(j=0;j<3;j++) str = line.getSTRING();
        if(str.is_double()) prev_time = str.to_double();
        else break;
        if(prev_time>(time-1.e-6)) break;
        if(cyc_str.is_double()) nb_cyc = cyc_str.to_double();
        else {
           ERROR("\nInvalid "+name+" file, cannot #cycles\n");
           return(1);
        } 
        line.getSTRING();
        str = line.getSTRING();
        if(str.is_int()) nb_prev_front = str.to_int();
        else {
           ERROR("\nInvalid "+name+" file, cannot read #fronts\n");
           return(1);
        }
        for(j=0;j<nb_prev_front;j++) {
            for(k=0;k<nb_pt;k++) {
                for(l=0;l<4;l++) str = line.getSTRING();
                if(j<!a0) {
                   if(str.is_double()) a0[j][k] = str.to_double();
                }
                for(l=0;l<8;l++) line.getSTRING();
            }
        }
        previous_vals.add(cur_line);
     }
  }
  asc.close();

  nb_cyc = nb_cyc + dN;

  // .zck file

  output_vals.resize(12); output_vals = 0.0;
  f.open(name,ios::out);
  f.setf(ios::scientific);
  f.precision(64);
  f << "# Zcracks propagation informations" << endl;
  f << "# 1:N 2:DeltaN 3:icycle 4:time 5:point_nb 6:front_nb (front_nb)x{ (point_nb)x{  7+(point_nb*12)*fid:3Dpos 7+(point_nb*12)*fid+3:clength 7+(point_nb*12)*fid+4:3Dincr 7+(point_nb*12)*fid+7:delta_length 7+(point_nb*12)*fid+8:Kmin 7+(point_nb*12)*fid+9:Kmax 7+(point_nb*12)*fid+10:Tmin 7+(point_nb*12)*fid+11:Tmax" << endl;
  for(i=0;i<!previous_vals;i++) f << previous_vals[i] << endl;
  f << nb_cyc << " " << dN << " " <<  cyc << " " << time << " " << nb_pt << " " <<  (max_id+1);
  posv=0.;
  i = 0;
  for(id=0;id<nb_front;id++) {
     // no interpolation on nb_written output points in POST_GTHETA
     // output of closest values delved in the nb_calc points
     if(!cur_ids.is_in(id)) {
        // front disapeared ... writing 0 vals
        for(k=0;k<nb_pt;k++) {
           for(l=0;l<12;l++) f << " " << 0.0;
        }
        continue;
     }
     nb_calc = fronts[i][1];
     nb_written = nb_pt;
     //if(nb_written>nb_calc) nb_written = nb_calc;
     //if(nb_written<1)       nb_written = 1;
     inc =(nb_calc-1);
     posv=(nb_written-1);
     if(posv==0) inc=1.;
     else inc=inc/posv;
     val_to_output.reset();
     val_to_output.add(0);
     for(j=1;j<=(nb_written-2);j++) {
       Kmin=j*inc;
       l=round(Kmin);
       if(l>(nb_calc-1)) l=nb_calc-1;
       val_to_output.add(l);
     }
     if(nb_calc>1) val_to_output.add(nb_calc-1);
//    cout<<"VAL TO OUTPUT : ";
//    for(j=0;j<val_to_output.size();j++) cout << " " << val_to_output[j] ;
//    cout << endl;
     // extract values on the nb_written output points from the nb_calc calculated ones
     num_pt = 0;
     posv=0.;
     for(l=0;l<val_to_output.size();l++) {
        j=val_to_output[l];
        // point cur pos and displacements
        num_pt=j;
        pos = 3 + 9*num_pt;
        for(k=0;k<3;k++) {
           output_vals[k]   = fronts[i][pos];
           output_vals[4+k] = fronts[i][3+pos];
           pos = pos + 1;
        }
        Kmin = 1.e19; Kmax = -1.e19;
        for(k=0;k<Gvalues.n;k++) {
           pos = fronts[i][2]+2+(4+extrafield)*num_pt;
           K = Gvalues(k,pos);
           T = Gvalues(k,pos+3); // Get temp
           if(K<=Kmin) { 
             Kmin = K;
             Tmin = T;
           }
           if(K>=Kmax) {
             Kmax = K;
             Tmax = T;
           }
        }
        if(aDX.size()==0) da=0.;
        else da = sqrt(aDX[i][num_pt]*aDX[i][num_pt] + aDY[i][num_pt]*aDY[i][num_pt]);
        a  = a0[id][l] + da;
        if(Gvalues.n==1) Kmin = 0.0;
        output_vals[3] = a;
        output_vals[7] = da;
        output_vals[8] = Kmin;
        output_vals[9] = Kmax;
        output_vals[10] = Tmin;
        output_vals[11] = Tmax;
        for(k=0;k<!output_vals;k++) f << " " << output_vals[k];
        posv=posv+inc;
        if(posv>nb_calc) posv=nb_calc-1;
        num_pt = posv;
        if(num_pt>=nb_calc) num_pt = nb_calc-1;
     }
     i = i+1;
  }
  f <<endl;
  f.close();

  return(0);
}

// Use G values to scale Vector size
int write_front_file_from_zcpost()
{ ARRAY<VECTOR> fronts;
  ARRAY<VECTOR> front_nodes,front_G;
  VECTOR front_Gv;
  int nnodes;
  MATRIX Gvalues;
  VECTOR Gtime,Sfront,Cfront;
  MATRIX G,GII,ALPHA,TEMP;
  STRING name;
  int err;
  Zfstream out,vtk;
  int i, j, k, nb, pos, id;
  VECTOR v, norm;
  VECTOR Gf; 
  double Nsz=min_size*10.,dmax,gmax; 

  // Vtk 
  nnodes=0;
  front_nodes.resize(4096);
  front_G.resize(4096);
  front_Gv.resize(4096);

  err = 0;
  name = cracked_name + "_SIF_PP.ZCPOST";
  err= read_zcpost(name,fronts,Gvalues);

  if(err) { 
    name = cracked_name + "_GPP.ZCPOST";
    err= read_zcpost(name,fronts,Gvalues);
  }
  if(err) {
     ERROR("\nNo file "+name+" ... run SIF computation\n");
     return(1);
  }
 
 
  v.resize(3);  norm.resize(3);
  for(i=0;i<!fronts;i++) {
     id = fronts[i][0];
     name = "FRONT"+itoa(id)+"_FRONT";
     out.open(name,ios::out);
     out.setf(ios::scientific);
     out.precision(12);
     nb = fronts[i][1];
     pos = 3;
     // Get G
     Gf.resize(nb);
     Gf=1.;
     Nsz=0.;
     if(get_front_info(fronts,Gvalues,i,Gtime,G,GII,ALPHA,TEMP,Sfront,Cfront)) { 
       Gf=1.; 
     } else {
       for(j=0;j<nb;j++) {
         Gf[j]=G(0,j);
         for(k=1;k<G.n;k++) if(G(k,j)>Gf[j]) Gf[j]=G(k,j);
         if(abs(Gf[j])>Nsz) Nsz=abs(Gf[j]);
       }
       gmax=Nsz;
       Nsz=1./Nsz;
       Gf=Gf*Nsz; 
     }
     pos=3;
     for(k=0;k<3;k++) { v[k] = fronts[i][pos]; pos = pos + 1; }
     Nsz=5.*min_size;
     for(j=0;j<nb;j++) {
       for(k=0;k<3;k++) { 
         dmax=abs(v[k]-fronts[i][pos]); 
         if(dmax>Nsz) Nsz=dmax;
         pos = pos + 1; 
       }
       pos = pos+6;
     }
     Nsz=Nsz/5.;
     cout << "*** G factor for front "<<i<<" Gmax_factor = "<<Nsz<<" Gmax = "<<gmax<<" ampli = "<<(Nsz/gmax)<<endl;
     pos=3;
     for(j=0;j<nb;j++) {
        for(k=0;k<3;k++) { v[k] = fronts[i][pos]; pos = pos + 1; }
        for(k=0;k<3;k++) out << v[k] << " ";
        if(nnodes<front_nodes.size()) {
          front_nodes[nnodes].resize(3);
          front_nodes[nnodes]=v;
          front_Gv[nnodes]=Gf[j]*gmax;
        }
        out << endl;
        for(k=0;k<3;k++) { norm[k] = fronts[i][pos]; pos = pos + 1; }
        dv = v.norm();
        dn = norm.norm(); 
        if(dn>0.0) norm = norm*(1.0/dn);
        //for(k=0;k<3;k++) out << (v[k]+0.01*dv*norm[k]) << " ";
//        for(k=0;k<3;k++) out << (Gf[j]*Nsz*norm[k]) << " ";
        if(nnodes<front_nodes.size()) {
          front_G[nnodes].resize(3);
          for(k=0;k<3;k++) front_G[nnodes][k]=Gf[j]*gmax*norm[k];
          nnodes=nnodes+1;
        }
        for(k=0;k<3;k++) out << (v[k]+Gf[j]*Nsz*norm[k]) << " ";
        //for(k=0;k<3;k++) out << norm[k] << " ";
        //out<<Nsz<<" "<<Gf[i]<<endl;
        out << endl;
        for(k=0;k<3;k++) out << v[k] << " ";
        out << endl;
        pos = pos + 3;
     }
     out.close();
  }

  cout<<"Generating "<<cracked_name<<"_G.vtk datafile"<<endl;
  vtk.open(cracked_name+"_G.vtk",ios::out);
  vtk.setf(ios::scientific);
  vtk.precision(64);
  vtk<<"# vtk DataFile Version 3.0"<<endl;
  vtk<<"VTK from Zcracks"<<endl;
  vtk<<"ASCII"<<endl;
  vtk<<"DATASET UNSTRUCTURED_GRID"<<endl;
  vtk<<"POINTS "<<nnodes<<" FLOAT"<<endl;
  for(j=0;j<nnodes;j++) {
    vtk<<front_nodes[j][0]<<" "<<front_nodes[j][1]<<" "<<front_nodes[j][2]<<endl;
  }
  vtk<<"POINT_DATA "<<nnodes<<endl;
  vtk<<"SCALARS norm_force float"<<endl;
  vtk<<"LOOKUP_TABLE default"<<endl;
  for(j=0;j<nnodes;j++) {
    vtk<<front_Gv[j]<<endl;
  }
  vtk<<"VECTORS force float"<<endl;
  for(j=0;j<nnodes;j++) {
    vtk<<front_G[j][0]<<" "<<front_G[j][1]<<" "<<front_G[j][2]<<endl;
  }
  vtk.close();
  cout<<"Done."<<endl;
  return(0);
}

int update_Z8()
{ Zfstream inp;
  STRING name, res_format;

  res_format = "Z7";
  if(format.start_with("abaqus"))      res_format = "odb";
  else if(format.start_with("ansys"))  res_format = "rst";
  else if(format.start_with("samcef")) res_format = "u18";

  name = cracked_name + "_z8.inp";
  inp.open(name,ios::out);
  inp.setf(ios::scientific);

  inp << "****concatenate_z8"<<endl;
  //ABR---06/2021 for aster we use the intermediate files to convert the med into zset for PP
  if(format.start_with("aster"))
  {
    inp << " ***prefix "<<cracked_name<<"_GPP_PROPAG_aster"<<endl;
  }
  else
  {
    inp << " ***prefix "<<cracked_name<<"_PROPAG"<<endl;
  }
  inp << " ***format "<<res_format<<endl;
  inp << " ***fields sig U";
  if(is_ductile)inp << " RU";
  inp<<endl;
  if(!format.start_with("aster"))   inp << " ***retrieve_sets_from "<<cracked_name<<" "<<cracked_name<<"_PROPAG"<<endl;
  if(is_ductile)  inp << " ***skip_zero_dtime"<<endl;
  if( (fatigue_Ti>0.0) ) inp<< " ***preload "<<fatigue_Ti<<endl;

  inp<< "%***output"<<endl;
  inp<< "% **frequency"<<endl;
  if(fatigue_Ti>0.0)
    inp<< "%  *preload "<<fatigue_Ti<<"      % preload time, defined in the propagation tab"<<endl;
  inp<< "%  *d_cycle 1                 % output every d_cycle"<<endl;
  inp<< "%  *cycle_period "<<fatigue_DT<<" % cycle period, defined in the propagation tab"<<endl;
  inp<< "%  *at "<<fatigue_DT<<"           % cycle local time"<<endl;
  inp << "****return"<<endl;

  inp.close();
  return(0);
}

int get_sel(LIST<STRING>& avail, STRING& name, int& rk)
{ int i;
  rk = -1;
  for(i=0;i<!avail;i++) {
    if(avail[i]==name) { rk=i; return(1); }
  }
  return(0);
}

void get_sane_name()
{ if(!batch_mode) {
    sane_name = graphics_app.get_file_selection(dname,"Sane name");
    if(sane_name.locate(".")) {
       sane_name.remove_suffix();
       graphics_app.set_file_selection(dname,"Sane name",sane_name);
    }
  }
}

void remove_abaqus_files(int cyc)
{
  int i;
  LIST<STRING> ext;
  STRING file_name;
  if(cyc>0){
    ext.add("stt");
    ext.add("mdl");
    ext.add("prt");
    ext.add("res");
    ext.add("sim");
    ext.add("com");

    cout<< "  Remove abaqus files from cycle "<<cyc<<" :"<<endl;cflush();

    for(i=0;i<!ext;i++) {
      file_name = cracked_name + "_PROPAG"+itoa(cyc)+"."+ext[i];
      cout<< " - "<<file_name<<endl;cflush();
      STD_RM((file_name));
    }
  }
}

void remove_zebulon_files(int cyc)
{
  int i;
  LIST<STRING> ext;
  STRING file_name;
  if(cyc>0){
    ext.add("rst");

    cout<< "  Remove useless zebulon files from cycle "<<cyc<<" :"<<endl;cflush();

    for(i=0;i<!ext;i++) {
      file_name = cracked_name + "_PROPAG"+itoa(cyc)+"."+ext[i];
      cout<< " - "<<file_name<<endl;cflush();
      STD_RM((file_name));
    }
  }
}

void save_sif_files(int nb_fronts, int cyc)
{
  int i;
  STRING file_name, new_file_name;
  ASCII_FILE ascf;

  STD_MKDIR(cracked_name+"_SIFS");

  for(i=0;i<nb_fronts;i++) {
    file_name = "FRONT"+itoa(i)+"_SIF";
    new_file_name = cracked_name+"_SIFS/FRONT"+itoa(i)+"_SIF_CYC"+itoa(cyc);

    ascf.open(file_name);
    if(ascf.ok) {
      ascf.close();
      cout<< " - move "<<file_name<<" from cycle "<<cyc<<" to "<<new_file_name<<endl;cflush();
      STD_CP(file_name,new_file_name);
    }
  }
}

int write_gnuplot_from_propag_law(STRING gnun)
{
  int i, err, max_val;

  VECTOR Gtimes,G,A,T;
  double dK,R,dx,dy;

  Zfstream gnuf;
  gnuf.open(gnun,ios::out);
  gnuf.setf(ios::scientific);
  gnuf.precision(8);

  Gtimes.resize(2); G.resize(2); A.resize(2); T.resize(2);
  Gtimes[0]=1.; Gtimes[1]=1.; A=0.0; T=0.0; dx=0.0; dy=0.0; dK=0.0;
  max_val=1000;

  load_factor.resize(3);
  load_factor[0]=0.; load_factor[1]=0.25; load_factor[2]=0.5;

  if(propag_model != "paris_std"){
    if(propag_law.Null()) {
       propag_law.set(Create_object("ZCRACKS_PROPAG_LAW",propag_model));
    }

    if(propag_model == "z7p") err = propag_law.initialize(propag_script,propag_mat_file);
    else                      err = propag_law.initialize("",propag_mat_file);
    if(err) ERROR("Cannot initialize the propag law");
    
    //find max upper bound for delta K
    if(propag_model == "forman"){
      for(i=0;i<!propag_coefficients;i++) {
        if((propag_coefficients[i].get_name()=="Kc") && (propag_coefficients[i].constant)) {
          max_val = propag_coefficients[i].compute_value()*2.;
        }
      }
    }

    gnuf<<"# ";
    for(j=0;j<load_factor.size();j++){
      gnuf<<"dK("<<load_factor[j]<<")	da	";
    }
    gnuf<<endl;

    for(i=0;i<max_val;i++){
      for(j=0;j<load_factor.size();j++){
        G[1]=1.+i;
        G[0]=G[1]*load_factor[j];
        dK=G[1]-G[0]; // delta K
        R=G[0]/G[1];  // loading factor
        da = propag_law.compute_propag(Gtimes,G,A,T,dx,dy);
        gnuf<<dK<<" "<<da<<" ";
      }
      gnuf<<endl;
    }
  }
  else{
    err = get_paris_std_coefs(propag_mat_file);
    for(i=0;i<max_val;i++){
      G[0]=0.1;
      G[1]=1.+i;
      dK=G[1]-G[0]; // delta K
      R=G[0]/G[1];  // loading factor
      da = paris_law(Gtimes,G,A,T,dx,dy);
      gnuf<<dK<<" "<<da<<" "<<R<<endl;
    }
  }

  gnuf.close();
  return(1);
}

int write_gnuplot_from_zck(int code, STRING gnun)
{ ASCII_FILE zck;
  STRING zckn;
  Zfstream gnuf;
  double N, dN;
  int i, cyc, np, nf, j, k, l;
  VECTOR point_vals;

  point_vals.resize(12);

  reshape_zck(cracked_name+"_PROPAG.zck",cracked_name+"_PROPAG_rs.zck",nb_pt,0.,1.);
  zckn = cracked_name+"_PROPAG_rs.zck";
  zck.open(zckn);
  gnuf.open(gnun,ios::out);
  gnuf.setf(ios::scientific);
  gnuf.precision(64);
  
  if(!zck.ok) {
     cout<<endl<<"Cannot open ZCK file: "<<zckn<<endl<<endl;
     return(0);
  }
  gnuf<<"# ";
  if(code>6) { 
     cout<<endl<<"Not available"<<endl<<endl;
     return(0);
  }
  if(code<4) gnuf<<" N";
  if(code==0) {
     for(i=0;i<nb_pt;i++) gnuf<<" a("<<i<<",N)";
  }
  else if(code==1) {
     for(i=0;i<nb_pt;i++) gnuf<<" da_dN("<<i<<",N)";
  }
  else if(code==2) {
     for(i=0;i<nb_pt;i++) gnuf<<" Kmin("<<i<<",N) Kmax("<<i<<",N)";
  }
  else if(code==3) {
     for(i=0;i<nb_pt;i++) gnuf<<" Tmin("<<i<<",N) Tmax("<<i<<",N)";
  }
  else if(code==4) {
     for(i=0;i<nb_pt;i++) gnuf<<" Delta_K("<<i<<") da_dN("<<i<<")";
  }
  else if(code==5) {
     for(i=0;i<nb_pt;i++) gnuf<<" Kminmax("<<i<<") a("<<i<<")";
  }
  else if(code==6) {
     for(i=0;i<nb_pt;i++) gnuf<<" Tminmax("<<i<<") a("<<i<<")";
  }
  gnuf<<endl;
  for(i=0;i>=0;i++) {
     N = zck.getdouble(); // N
     if(!zck.ok) break;
     N = N*fact_nc;
     dN = zck.getdouble(); // dN
     dN = dN*fact_nc;
     cyc = zck.getint();
     zck.getSTRING(); // time
     np = zck.getint();
     nf = zck.getint();
     if(front_view>(nf-1)) { 
        // front is not available for this cycle
        // skip all available fronts
        for(j=0;j<nf;j++) {
            for(k=0;k<nb_pt;k++) {
                for(l=0;l<12;l++) zck.getSTRING();
            }
        } 
     }
     else {
        for(j=0;j<front_view;j++) {
            for(k=0;k<nb_pt;k++) {
                for(l=0;l<12;l++) zck.getSTRING();
            }
        } 
        if(code<4) { 
          gnuf<<(N-dN)<<" ";
        } 
        for(k=0;k<nb_pt;k++) {
           for(l=0;l<!point_vals;l++) point_vals[l] = zck.getdouble();
           if(code==0) gnuf<<(point_vals[3]-point_vals[7])<<" ";                // a(N)
           else if(code==1)  gnuf<<(point_vals[7]/dN)<<" ";                     // da_dN(N) 
           else if(code==2)  gnuf<<point_vals[8]<<" "<<point_vals[9]<<" ";      // SIF(N)
           else if(code==3)  gnuf<<point_vals[10]<<" "<<point_vals[11]<<" ";    // T(N)
           else if(code==4)  {                                                  // da_dN(DK)
              double Kmin_val = 0.;
              if(point_vals[8]<0.) Kmin_val=0.;
              //gnuf<<(point_vals[9]-point_vals[8])<<" "<<(point_vals[7]/dN)<<" ";
              //in actual propag laws we do not consider negative Kmin values
              gnuf<<(point_vals[9]-Kmin_val)<<" "<<(point_vals[7]/dN)<<" ";
           } 
           else if(code==5)  gnuf<<(point_vals[3]-point_vals[7])<<" "<<point_vals[8]<<" "<<point_vals[9]<<" "; // Kminmax(a)
           else if(code==6)  gnuf<<(point_vals[3]-point_vals[7])<<" "<<point_vals[10]<<" "<<point_vals[11]<<" "; // Tminmax(a)(DK)
        }
        gnuf<<endl;
        for(j=front_view+1;j<nf;j++) {
            for(k=0;k<nb_pt;k++) {
                for(l=0;l<12;l++) zck.getSTRING();
            }
        } 
     }
  }
  gnuf.close();
  return(1);
  
}

int read_advance_plot_dialog()
{ STRING str,fname0,fname1;
  ASCII_FILE file;
  ARRAY<VECTOR> fronts;
  MATRIX Gvalues,gp_data;
  ARRAY<int>     defaults;
  ARRAY<STRING>  options;
  int iferr=0,i,i0,i1,is,id;

  zcpost_file = graphics_app.get_file_selection("Advanced Plot",".ZCPOST file");
  fname1=zcpost_file; 
  fname0=zcfile_to_index(fname1,i0,is,i1);
  file.open(fname0);
  if(file.ok) {
    iferr=read_zcpost(fname0,fronts,Gvalues);
  } else iferr=1;

  str="\n"+fname0+" is an invalid .ZCPOST file";
  if(iferr) ERROR(str);

  // Reset 
  options.resize(0);
  graphics_app.set_list_group("Advanced Plot","Fronts",options,-1);
  graphics_app.set_list_group("Advanced Plot","Fields",options,-1);
  graphics_app.set_list_group("Advanced Plot","Times",options,-1);

  // Fronts
  options.resize(zcpost_nfronts);
  for(i=0;i<options.size();i++) {
    id = fronts[i][0];
    options[i]=itoa(id);
  }
  graphics_app.set_list_group("Advanced Plot","Fronts",options,-1);
  // Fields
  options.resize(zcpost_fields.size()+1);
  for(i=0;i<zcpost_fields.size();i++)
    options[i]=zcpost_fields[i];
  options[i]="Curvature";
  graphics_app.set_list_group("Advanced Plot","Fields",options,-1);
  // Times
  options.resize(zcpost_times.size());
  for(i=0;i<options.size();i++)
    options[i]=dtoa(zcpost_times[i]);
  graphics_app.set_list_group("Advanced Plot","Times",options,-1);
  
  return(iferr);
}

void plot_selec_dialog()
{ int ok;
  ok = 1;
  zcpost_file = graphics_app.get_file_selection("Advanced Plot",".ZCPOST file");
  graphics_app.get_list_group("Advanced Plot","Fronts",select_fronts);
  if(!select_fronts==0) { ERROR("Please select a front id"); ok = 0; }
  graphics_app.get_list_group("Advanced Plot","Fields",select_fields);
  if(!select_fields==0) { ERROR("Please select fields to plot"); ok = 0; }
  graphics_app.get_list_group("Advanced Plot","Times",select_times);
  if(!select_times==0) { ERROR("Please select output Times"); ok = 0; }
  if(ok) extrafields_to_gnuplot(zcpost_file);
} 


int read_advance_propag_dialog()
{ STRING cfile;
  cfile = graphics_app.get_file_selection("Advanced propag options","Propag coefs file");
  propag_script   = graphics_app.get_file_selection("Advanced propag options","Propag script file");
  if(!cfile) propag_mat_file = cfile;
  return(0);
}

int read_hexa_dialog()
{ STRING cmd;
  int int_val;

  cmd = graphics_app.get_text_field("Set hexa params","--dr-hexa");
  if(!cmd.is_double()) {
    ERROR("\nInvalid dr-hexa param: "+cmd+"\n(float expected)\n");
    return(1);
  }
  dr_hexa = cmd.to_double();

  cmd = graphics_app.get_text_field("Set hexa params","--prog-hexa");
  if(!cmd.is_double()) {
    ERROR("\nInvalid prog-hexa param: "+cmd+"\n(float expected)\n");
    return(1);
  }
  prog_hexa = cmd.to_double();

  cmd = graphics_app.get_text_field("Set hexa params","--nb-hexa");
  if(!cmd.is_int()) {
    ERROR("\nInvalid nb-hexa param: "+cmd+"\n(positive int expected)\n");
    return(1);
  }
  int_val = cmd.to_int();
  if(int_val<0) {
    ERROR("\nInvalid nb-hexa param: "+cmd+"\n(positive int expected)\n");
    return(1);
  }
  nb_hexa = int_val;

  cmd = graphics_app.get_text_field("Set hexa params","--th-hexa");
  if(!cmd.is_int()) {
    ERROR("\nInvalid th-hexa param: "+cmd+"\n(int expected)\n");
    return(1);
  }
  int_val = cmd.to_int();
  if(int_val<0) {
    ERROR("\nInvalid th-hexa param: "+cmd+"\n(positive int expected)\n");
    return(1);
  }
  th_hexa = int_val;

  cmd = graphics_app.get_text_field("Set hexa params","--nc-hexa");
  if(!cmd.is_int()) {
    ERROR("\nInvalid nc-hexa param: "+cmd+"\n(int expected)\n");
    return(1);
  }
  int_val = cmd.to_int();
  if(int_val<0) {
    ERROR("\nInvalid nc-hexa param: "+cmd+"\n(positive int expected)\n");
    return(1);
  }
 
  nc_hexa = int_val;

  return(0);
}

int read_quad_dialog()
{  
  ARRAY<int> opt_fic;

  quad_opt = graphics_app.get_radio_group("Set quad params","Quadratic choice");

  opt_fic.resize(1);
  graphics_app.get_check_group("Set quad params","Quadratic options 2",opt_fic);
  if_barsoum = opt_fic[0];

  return(0);
}

void write_default_coefs_file(STRING cfile)
{ int i;
  Zfstream out;
  out.open(cfile,ios::out);
  if(propag_model == "paris_std") {
    out<<"C 1.e-12"<<endl;
    out<<"m 3.0"<<endl;
  }
  else {
    if(!propag_law.Null()) {
       propag_law.get_coef_names(propag_script,propag_coef_names);
       for(i=0;i<!propag_coef_names;i++) out<<propag_coef_names[i]<<" 0.0"<<endl;
    }
  }
  out.close();
}

int set_propag_coefs()
{ int i, j, ok_file;
  ASCII_FILE file;
  Zfstream out;
  STRING cfile, nm;

  if((propag_model == "z7p")*(!propag_script == 0)) {
     ERROR("\nCannot set coefs of a user model. Please define the script using the Advanced command\n");
     return(1);
  }

  if(propag_model == "paris_std") {
    if(!propag_coef_names != 2) {
       propag_coef_names.resize(2);
       propag_coef_names[0] = "C"; propag_coef_names[1] = "m"; 
    }
  }
  if(!propag_mat_file == 0) cfile = propag_model+".mat";
  else                      cfile = propag_mat_file;

  file.open(cfile);
  if(!file.ok) write_default_coefs_file(cfile);

  read_coefficients(cfile,propag_coefficients);
  ok_file = 1;
  if(!propag_coefficients == !propag_coef_names) {
     for(i=0;i<!propag_coefficients;i++) {
         nm = propag_coefficients[i].get_name();
         for(j=0;j<!propag_coef_names;j++) {
            if(propag_coef_names[j]==nm) break;
         }
         if(j==!propag_coef_names) { ok_file = 0; break; }
     }
  }
  else ok_file = 0;
  if(!ok_file) {
     cfile = propag_model+".mat";
     write_default_coefs_file(cfile);
     read_coefficients(cfile,propag_coefficients);
  }
  graphics_app.add_dialog("Set coefficients");
  graphics_app.set_add_target(""); // to be sure
  graphics_app.add_label("Set coefficients","Set coef file","read from file:"+cfile);
  propag_coef_names.resize(!propag_coefficients);
  for(i=0;i<!propag_coefficients;i++) {
     propag_coef_names[i] = propag_coefficients[i].get_name();
     if(propag_coefficients[i].constant) {
        propag_coefficients[i].compute_value();
        graphics_app.add_text_field("Set coefficients",propag_coefficients[i].get_name(),dtoa(propag_coefficients[i]()));
     }
     else graphics_app.add_text_field("Set coefficients",propag_coefficients[i].get_name(),"not constant");
  }
  graphics_app.add_command_button("Set coefficients","Write","write_propag_mat_file");
  graphics_app.add_command_button("Set coefficients","Plot","plot_propag_law");
  graphics_app.realize("Set coefficients");
  propag_mat_file = cfile;

  return(0);
}

int get_paris_std_coefs(STRING fname)
{ int i;
  read_coefficients(fname,propag_coefficients);
  for(i=0;i<!propag_coefficients;i++) {
     if(propag_coefficients[i].get_name() == "C")       paris_C.set(propag_coefficients[i]);
     else if(propag_coefficients[i].get_name() == "m")  paris_m.set(propag_coefficients[i]);
  }
  if(paris_C.Null() + paris_m.Null()) {
     ERROR("Coefficients C,m not found in file: "+propag_mat_file);
     return(1);
  }
  paris_C.compute_value(); paris_m.compute_value();
  return(0);
}

int test_propag_script()
{ int i, j, ret;
  ARRAY<STRING> tmp_string;
  ASCII_FILE mat;
  LIST<COEFF> tmp_coefs;
  ARRAY<int> coef_ranks;
  VECTOR Gtimes, G, A, T;
  double da, dx, dy;

  if(propag_law.Null()) {
     propag_law.set(Create_object("ZCRACKS_PROPAG_LAW",propag_model));
  }
  ret = propag_law.get_coef_names(propag_script,tmp_string);
  if(ret) {
     ERROR("\nInvalid script: "+propag_script
       +" ?\nCannot read coefficients in function declare_coefs()\n");
     return(0);
  }
  cout<<endl<<"================================================="<<endl;
  cout<<"Test script: "<<propag_script<<endl;
  cout<<"================================================="<<endl;
  cout<<"Coefficients:";
  for(i=0;i<!tmp_string;i++) {
     cout<<" "<<tmp_string[i];
     if(i<!tmp_string-1) cout<<",";
  }
  cout<<endl;
  cflush();
  if(!propag_mat_file == 0) {
     ERROR("\nPlease give the name of of coef file before running test\n");
     return(0);
  }
  mat.open(propag_mat_file);
  if(!mat.ok) {
     ERROR("\nCannot find mat file: "+propag_mat_file+"\n");
     return(0);
  }
  mat.close();
  cout<<"Reading coefficients from file: "<<propag_mat_file<<endl;
  cflush();
  read_coefficients(propag_mat_file,tmp_coefs);
  coef_ranks.resize(!tmp_string);
  for(i=0;i<!coef_ranks;i++) coef_ranks[i] = -1;
  for(i=0;i<!tmp_string;i++) {
     for(j=0;j<!tmp_coefs;j++) {
        if(tmp_string[i] == tmp_coefs[j].get_name()) { coef_ranks[i] = j; break; }
     }
  }
  ret = 1;
  for(i=0;i<!coef_ranks;i++) {
     if(coef_ranks[i]<0) {
        ret = 0;
        cout<<"Cannot find coefficient: "<<tmp_string[i]<<" in coef file"<<endl;
        cflush();
     }
  }
  if(!ret) {
     ERROR("\nMissing coefficients in coef file: "+propag_mat_file+"\n");
     return(0);
  }
  cout<<"Coefficients values: "<<endl;
  for(i=0;i<!tmp_coefs;i++) {
      cout<<" . "<<tmp_coefs[i].get_name();
      if(!tmp_coefs[i].constant) cout<<" not constant"<<endl;
      else {
         tmp_coefs[i].compute_value();
         cout<<" = "<<tmp_coefs[i]()<<endl;
      }
  }
  cflush();
  ret = propag_law.initialize(propag_script,propag_mat_file);
  if(ret) {
     ERROR("\nFunction initialize() failure when running script: "+propag_script+"\n");
     return(0);
  }
  cout<<"Test function initialize() ... ok"<<endl; cflush();
  Gtimes.resize(1); G.resize(1); A.resize(1); T.resize(1);
  G[0]=10.0; A[0]=0.0; T[0]=0.0;
  da = propag_law.compute_propag(Gtimes,G,A,T,dx,dy);
  cout<<"Test function compute_propag()"<<endl;
  cout<<"  G="<<G[0]<<" -> da="<<da<<endl;
  cout<<"OK"<<endl; cflush();
  cout<<"================================================="<<endl<<endl;
  cflush();
  return(1);
}

int get_default_contact()
{ ASCII_FILE old_contact;
  Zfstream fcontact;
  if(!contact_cmds) {
     old_contact.open(contact_cmds);
     if(old_contact.ok) {
        ERROR("\nContact file: "+contact_cmds+" already exist.\nRemove or change the name before setting default commands.\n");
        return(0);
     }
  } 
  else {
     contact_cmds = "default_contact.dat";
     graphics_app.set_file_selection(dname,"Contact special",contact_cmds);
     cout<<"creating cmd file with name: "<<contact_cmds<<endl; cflush();
  }
  fcontact.open(contact_cmds,ios::out);
  if(format.start_with("abaqus")) {
     fcontact << "*CONTACTPAIR,TYPE=SURFACETOSURFACE,SMALLSLIDING,INTERACTION=int_SIDE0_SIDE1"<<endl;
     fcontact << "SIDE0,SIDE1"<<endl;
     fcontact << "*SURFACEINTERACTION,NAME=int_SIDE0_SIDE1"<<endl;
     fcontact << "*SURFACEBEHAVIOR,PENALTY"<<endl;
  }
/*
  else if(format.start_with("ansys")) {
     // special KEYOPTS but dunno the num here ???
  }
*/
  else if(format.start_with("samcef")) {
     fcontact << ".MCT GROUP \"SIDE0\" GTAR \"SIDE1\" OPT 2 UN2 1 NPEN 1000"<<endl;
  }
  else if(format.start_with("zebulon")) {
     fcontact << " ***continuum_contact" << endl;
     fcontact << "  **stabilize_behavior" << endl;
     fcontact << "  **zone penalty" << endl;
     fcontact << "   *master SIDE0" << endl;
     fcontact << "   *slave  SIDE1" << endl;
     fcontact << "   *remove FRONT" << endl;
     fcontact << "   *warning_distance 0.02" << endl;
     fcontact << "   *keep_master" << endl;
     if(if_quad) fcontact << "   *add_mpc middle everywhere" << endl;
     fcontact << "   *automatic_penalty" << endl;
     //ABR---07/2021 adding this to have better statisfaction of contact constraints!
     fcontact << "   *auto_factor 10." << endl;
  }
  else if(format.start_with("aster")) {
    fcontact<<"lip_cont = DEFI_CONTACT(identifier='8:1',"<<endl;
    fcontact<<"            FORMULATION='DISCRETE',"<<endl;
    fcontact<<"            MODELE=model,"<<endl;
    fcontact<<"            ZONE=_F(GROUP_MA_ESCL=('SIDE0_aster', ),"<<endl;
    fcontact<<"            GROUP_MA_MAIT=('SIDE1_aster', )))"<<endl;
  }
  else {
     ERROR("\nCannot set default contact commands for format: "+format+"\n");
     return(0);
  }
  fcontact.close();
  return(1);
}

void remove_mesh_files()
{
  LIST<STRING> files;
  STRING filename;
  ASCII_FILE ascf;

  files.add(crack_name+".geo");
  files.add(crack_name+"_0.geo");
  files.add(cracked_name+".geo");
  files.add("TO_REMESH.geo");
  files.add("REMESHED.geo");
  files.add("REMESHED_INI.geo");
  files.add("TO_REMESH_COMPO.geo");
  files.add("TO_REASSIGN.geo");
  files.add(sane_name+"_REFINED.geo");
  files.add(sane_name+"_CRACKI.geo");
  files.add("IMPORT-new.geo");

  if(format=="abaqus_templated"){
    files.add(sane_name+".geo");
  }

  cout<< "  Remove mesh files from previous simulation"<<endl;

  for(int i=0;i<files.size();i++) {
    filename = files[i];
    ascf.open(filename);
    if(ascf.ok) {
      cout<< " - remove file : "<<filename;
      STD_RM(filename);
      cout<<" ..done"<<flush<<endl;
    }
    ascf.close();
  }
  cout<<flush<<endl;
}

int round(double x)
{
  int ret, int_part;
  int_part = x;
  if((x-int_part) > 0.5)  ret = x+1.;
  else                    ret = x;
  return(ret);
}

//ABR---05/2021
void write_gpp_aster(int cyc)
{
    STRING gpp_aster_name;
    Zfstream gpp;
    if(cyc==0)
    {
        gpp_aster_name = cracked_name + "_GPP_aster.inp";
    }
    else
    {
        gpp_aster_name = cracked_name + "_GPP_PROPAG_aster"+itoa(cyc)+".inp";
        //gpp_aster_name = cracked_name + "_PROPAG"+itoa(cyc)+".inp";
    }
    gpp.open(gpp_aster_name,ios::out);
    gpp.setf(ios::scientific);
    gpp<<"****post_processing"<<endl;
    gpp<<" ***suppress_p_on_post_files"<<endl;
    gpp<<" ***data_source med"<<endl;
    if(cyc==0)
    {
        gpp <<"  **open "<<cracked_name<<"_SIF.med"<<endl;
    }
    else
    {
        gpp <<"  **open "<<cracked_name<<"_PROPAG"<<itoa(cyc)<<".med"<<endl;
    }
    gpp<<"  **write_geo"<<endl;
    gpp<<" ***local_post_processing"<<endl;
    gpp<<"  **file node"<<endl;
    gpp<<"  **nset ALL_NODE"<<endl;
    gpp<<"  **process copy"<<endl;
    gpp<<"   *list_var RESU____DEPL.DX RESU____DEPL.DY RESU____DEPL.DZ"<<endl;
    gpp<<"   *out_var U1 U2 U3"<<endl;
    gpp<<"  **file integ"<<endl;
    gpp<<"  **elset ALL_ELEMENT"<<endl;
    gpp<<"  **process copy"<<endl;
    gpp<<"   *list_var RESU____SIEF_ELGA.SIXX RESU____SIEF_ELGA.SIYY RESU____SIEF_ELGA.SIZZ RESU____SIEF_ELGA.SIXY RESU____SIEF_ELGA.SIYZ RESU____SIEF_ELGA.SIXZ"<<endl;
    gpp<<"   *out_var sig11 sig22 sig33 sig12 sig23 sig31"<<endl;
    gpp<<"  **process copy"<<endl;
    gpp<<"   *list_var RESU____EPME_ELGA.EPXX RESU____EPME_ELGA.EPYY RESU____EPME_ELGA.EPZZ RESU____EPME_ELGA.EPXY RESU____EPME_ELGA.EPYZ RESU____EPME_ELGA.EPXZ"<<endl;
    gpp<<"   *out_var eto11 eto22 eto33 eto12 eto23 eto31"<<endl;
    //ABR---06/2021 for fetching reactions....required for cracks involving contact!
    gpp<<" ***global_post_processing"<<endl;
    gpp<<"  **output_to_node"<<endl;
    gpp<<"  **file integ"<<endl;
    gpp<<"  **elset ALL_ELEMENT"<<endl;
    gpp<<"  **process integrate_flux"<<endl;
    gpp<<"   *flux sig"<<endl;
    gpp<<"   *force RU"<<endl;
//    gpp<<" ***global_post_processing"<<endl;
//    gpp<<"  **file node"<<endl;
//    gpp<<"  **deformed"<<endl;
//    gpp<<"  **nset ALL_NODE"<<endl;
//    gpp<<"  **process strain_measure"<<endl;
//    gpp<<"   *strain_prefix eto"<<endl;
//    gpp<<"   *measure sd"<<endl;
    gpp<<"****return"<<endl;
    gpp.close();
}

int diff_mesh(STRING& gm1, STRING& gm2)
{ UTILITY_MESH m1, m2;
  VECTOR v;
  m1.name = gm1; m2.name = gm2;
  m1.load("Z7"); m2.load("Z7");
  if(!m1.nodes != !m2.nodes) return(1);
  if(!m1.elements != !m2.elements) return(1);
  for(i=0;i<!m1.nodes;i++) {
     v =  m1.nodes[i].position;
     v -= m2.nodes[i].position;
     if(v.norm()>1.e-9) return(1);
  }
  return(0);
}

void check_mesh_quality(STRING mesh_to_check)
{
  STRING mesher_cmd, out_mesh;
  out_mesh = mesh_to_check;
  out_mesh.remove_suffix();
  out_mesh = out_mesh + "_quality_checked.geof";
  mesher_cmd = "**check_quality *elset_to_check "+elset_name+" *quality_threshold "+dtoa(max_quality)+" *histo_write_to_file";
  apply_mesher(mesh_to_check,out_mesh,mesher_cmd);
}

void geo_to_geof(STRING geo_name)
{
  STRING mesher_cmd;
  mesher_cmd = "**open " + geo_name + "\n";
  apply_mesher(geo_name,geo_name+".geof",mesher_cmd);
}

